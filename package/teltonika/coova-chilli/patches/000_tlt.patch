diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2016-12-15 17:28:43.000000000 +0000
+++ src/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,132 +0,0 @@
-# Object files
-*.o
-*.ko
-*.lo
-
-# Libraries
-*.lib
-*.a
-*.la
-
-# Shared objects (inc. Windows DLLs)
-*.dll
-*.so
-*.so.*
-*.dylib
-
-# Executables
-*.exe
-*.out
-*.app
-
-**/.deps
-**/.libs
-
-Makefile
-Makefile.in
-bstring/Makefile
-bstring/Makefile.in
-conf/Makefile
-conf/Makefile.in
-debian/Makefile
-debian/Makefile.in
-distro/Makefile
-distro/Makefile.in
-doc/Makefile
-doc/Makefile.in
-json/Makefile
-json/Makefile.in
-json/json_config.h
-json/json_config.h.in
-json/stamp-h2
-miniportal/Makefile
-miniportal/Makefile.in
-src/Makefile
-src/Makefile.in
-src/mssl/Makefile
-src/mssl/Makefile.in
-www/Makefile
-www/Makefile.in
-
-aclocal.m4
-compile
-conf/CoovaChilliLib.py
-conf/chilli
-conf/chilli.conf
-conf/defaults
-conf/down.sh
-conf/functions
-conf/newmulti.sh
-conf/up.sh
-conf/wpad.dat
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-configure.status
-coova-doxygen
-depcomp
-distro/nethserver/coova-chilli.spec
-distro/redhat/coova-chilli.spec
-distro/suse/coova-chilli.spec
-doc/chilli-radius.5
-doc/chilli.8
-doc/chilli.conf.5
-doc/chilli_opt.1
-doc/chilli_proxy.1
-doc/chilli_query.1
-doc/chilli_radconfig.1
-doc/chilli_radsec.1
-doc/chilli_redir.1
-doc/chilli_response.1
-doc/chilli_rtmon.1
-doc/chilli_script.1
-install-sh
-libtool
-ltmain.sh
-m4/
-missing
-stamp-h1
-
-src/chilli
-src/chilli_opt
-src/chilli_query
-src/chilli_radconfig
-src/chilli_response
-src/chilli_proxy
-src/chilli_radsec
-src/chilli_redir
-src/chilli_rtmon
-src/chilli_script
-
-www/config.sh
-miniportal/config-local.sh
-miniportal/contact.chi
-miniportal/error.chi
-miniportal/functions.sh
-miniportal/login.chi
-miniportal/map.chi
-miniportal/payment.chi
-miniportal/payment.sh
-miniportal/register.chi
-miniportal/service.chi
-miniportal/status.chi
-miniportal/terms.chi
-miniportal/tos.chi
-miniportal/uam.sh
-miniportal/wispr.sh
-
-src/cmdline.[ch]
-src/cmdline.c.orig
-autom4te.cache
-
-debian/coova-chilli.debhelper.log
-debian/coova-chilli.postinst.debhelper
-debian/coova-chilli.postrm.debhelper
-debian/coova-chilli.prerm.debhelper
-debian/coova-chilli.substvars
-debian/coova-chilli/
-debian/files
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitlab-ci.yml src/.gitlab-ci.yml
--- upstream/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/Makefile.am src/Makefile.am
--- upstream/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -9,3 +9,6 @@
 if WITH_MINIPORTAL
 SUBDIRS += miniportal
 endif
+#if WITH_UBUS
+#SUBDIRS += lchilli
+#endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/README.md src/README.md
--- upstream/README.md	2016-12-15 17:28:43.000000000 +0000
+++ src/README.md	2025-07-03 10:02:27.000000000 +0000
@@ -27,3 +27,14 @@
   `make`
 
 More details about the build process and dependencies are covered in the [INSTALL file](/INSTALL)
+
+## UBUS Methods
+
+The following methods are exposed over `ubus`:
+
+**Object: chilli**
+
+Path | Procedure | Signature | Description
+--- | --- | --- | ---
+chilli | list | `{"ip":"String","mac":"String","sessionid":"String"}` | List sessions. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional).
+chilli | logout | `{"ip":"String","mac":"String","sessionid":"String"}` | Logoff active user. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional). At least one parameter required.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/changelog src/changelog
--- upstream/changelog	1970-01-01 00:00:00.000000000 +0000
+++ src/changelog	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,9 @@
+# 2019-12-19
+	*New
+		* SMS authentication added
+		* MAC based authentication added
+		* Signup method added
+		* Additional user scripts added
+		* New session param added "expirationtime"
+		* TOS requirement added
+		* Configurable url params added
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/Makefile.am src/conf/Makefile.am
--- upstream/conf/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -20,8 +20,8 @@
 	-e 's,@ETCDIR\@,$(sysconfdir),g' \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(initrddir),g' \
-	-e 's,@VARTMP\@,$(localstatedir)/tmp,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARTMP\@,$(localstatedir),g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/down.sh.in src/conf/down.sh.in
--- upstream/conf/down.sh.in	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/down.sh.in	2025-07-03 10:02:27.000000000 +0000
@@ -4,23 +4,95 @@
 # down.sh /dev/tun0 192.168.0.10 255.255.255.0
 
 TUNTAP=$(basename $DEV)
+RT_TABLES_FILE="/etc/iproute2/rt_tables"
+
 UNDO_FILE=@VARRUN@/chilli.$TUNTAP.sh
+RT_TABLES_LOCK_FILE=@VARRUN@/rt_tables.lock
+LOCK_FILE=@VARRUN@/down.lock
 
 . @SYSCONFDIR@/chilli/functions
+. /lib/functions.sh
+
+remove_routing_table() {
+    local table_num="$1"
+    local interface="$2"
+    local entry="${table_num} ${interface}"
+
+    lock -w "$RT_TABLES_LOCK_FILE"
+
+    grep -q "^${entry}$" "$RT_TABLES_FILE" && {
+        sed -i "/^${entry}$/d" "$RT_TABLES_FILE"
+        ip route flush table "$table_num"
+        ip rule flush table "$table_num"
+    }
+
+    lock -u "$RT_TABLES_LOCK_FILE"
+}
+
+restore_lan() {
+    local device ipaddr
+    config_get device $1 device
+    config_get ipaddr $1 ipaddr
+    config_get netmask $1 netmask
+
+    [ "$device" == "$2" ] && [ -n "$ipaddr" ] && {
+        ip addr replace $ipaddr/$netmask broadcast + dev $2
+        ip link set $2 up
+    }
+}
 
 run_down() {
     [ -e "$UNDO_FILE" ] && sh $UNDO_FILE 2>/dev/null
     rm -f $UNDO_FILE 2>/dev/null
+
+    [ -n "$TUNTAP" ] && [ "$KNAME" != "" ] && {
+        local virtual="ifb0"
+        local interfaces=$DHCPIF
+        [ -n "$MOREIF" ] && {
+            for iface in $MOREIF; do
+                interfaces="$interfaces $iface"
+            done
+        }
+
+        local index=100
+        for iface in $interfaces; do
+            tc qdisc show dev $iface 2>/dev/null | grep -q '^qdisc htb 1:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del root dev $iface >/dev/null 2>&1 && break
+                    sleep 2
+                done
+            }
+            tc qdisc show dev $virtual 2>/dev/null | grep -q '^qdisc htb 2:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del root dev $virtual >/dev/null 2>&1 && break
+                    sleep 2
+                done
+                ip link set dev $virtual down
+                ip link delete name $virtual
+            }
+            tc qdisc show dev $iface 2>/dev/null | grep -q '^qdisc ingress ffff:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del dev $iface handle ffff: ingress >/dev/null 2>&1 && break
+                    sleep 2
+                done
+            }
+            ip addr flush dev $iface
+            ip link set $iface up
+            config_load network
+            config_foreach restore_lan interface "$iface"
+            [ -n "$MOREIF" ] && remove_routing_table "$index" "$iface"
+            index=$((index + 1))
+        done
+    }
     
     # site specific stuff optional
     [ -e @SYSCONFDIR@/chilli/ipdown.sh ] && . @SYSCONFDIR@/chilli/ipdown.sh
 }
 
-FLOCK=$(which flock)
-if [ -n "$FLOCK" ] && [ -z "$LOCKED_FILE" ]
-then
-    export LOCKED_FILE=/tmp/.chilli-flock
-    flock -x $LOCKED_FILE -c "$0 $@"
-else
-    run_down
-fi
+lock -w "$LOCK_FILE"
+
+trap 'lock -u '"$LOCK_FILE"'' EXIT
+
+run_down
+
+exit 0
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/cloud4wi src/conf/profiles/configs/cloud4wi
--- upstream/conf/profiles/configs/cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/cloud4wi	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,33 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamserver 'https://splashportal.cloud4wi.com?vendor=teltonika'
+	option radiusserver1 '54.247.117.188'
+	option radiusserver2 '79.125.111.180'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_cloud4wi'
+	option paramuamip 'nas_ip'
+	option paramuamport 'nas_port'
+	option paramcalled 'ap_mac'
+	option parammac 'client_mac'
+	option paramip 'client_ip'
+	option paramnasid 'identifer'
+	option paramuserurl 'redirect_url'
+	option param1 'version'
+	option param1value ''
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/default src/conf/profiles/configs/default
--- upstream/conf/profiles/configs/default	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/default	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,19 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _mode 'local'
+	option _landingpage 'int'
+	option _success 'uam'
+	option _protocol 'http'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/hotspotsystems src/conf/profiles/configs/hotspotsystems
--- upstream/conf/profiles/configs/hotspotsystems	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/hotspotsystems	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,26 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_hs
+	option uamserver 'https://customer.hotspotsystem.com/customer/hotspotlogin.php'
+	option uamsecret 'hotsys123'
+	option radiusserver1 'radius.hotspotsystem.com'
+	option radiusserver2 'radius2.hotspotsystem.com'
+	option radiussecret 'hotsys123'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/purple src/conf/profiles/configs/purple
--- upstream/conf/profiles/configs/purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/purple	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,31 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option _https '0'
+	option tos '0'
+	option trialusers '0'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_purple'
+	option uamserver 'https://purpleportal.net/access/'
+	option uamsecret ''
+	option radiusserver1 ''
+	option radiusserver2 ''
+	option radiussecret ''
+	option radiusnasid 'guest'
+	option swapoctets '1'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_cloud4wi src/conf/profiles/uamdomains/uamdomainfile_cloud4wi
--- upstream/conf/profiles/uamdomains/uamdomainfile_cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_cloud4wi	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,5 @@
+cloud4wi.com
+facebook.com
+facebook.net
+flinkedin.com
+licdn.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_hs src/conf/profiles/uamdomains/uamdomainfile_hs
--- upstream/conf/profiles/uamdomains/uamdomainfile_hs	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_hs	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,2 @@
+hotspotsystem.com
+facebook.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_purple src/conf/profiles/uamdomains/uamdomainfile_purple
--- upstream/conf/profiles/uamdomains/uamdomainfile_purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_purple	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,5 @@
+purpleportal.net
+venuewifi.com
+cloudfront.net
+openweathermap.org
+stripe.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/up.sh.in src/conf/up.sh.in
--- upstream/conf/up.sh.in	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/up.sh.in	2025-07-03 10:02:27.000000000 +0000
@@ -1,7 +1,10 @@
 #!/bin/sh
 
 TUNTAP=$(basename $DEV)
+RT_TABLES_FILE="/etc/iproute2/rt_tables"
+
 UNDO_FILE=@VARRUN@/chilli.$TUNTAP.sh
+RT_TABLES_LOCK_FILE=@VARRUN@/rt_tables.lock
 
 . @SYSCONFDIR@/chilli/functions
 
@@ -9,98 +12,125 @@
 rm -f $UNDO_FILE 2>/dev/null
 
 ipt() {
-    opt=$1; shift
-    echo "iptables -D $*" >> $UNDO_FILE
-    iptables $opt $*
+	opt=$1; shift
+	echo "iptables --wait -D $*" >> $UNDO_FILE
+	iptables --wait $opt $*
+}
+
+add_routing_table() {
+	local table_num="$1"
+	local interface="$2"
+	local entry="${table_num} ${interface}"
+
+	lock -w "$RT_TABLES_LOCK_FILE"
+
+	grep -q " ${interface}$" "$RT_TABLES_FILE" && {
+		sed -i "s/^.* ${interface}$/${entry}/" "$RT_TABLES_FILE"
+	} || {
+		echo "$entry" >>"$RT_TABLES_FILE"
+	}
+
+	lock -u "$RT_TABLES_LOCK_FILE"
+}
+
+add_nat_rule() {
+	local has_dhcp="$(jsonfilter -i /etc/board.json -e '@.network.dhcp.proto')"
+	[ "$has_dhcp" = "dhcp" ] || return
+
+	ipt -I POSTROUTING -t nat -s $ADDR/$MASK -j MASQUERADE
+	ipt -I POSTROUTING -t nat -s $DHCPLISTEN/$MASK -j MASQUERADE
 }
 
-ipt_in() {
-    ipt -I INPUT -i $TUNTAP $*
+chain_exists() {
+	local timeout=5
+	local elapsed=0
+	local sleep_interval=1
+	local chain_name="$1"
+
+	while [ $elapsed -lt $timeout ]; do
+		if iptables -w $timeout -L $chain_name -n &>/dev/null; then
+			return 0
+		fi
+		sleep $sleep_interval
+		elapsed=$((elapsed + sleep_interval))
+	done
+
+	return 1
 }
 
-run_up() {
-    if [ -n "$TUNTAP" ]
-    then
-        # ifconfig $TUNTAP mtu $MTU
+if [ -n "$TUNTAP" ]
+then
 	if [ "$KNAME" != "" ]
 	then
-	    ipt -I FORWARD -i $DHCPIF -m coova --name $KNAME -j ACCEPT 
-	    ipt -I FORWARD -o $DHCPIF -m coova --name $KNAME --dest -j ACCEPT
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    [ -n "$DHCPLISTEN" ] && ifconfig $DHCPIF $DHCPLISTEN
-	else
-	    if [ "$LAYER3" != "1" ]
-	    then
-		ipt_in --dst $ADDR -j DROP
-		
-		[ -n "$UAMPORT" -a "$UAMPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$UAMUIPORT" -a "$UAMUIPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMUIPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$HS_TCP_PORTS" ] && {
-		    for port in $HS_TCP_PORTS; do
-			ipt_in -p tcp -m tcp --dport $port --dst $ADDR -j ACCEPT
-		    done
+		interfaces=$DHCPIF
+		[ -n "$MOREIF" ] && {
+			for iface in $MOREIF; do
+				interfaces="$interfaces $iface"
+			done
+		}
+
+		chain_exists zone_hotspot_input && {
+			ipt -I input_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j zone_hotspot_input
+			ipt -I input_rule -d $DHCPLISTEN/$MASK -m coova --name $KNAME --dest -j ACCEPT
+		} || {
+			[ -n "$UAMPORT" ] && ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport $UAMPORT -m coova --name $KNAME -j ACCEPT
+			[ -n "$UAMUIPORT" ] && ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport $UAMUIPORT -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport 81 -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport 444 -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p udp -m udp --dport 53 -m coova --name $KNAME -j ACCEPT
 		}
 
-		[ -n "$HS_UDP_PORTS" ] && {
-		    for port in $HS_UDP_PORTS; do
-			ipt_in -p udp -m udp --dport $port --dst $ADDR -j ACCEPT
-		    done
+		chain_exists zone_hotspot_forward && \
+			ipt -I forwarding_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j zone_hotspot_forward || \
+			ipt -I forwarding_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j ACCEPT
+		ipt -I forwarding_rule -d $DHCPLISTEN/$MASK -m coova --name $KNAME --dest -j ACCEPT
+
+		ipt -I forwarding_rule -s $ADDR/$MASK -j ACCEPT
+		ipt -I forwarding_rule -d $ADDR/$MASK -j ACCEPT
+
+		add_nat_rule
+
+		index=100
+		for iface in $interfaces; do
+			ipt -A PREROUTING -t nat -i $iface -p udp --dport 53 -j DNAT --to-destination $ADDR
+			ipt -A input_rule -i $iface -j DROP
+			ipt -A input_rule -o $iface -j DROP
+
+			ipt -A forwarding_rule -i $iface -j DROP
+			ipt -A forwarding_rule -o $iface -j DROP
+
+			ip addr flush dev $iface
+			ip addr replace $DHCPLISTEN/$MASK broadcast + dev $iface
+			ip link set $iface up
+
+			[ -n "$MOREIF" ] && add_routing_table "$index" "$iface"
+			index=$((index + 1))
+		done
+	else
+		IFS=' '
+		IFS=$' \t\n'
+
+		[ "$HS_LOCAL_DNS" = "on" ] && {
+			ipt -A PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 		}
 
-		ipt_in -p udp -d 255.255.255.255 --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp -d $ADDR --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp --dst $ADDR --dport 53 -j ACCEPT
-		ipt_in -p icmp --dst $ADDR -j ACCEPT
-		
+		ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+		ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+
 		if [ "$ONLY8021Q" != "1" ]
 		then
-		    ipt -I INPUT -i $DHCPIF -j DROP
+			ipt -I FORWARD -o $DHCPIF -j DROP
+			ipt -A forwarding_rule -i $DHCPIF -j DROP
+		fi
+		if [ "$LAYER3" != "1" ]
+		then
+			if [ "$ONLY8021Q" != "1" ]
+			then
+				ipt -I INPUT -i $DHCPIF -j DROP
+			fi
 		fi
-	    fi
-	    
-	    if [ "$ONLY8021Q" != "1" ]
-	    then
-		ipt -I FORWARD -i $DHCPIF -j DROP
-		ipt -I FORWARD -o $DHCPIF -j DROP
-	    fi
-	    
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    
-            # Help out conntrack to not get confused
-            # (stops masquerading from working)
-            #ipt -I PREROUTING -t raw -j NOTRACK -i $DHCPIF
-            #ipt -I OUTPUT -t raw -j NOTRACK -o $DHCPIF
-	    
-            # Help out MTU issues with PPPoE or Mesh
-	    ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    
-	    [ "$HS_LAN_ACCESS" != "on" -a "$HS_LAN_ACCESS" != "allow" ] && \
-		ipt -I FORWARD -i $TUNTAP \! -o $HS_WANIF -j DROP
-	    
-	    ipt -I FORWARD -i $TUNTAP -o $HS_WANIF -j ACCEPT
-	    
-	    [ "$HS_LOCAL_DNS" = "on" ] && \
-		ipt -I PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 	fi
-    fi
-
-    # site specific stuff optional
-    [ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
-}
-
-
-FLOCK=$(which flock)
-if [ -n "$FLOCK" ] && [ -z "$LOCKED_FILE" ]
-then
-    export LOCKED_FILE=/tmp/.chilli-flock
-    flock -x $LOCKED_FILE -c "$0 $@"
-else
-    run_up
 fi
+
+# site specific stuff optional
+[ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/configure.ac src/configure.ac
--- upstream/configure.ac	2016-12-15 17:28:43.000000000 +0000
+++ src/configure.ac	2025-07-03 10:02:27.000000000 +0000
@@ -154,8 +154,17 @@
    AC_DEFINE(ENABLE_CHILLIQUERY,1,[Define to enable chilli_query])
 fi
 
+AC_ARG_ENABLE(ubus, [AS_HELP_STRING([--disable-ubus],[Disable ubus])],
+  enable_ubus=$enableval, enable_ubus=yes)
+
+if test x"$enable_ubus" = xyes; then
+   AC_DEFINE(ENABLE_UBUS,1,[Define to enable ubus])
+fi
+
 AM_CONDITIONAL(WITH_CHILLIQUERY, [test x"$enable_chilliquery" != xno])
 
+AM_CONDITIONAL(WITH_UBUS, [test x"$enable_ubus" != xno])
+
 AC_ARG_ENABLE(leakybucket, [AS_HELP_STRING([--disable-leakybucket],[disable use of leaky bucket shaping])], 
   enable_leakybucket=$enableval, enable_leakybucket=yes)
 
@@ -206,7 +215,7 @@
 fi
 
 AC_ARG_ENABLE(json, [AS_HELP_STRING([--enable-json],[Enable support for JSON])], 
-  enable_json=$enableval, enable_json=no)
+  enable_json=$enableval, enable_json=yes)
 
 if test x"$enable_json" = xyes; then
    AC_DEFINE(ENABLE_JSON,1,[Define to enable Chilli JSON])
@@ -396,6 +405,9 @@
 AC_ARG_WITH([cyassl],
  [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
 
+AC_ARG_WITH([cyassl],
+ [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
+
 AS_IF([test x"$with_cyassl" != xno],
   [AC_CHECK_LIB([cyassl], [CyaSSL_Init],
               [AC_SUBST([LIBSSL], ["-lcyassl"])
@@ -511,13 +523,13 @@
 
 AS_IF([test x"$with_curl" != xno],
   [AC_CHECK_LIB([curl], [curl_global_init],
-              [AC_SUBST([LIBCURL], ["-lcurl -lz -lssl -lcrypto -lcares"])
+              [AC_SUBST([LIBCURL], ["-lcurl -lz -lssl -lcrypto"])
                AC_DEFINE([USING_CURL], [1],
                          [Define if you have curl enabled])
               ],
               [AC_MSG_FAILURE(
                  [--with-curl was given, but test for curl failed])],
-              [-lz -lssl -lcrypto -lcares])])
+              [-lz -lssl -lcrypto])])
 
 AM_CONDITIONAL(WITH_CURL, [test x"$with_curl" != xno])
 
@@ -598,6 +610,24 @@
 
 AM_CONDITIONAL(WITH_CHILLIREDIR, [test x"$enable_chilliredir" = xyes])
 
+AC_ARG_ENABLE(database, [AS_HELP_STRING([--enable-database],[Enable support sqlite database])],
+  enable_database=$enableval, enable_database=no)
+
+if test x"$enable_database" = xyes; then
+   AC_DEFINE(ENABLE_DATABASE,1,[Define to enable sqlite database])
+fi
+
+AM_CONDITIONAL(WITH_DATABASE, [test x"$enable_database" = xyes])
+
+AC_ARG_ENABLE(gsm, [AS_HELP_STRING([--enable-gsm],[Enable gsm support])],
+  enable_gsm=$enableval, enable_gsm=no)
+
+if test x"$enable_gsm" = xyes; then
+   AC_DEFINE(ENABLE_GSM,1,[Define to enable gsm support])
+fi
+
+AM_CONDITIONAL(WITH_GSM, [test x"$enable_gsm" = xyes])
+
 AC_ARG_ENABLE(chilliscript, [AS_HELP_STRING([--enable-chilliscript],[Enable support for chilli_script helper])], 
   enable_chilliscript=$enableval, enable_chilliscript=no)
 
@@ -830,7 +860,7 @@
 AM_CONDITIONAL(WITH_CONFIG, [test x"$enable_config" = xyes])
 
 AC_SUBST(sysconfdir)
-AC_CONFIG_FILES([Makefile 
+AC_CONFIG_FILES([Makefile
 		 bstring/Makefile 
 		 conf/Makefile
 		 debian/Makefile
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/Makefile.am src/doc/Makefile.am
--- upstream/doc/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -10,7 +10,7 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(sysconfdir)/init.d,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/attributes src/doc/attributes
--- upstream/doc/attributes	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/attributes	2025-07-03 10:02:27.000000000 +0000
@@ -8,7 +8,7 @@
 Service-Type      :     6 : Integer : X : - : X : - : - : Set to Login (1) for normal authentication requests.  The Access-Accept message from the radius server for configuration management messages must also be set to Administrative-User.
 Framed-IP-Address : 	8 : IPaddr  : X : X : X : - : - : IP address of the user, which is configurable during MAC authentication in the Access-Accept.
 Framed-IP-Netmask : 	9 : IPaddr  : - : X : - : - : - : IP netmask of the user, which is configurable during MAC authentication in the Access-Accept.
-Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly. 
+Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly.
 Reply-Message     :    18 : String  : - : X : - : - : - : Reason of reject if present.
 State             :    24 : String  : X : X : - : - : - : Sent to chilli in Access-Accept or Access-Challenge. Used transparently in subsequent Access-Request.
 Class             :    25 : String  : - : X : X : - : - : Copied transparently by chilli from Access-Accept to Accounting-Request.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/chilli.conf.5.in src/doc/chilli.conf.5.in
--- upstream/doc/chilli.conf.5.in	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/chilli.conf.5.in	2025-07-03 10:02:27.000000000 +0000
@@ -889,11 +889,6 @@
 .RE
 
 .TP
-.BI localusers " file"
-A colon seperated file containing usernames and passwords of locally
-authenticated users. 
-
-.TP
 .BI postauthproxy " ipaddress"
 Used with
 .B postauthproxyport
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/chilli_query.1.in src/doc/chilli_query.1.in
--- upstream/doc/chilli_query.1.in	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/chilli_query.1.in	2025-07-03 10:02:27.000000000 +0000
@@ -115,6 +115,10 @@
 Sets the max output data limit of the session.
 
 .TP
+.BI warningoctets " <number-of-bytes>"
+Sets the data threshold for the session over which an SMS warning is sent.
+
+.TP
 .BI maxbwup " <bandwidth>"
 Sets the max up bandwidth of the session.
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/dictionary.coovachilli src/doc/dictionary.coovachilli
--- upstream/doc/dictionary.coovachilli	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/dictionary.coovachilli	2025-07-03 10:02:27.000000000 +0000
@@ -54,6 +54,7 @@
 ATTRIBUTE	CoovaChilli-Location		       25	string
 ATTRIBUTE	CoovaChilli-Old-Location		       26	string
 ATTRIBUTE	CoovaChilli-Location-Change-Count       27	integer
+ATTRIBUTE	CoovaChilli-SSID       28	string
 
 ATTRIBUTE	CoovaChilli-Sys-Uptime		       40	integer
 ATTRIBUTE	CoovaChilli-Sys-LoadAvg		       41	string
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/json/linkhash.c src/json/linkhash.c
--- upstream/json/linkhash.c	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.c	2025-07-03 10:02:27.000000000 +0000
@@ -52,15 +52,6 @@
 	return 0;
 }
 
-void lh_abort(const char *msg, ...)
-{
-	va_list ap;
-	va_start(ap, msg);
-	vprintf(msg, ap);
-	va_end(ap);
-	exit(1);
-}
-
 static unsigned long lh_ptr_hash(const void *k)
 {
 	/* CAW: refactored to be 64bit nice */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/json/linkhash.h src/json/linkhash.h
--- upstream/json/linkhash.h	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.h	2025-07-03 10:02:27.000000000 +0000
@@ -294,21 +294,6 @@
 extern int lh_table_length(struct lh_table *t);
 
 /**
- * Prints a message to <code>stdout</code>,
- * then exits the program with an exit code of <code>1</code>.
- *
- * @param msg Message format string, like for <code>printf</code>.
- * @param ... Format args.
- *
- * @deprecated Since it is not a good idea to exit the entire program
- * 	because of an internal library failure, json-c will no longer
- * 	use this function internally.
- * 	However, because its interface is public, it will remain part of
- * 	the API on the off chance of legacy software using it externally.
- */
-void lh_abort(const char *msg, ...);
-
-/**
  * Resizes the specified table.
  *
  * @param t Pointer to table to resize.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/miniportal/Makefile.am src/miniportal/Makefile.am
--- upstream/miniportal/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/miniportal/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -27,8 +27,8 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(initrddir),g' \
-	-e 's,@VARTMP\@,$(localstatedir)/tmp,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARTMP\@,$(localstatedir),g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/Makefile.am src/src/Makefile.am
--- upstream/src/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/src/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -12,34 +12,35 @@
 tun.h ippool.h md5.h redir.h dhcp.h iphash.h \
 radius_wispr.h radius_coovachilli.h ssl.h dns.h net.h \
 pkt.h conn.h lookup.h chilli_limits.h cmdline.h debug.h \
-radius_pkt.h ../bstring/bstrlib.h ../config.h system.h 
+radius_pkt.h ../bstring/bstrlib.h ../config.h system.h \
+ sqlite.h users.h
 
 lib_LTLIBRARIES = libchilli.la
 sbin_PROGRAMS = \
-chilli chilli_response chilli_radconfig chilli_opt 
+chilli chilli_response chilli_radconfig chilli_opt
 
 suid_programs =
 
 libchilli_la_SOURCES = \
 chilli.c tun.c ippool.c radius.c md5.c redir.c dhcp.c \
 iphash.c lookup.c system.h util.c options.c statusfile.c conn.c sig.c \
-garden.c dns.c session.c pkt.c chksum.c net.c safe.c
+garden.c dns.c session.c pkt.c chksum.c net.c safe.c sqlite.c users.c
 
 AM_CFLAGS = -D_GNU_SOURCE -Wall -Werror -fno-builtin -fno-strict-aliasing \
   -fomit-frame-pointer -funroll-loops -pipe -I$(top_builddir)/bstring \
  -DDEFCHILLICONF='"$(sysconfdir)/chilli.conf"'\
- -DDEFPIDFILE='"$(localstatedir)/run/chilli.pid"'\
- -DDEFSTATEDIR='"$(localstatedir)/run"'\
- -DSBINDIR='"$(sbindir)"' 
+ -DDEFPIDFILE='"$(localstatedir)/chilli.pid"'\
+ -DDEFSTATEDIR='"$(localstatedir)"'\
+ -DSBINDIR='"$(sbindir)"'
 
 chilli_SOURCES= main.c
-chilli_radconfig_SOURCES = main-radconfig.c 
-chilli_response_SOURCES = main-response.c 
-chilli_query_SOURCES = main-query.c 
-chilli_opt_SOURCES = main-opt.c 
+chilli_radconfig_SOURCES = main-radconfig.c
+chilli_response_SOURCES = main-response.c
+chilli_query_SOURCES = main-query.c
+chilli_opt_SOURCES = main-opt.c
 
-libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la 
-LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON}
+libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la -lsqlite3 -luci -ltlt_uci -lcap
+LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON} -lsqlite3 -lcap
 
 if WITH_MINICONFIG
 chilli_opt_SOURCES += cmdline.mini.c
@@ -54,7 +55,7 @@
 if WITH_JSONLIB
 AM_CFLAGS += -I$(top_builddir)/json
 libchilli_la_LIBADD += $(top_builddir)/json/libjson.la 
-LDADD += $(top_builddir)/json/libjson.la 
+LDADD += $(top_builddir)/json/libjson.la
 endif
 
 if WITH_EWTAPI
@@ -75,6 +76,8 @@
 endif
 
 if WITH_OPENSSL
+libchilli_la_SOURCES += passwd_md5crypt.c passwd_shacrypt.c
+chilliinclude_HEADERS += passwd_md5crypt.h passwd_shacrypt.h
 libchilli_la_LIBADD += ${LIBSSL}
 LDADD += ${LIBSSL}
 endif
@@ -93,6 +96,31 @@
 endif
 endif
 
+if WITH_GSM
+libchilli_la_SOURCES += gsm.c
+chilliinclude_HEADERS += gsm.h
+libchilli_la_LIBADD += -lgsm -lgsm_utils
+LDADD += -lgsm
+endif
+
+if WITH_DATABASE
+libchilli_la_SOURCES += database.c
+chilliinclude_HEADERS += database.h
+endif
+
+if WITH_CURL
+libchilli_la_SOURCES += oauth2.c
+chilliinclude_HEADERS += oauth2.h
+LDADD += ${LIBCURL} 
+endif
+
+if WITH_UBUS
+chilliinclude_HEADERS += ubus.h
+libchilli_la_SOURCES += ubus.c
+libchilli_la_LIBADD += -lubox -lubus
+LDADD += -lubox -lubus
+endif
+
 if WITH_AVL
 libchilli_la_SOURCES += avl/avl.c avl/avl.h avl/list.h \
 avl/common_types.h avl/container_of.h
@@ -131,9 +159,6 @@
 sbin_PROGRAMS += chilli_proxy
 chilli_proxy_SOURCES = main-proxy.c 
 chilli_proxy_LDADD = ${LDADD}
-if WITH_CURL
-chilli_proxy_LDADD += ${LIBCURL} 
-endif
 endif
 
 if WITH_CHILLIRADSEC
@@ -153,9 +178,6 @@
 sbin_PROGRAMS += chilli_redir
 chilli_redir_SOURCES = main-redir.c 
 chilli_redir_LDADD = ${LDADD}
-if WITH_CURL
-chilli_redir_LDADD += ${LIBCURL} 
-endif
 endif
 
 if WITH_NETFILTER_COOVA
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli.c src/src/chilli.c
--- upstream/src/chilli.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.c	2025-07-03 10:02:27.000000000 +0000
@@ -20,10 +20,13 @@
 
 #include "chilli.h"
 #include "bstrlib.h"
+#include "ubus.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
 #endif
 
+
+
 struct tun_t *tun;                /* TUN instance            */
 struct ippool_t *ippool;          /* Pool of IP addresses */
 struct radius_t *radius;          /* Radius client instance */
@@ -42,6 +45,9 @@
 struct app_conn_t *lastusedconn=0;  /* Last used in linked list */
 struct app_conn_t admin_session;
 
+struct ubus_context *g_ubus_event_ctx; /* Ubus for sending events
+                                          about connected/disconnected clients */
+
 struct timespec mainclock;
 time_t checktime;
 time_t rereadtime;
@@ -80,6 +86,8 @@
 static pid_t redir_pid = 0;
 #endif
 
+
+
 typedef struct child {
   pid_t pid;
   uint8_t type;
@@ -214,7 +222,7 @@
   while ((read = getline(&line, &len, fp)) != -1) {
     if (!memcmp(line, name, strlen(name))) {
       int i;
-      if (sscanf(line+strlen(name)+1, "%d %s", &i, buffer) == 2) {
+      if (sscanf(line+strlen(name)+1, "%d %128s", &i, buffer) == 2) {
 	ret = i;
 	if (buffer[0] == 'm') ret *= 1000;
 	else if (buffer[0] == 'g') ret *= 1000000;
@@ -463,7 +471,7 @@
 #ifdef HAVE_LIBRT
   struct timespec ts;
 #if defined(CLOCK_MONOTONIC)
-  clockid_t cid = CLOCK_MONOTONIC;
+  clockid_t cid = _options.testtime ? CLOCK_REALTIME : CLOCK_MONOTONIC;
 #else
   clockid_t cid = CLOCK_REALTIME;
 #endif
@@ -547,13 +555,31 @@
   return d;
 }
 
+const char *get_mac_format() {
+  if (_options.maclower) {
+    switch (_options.macdelimiter) {
+      case MAC_DELIM_DASH: return MAC_FMT_LOWER_DASH;
+      case MAC_DELIM_COLON: return MAC_FMT_LOWER_COLON;
+      case MAC_DELIM_NONE: return MAC_FMT_LOWER_NONE;
+    }
+    return MAC_FMT_LOWER_DASH;
+  }
+
+  switch (_options.macdelimiter) {
+    case MAC_DELIM_DASH: return MAC_FMT_UPPER_DASH;
+    case MAC_DELIM_COLON: return MAC_FMT_UPPER_COLON;
+    case MAC_DELIM_NONE: return MAC_FMT_UPPER_NONE;
+  }
+  return MAC_FMT_UPPER_DASH;
+}
+
 uint8_t* chilli_called_station(struct session_state *state) {
 #ifdef ENABLE_LOCATION
   if (_options.location_copy_called && state->redir.calledlen) {
     return state->redir.called;
   }
 #endif
-  return dhcp_nexthop(dhcp);
+  return dhcp_nexthop(dhcp, 0);
 }
 
 static void set_sessionid(struct app_conn_t *appconn, char full) {
@@ -569,7 +595,7 @@
 #ifdef ENABLE_SESSIONID
   if (full) {
     uint8_t * his = appconn->hismac;
-    uint8_t * called = dhcp_nexthop(dhcp);
+    uint8_t * called = dhcp_nexthop(dhcp, 0);
     snprintf(appconn->s_state.chilli_sessionid,
 		  sizeof(appconn->s_state.chilli_sessionid),
 		  "SES-"
@@ -738,17 +764,17 @@
       break;
 
     case VAL_ULONG:
-      snprintf(s, sizeof(s), "%ld", (long int)*(uint32_t *)value);
+      snprintf(s, sizeof(s), "%" PRIu32, *(uint32_t *)value);
       v = s;
       break;
 
     case VAL_ULONG64:
-      snprintf(s, sizeof(s), "%ld", (long int)*(uint64_t *)value);
+      snprintf(s, sizeof(s), "%" PRIu64, *(uint64_t *)value);
       v = s;
       break;
 
     case VAL_USHORT:
-      snprintf(s, sizeof(s), "%d", (int)(*(uint16_t *)value));
+      snprintf(s, sizeof(s), "%" PRIu16, *(uint16_t *)value);
       v = s;
       break;
 
@@ -772,10 +798,47 @@
   }
 }
 
+#ifdef ENABLE_MULTILAN
+void set_moreif_env() {
+  size_t moreif_len = 256;
+  char *moreif = calloc(moreif_len, sizeof(char));
+  if (!moreif)
+    return;
+
+  moreif[0] = '\0';
+  size_t current_len = 0;
+
+  for (int i = 0; i < MAX_MOREIF; i++) {
+    if(!_options.moreif[i].dhcpif)
+      continue;
+
+    size_t needed_len = strlen(moreif) + strlen(_options.moreif[i].dhcpif) + 2;
+    if (needed_len > moreif_len) {
+      moreif_len = needed_len + 256;
+      char *new_moreif = realloc(moreif, moreif_len * sizeof(char));
+      if (!new_moreif) {
+        free(moreif);
+        return;
+      }
+      moreif = new_moreif;
+    }
+
+    if (current_len > 0) {
+      current_len += snprintf(moreif + current_len, moreif_len - current_len, " ");
+    }
+
+    current_len += snprintf(moreif + current_len, moreif_len - current_len, "%s", _options.moreif[i].dhcpif);
+  }
+  set_env("MOREIF", VAL_STRING, moreif, 0);
+  free(moreif);
+}
+#endif
+
 int runscript(struct app_conn_t *appconn, char* script,
-	      char *loc, char *oloc) {
+	      char *loc, char *oloc, char *dhcp_assign) {
   int status;
   uint32_t sessiontime;
+  struct dhcp_conn_t* dhcpconn;
 
   if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
     syslog(LOG_ERR, "%s: forking %s", strerror(errno), script);
@@ -790,6 +853,11 @@
   if (_options.layer3)
     set_env("LAYER3", VAL_STRING, "1", 0);
 #endif
+  set_env("DHCPIF", VAL_STRING, _options.dhcpif ? _options.dhcpif : "", 0);
+
+  if ((dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
+    set_env("IF", VAL_STRING, dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname, 0);
+  }
   set_env("DEV", VAL_STRING, tun(tun, 0).devname, 0);
   set_env("NET", VAL_IN_ADDR, &appconn->net, 0);
   set_env("MASK", VAL_IN_ADDR, &appconn->mask, 0);
@@ -812,12 +880,13 @@
   set_env("ACCT_INTERIM_INTERVAL", VAL_USHORT, &appconn->s_params.interim_interval, 0);
   set_env("WISPR_LOCATION_ID", VAL_STRING, _options.radiuslocationid, 0);
   set_env("WISPR_LOCATION_NAME", VAL_STRING, _options.radiuslocationname, 0);
-  set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG, &appconn->s_params.bandwidthmaxup, 0);
-  set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG, &appconn->s_params.bandwidthmaxdown, 0);
+  set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG64, &appconn->s_params.bandwidthmaxup, 0);
+  set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG64, &appconn->s_params.bandwidthmaxdown, 0);
   /*set_env("WISPR-SESSION_TERMINATE_TIME", VAL_USHORT, &appconn->sessionterminatetime, 0);*/
   set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxinputoctets, 0);
   set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxoutputoctets, 0);
   set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &appconn->s_params.maxtotaloctets, 0);
+  set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &appconn->s_params.warningoctets, 0);
   set_env("INPUT_OCTETS", VAL_ULONG64, &appconn->s_state.input_octets, 0);
   set_env("OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_state.output_octets, 0);
   set_env("INPUT_PACKETS", VAL_ULONG64, &appconn->s_state.input_packets, 0);
@@ -826,6 +895,18 @@
   set_env("SESSION_TIME", VAL_ULONG, &sessiontime, 0);
   sessiontime = mainclock_diffu(appconn->s_state.last_up_time);
   set_env("IDLE_TIME", VAL_ULONG, &sessiontime, 0);
+  if (dhcp_assign != NULL) {
+    // indication of first dhcp request when IP is set for the client
+    set_env("DHCP_ASSIGN", VAL_STRING, dhcp_assign, 0);
+  }
+
+#ifdef HAVE_NETFILTER_COOVA
+  set_env("KNAME", VAL_STRING, _options.kname ? _options.kname : "", 0);
+#endif
+
+#ifdef ENABLE_MULTILAN
+  set_moreif_env();
+#endif
 
   if (loc) {
     set_env("LOCATION", VAL_STRING, loc, 0);
@@ -1037,6 +1118,7 @@
 
 static int dnprot_terminate(struct app_conn_t *appconn) {
   appconn->s_state.authenticated = 0;
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
 #ifdef ENABLE_SESSIONSTATE
   appconn->s_state.session_state = 0;
 #endif
@@ -1085,7 +1167,25 @@
   return 0;
 }
 
+#ifdef ENABLE_GSM
+int send_warning_sms(uint64_t used, uint64_t warning, uint64_t limit, char *direction, char *phone)
+{
+	if (!limit || used < warning) {
+		// Only return 0 on successful SMS send.
+		return -1;
+	}
+
+	char sms_text[256] = { 0 };
+	float left	   = (used > limit) ? 0 : (float)(limit - used) / 1000000.f;
 
+	sprintf(sms_text, WARNING_FMT, direction, left, "MB");
+	syslog(LOG_INFO, "%s(%d): Sending SMS: %s\n", __FUNCTION__, __LINE__, sms_text);
+
+	chilli_send_sms_async(phone, sms_text, _options.modemid);
+
+	return 0;
+}
+#endif
 
 /* Check for:
  * - Session-Timeout
@@ -1104,12 +1204,50 @@
   interimtime = mainclock_diffu(conn->s_state.interim_time);
 
   if (conn->s_state.authenticated == 1) {
+#ifdef ENABLE_GSM
+#if(_debug_ > 1)
+	  if (conn->s_params.maxinputoctets > conn->s_state.input_octets)
+		  syslog(LOG_INFO, "warning_sent_download %d | download used %.1f left %.1f",
+			 conn->s_state.warning_sent_download, (float)conn->s_state.input_octets / 1000000.f,
+			 (float)(conn->s_params.maxinputoctets - conn->s_state.input_octets) / 1000000.f);
+	  if (conn->s_params.maxoutputoctets > conn->s_state.output_octets)
+		  syslog(LOG_INFO, "  warning_sent_upload %d |   upload used %.1f left %.1f",
+			 conn->s_state.warning_sent_upload, (float)conn->s_state.output_octets / 1000000.f,
+			 (float)(conn->s_params.maxoutputoctets - conn->s_state.output_octets) / 1000000.f);
+#endif
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_download &&
+	      !send_warning_sms(conn->s_state.input_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxinputoctets, "download", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_download = 1;
+	  }
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_upload &&
+	      !send_warning_sms(conn->s_state.output_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxoutputoctets, "upload", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_upload = 1;
+	  }
+#endif
+
     if ((conn->s_params.sessiontimeout) &&
 	(sessiontime > conn->s_params.sessiontimeout)) {
 #ifdef ENABLE_SESSIONSTATE
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+      terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+    }
+    else if (conn->s_params.expiration &&
+			 (conn->s_state.redir.auth_mode == AUTH_DYN_USER ||
+			  conn->s_state.redir.auth_mode == AUTH_SMS_USER) &&
+			 (sessiontime + conn->s_state.redir.user_time > conn->s_params.expiration))
+    {
+#ifdef ENABLE_SESSIONSTATE
+      conn->s_state.session_state =
+          RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.sessionterminatetime) &&
@@ -1118,6 +1256,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.idletimeout) &&
@@ -1126,6 +1266,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_IDLE_TIMEOUT);
     }
     else if ((conn->s_params.maxinputoctets) &&
@@ -1134,6 +1276,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxoutputoctets) &&
@@ -1142,6 +1286,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxtotaloctets) &&
@@ -1151,6 +1297,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.interim_interval) &&
@@ -1172,7 +1320,57 @@
 
       acct_req(ACCT_USER, conn, RADIUS_STATUS_TYPE_INTERIM_UPDATE);
     }
+#ifdef ENABLE_DATABASE
+      if (conn->s_params.sessiontimeout) {
+          uint32_t sessiontime_total = conn->s_history.sessiontime + sessiontime;
+
+          if (sessiontime_total > conn->s_params.sessiontimeout){
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+            RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+               conn->s_state.terminate_cause_ui =
+            	RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+
+      }
+      if (conn->s_params.maxinputoctets) {
+          uint64_t maxinputoctets_total = conn->s_state.input_octets + conn->s_history.input_octets;
+
+          if (maxinputoctets_total > conn->s_params.maxinputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+      if (conn->s_params.maxoutputoctets){
+          uint64_t maxoutputoctets_total = conn->s_state.output_octets + conn->s_history.output_octets;
+
+          if (maxoutputoctets_total > conn->s_params.maxoutputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+#endif //ENABLE_DATABASE
+  }
+#if(_debug_ > 1)
+  else {
+  	syslog(LOG_INFO, "Not authenticated");
   }
+#endif
 #ifdef ENABLE_GARDENACCOUNTING
   interimtime = mainclock_diffu(conn->s_state.garden_interim_time);
   if (_options.uamgardendata &&
@@ -1206,6 +1404,11 @@
     session_interval(&admin_session);
   }
 
+#ifdef ENABLE_DATABASE
+  sqlite3 *db;
+  db = dbopen();
+#endif
+
   for (conn = firstusedconn; conn; conn=conn->next) {
     if (conn->inuse != 0) {
       if (
@@ -1216,6 +1419,10 @@
 	syslog(LOG_WARNING, "No downlink protocol");
 	continue;
       }
+#ifdef ENABLE_DATABASE
+      if (db && conn->s_state.authenticated)
+        dbupdate(db, conn);
+#endif
       session_interval(conn);
     }
   }
@@ -1229,6 +1436,10 @@
     }
   }
 
+#ifdef ENABLE_DATABASE
+    dbclose(db);
+#endif
+
   return 0;
 }
 
@@ -1296,6 +1507,9 @@
 		     struct session_state *state) {
   char *sessionid = state->sessionid;
   char mac[MACSTRLEN+1];
+  struct ippoolm_t *ipm = NULL;
+  struct app_conn_t *appconn = NULL;
+  struct dhcp_conn_t *dhcpconn = NULL;
 
   switch(pack->code) {
     case RADIUS_CODE_ACCESS_REQUEST:
@@ -1422,6 +1636,11 @@
   if (hisip && hisip->s_addr) {
     radius_addattr(radius, pack, RADIUS_ATTR_FRAMED_IP_ADDRESS, 0, 0,
 		   ntohl(hisip->s_addr), NULL, 0);
+    /* Find user based on IP address */
+    if (!ippool_getip(ippool, &ipm, hisip)) {
+      appconn = (struct app_conn_t *)ipm->peer;
+      dhcpconn = appconn != NULL ? (struct dhcp_conn_t *)appconn->dnlink : NULL;
+    }
   }
 
   radius_addattr(radius, pack, RADIUS_ATTR_NAS_PORT_TYPE, 0, 0,
@@ -1470,6 +1689,19 @@
   }
 #endif
 
+  if (dhcpconn != NULL && dhcp->rawif[dhcp_conn_idx(dhcpconn)].fd > 0) {
+    const char* ssid = NULL;
+#ifdef ENABLE_UBUS
+    ssid = find_ssid_by_ifname(dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname);
+#endif
+    ssid = ssid == NULL ? dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname : ssid;
+    radius_addattr(radius, pack, RADIUS_ATTR_VENDOR_SPECIFIC,
+        RADIUS_VENDOR_COOVACHILLI,
+        RADIUS_ATTR_COOVACHILLI_SSID,
+        0, (uint8_t*) ssid,
+        strlen(ssid));
+  }
+
   /* Include NAS-Identifier if given in configuration options */
   if (_options.radiusnasid) {
     radius_addattr(radius, pack, RADIUS_ATTR_NAS_IDENTIFIER, 0, 0, 0,
@@ -1562,7 +1794,7 @@
   }
 
   /* Include his MAC address */
-  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(dhcpconn->hismac));
+  snprintf(mac, sizeof(mac), get_mac_format(), MAC_ARG(dhcpconn->hismac));
 
   if (!username) {
 
@@ -1796,6 +2028,7 @@
       switch(type) {
 #ifdef ENABLE_GARDENACCOUNTING
         case ACCT_GARDEN:
+             syslog(LOG_INFO, "ACCT_GARDEN set to zeros");
           snprintf(conn->s_state.garden_sessionid,
                         sizeof(conn->s_state.garden_sessionid),
                         "UAM-%s-%.8x%.8x", inet_ntoa(conn->hisip),
@@ -1813,6 +2046,9 @@
           conn->s_state.output_packets = 0;
           conn->s_state.input_octets = 0;
           conn->s_state.output_octets = 0;
+#ifdef ENABLE_DATABASE
+          dbsession_state(conn);
+#endif
           break;
       }
       break;
@@ -1838,7 +2074,7 @@
   /*
    *  Return if there is no RADIUS accounting for this session.
    */
-  if (conn->s_params.flags & NO_ACCOUNTING)
+  if ((conn->s_params.flags & NO_ACCOUNTING) || _options.localusers || _options.smsusers || _options.macusers)
     return 0;
 
   /*
@@ -2324,6 +2560,10 @@
   if (!(appconn->s_params.flags & REQUIRE_UAM_AUTH)) {
     /* This is the one and only place state is switched to authenticated */
     appconn->s_state.authenticated = 1;
+    appconn->s_state.terminate_cause_ui = 0;
+    memset(appconn->s_params.tcp_reset_addr, 0, sizeof(appconn->s_params.tcp_reset_addr));
+    appconn->s_params.num_tcp_reset_addr = 0;
+    send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_CONNECT, appconn, dhcpconn);
 
 #ifdef ENABLE_SESSIONSTATE
     appconn->s_state.session_state =
@@ -2352,12 +2592,15 @@
 
     /* if (!(appconn->s_params.flags & IS_UAM_REAUTH))*/
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
-
+#ifdef ENABLE_DATABASE
+      dbconup(appconn);
+#endif
     /* Run connection up script */
     if (_options.conup && !(appconn->s_params.flags & NO_SCRIPT)) {
- if (_options.debug)
-     syslog(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n", __FUNCTION__, __LINE__, _options.conup);
-      runscript(appconn, _options.conup, 0, 0);
+        if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n",
+                   __FUNCTION__, __LINE__, _options.conup);
+        runscript(appconn, _options.conup, 0, 0, NULL);
     }
   }
 
@@ -2481,7 +2724,7 @@
 	length += hdrlen;
 
 	copy_mac6(ethh->dst, dstmac);
-	copy_mac6(ethh->src, dhcp_nexthop(dhcp));
+	copy_mac6(ethh->src, dhcp_nexthop(dhcp, 0));
 	ethh->prot = htons(PKT_ETH_PROTO_IP);
 
 	dhcp_send(dhcp, -1, dstmac, packet, length);
@@ -2958,7 +3201,7 @@
 
       if (_options.locationupdate) {
 	runscript(appconn, _options.locationupdate,
-		  loc_buff, prev_loc_buff);
+		  loc_buff, prev_loc_buff, NULL);
       }
 
       if (_options.location_stop_start) {
@@ -3050,6 +3293,7 @@
     appconn->s_state.input_octets = 0;
     appconn->s_state.output_packets = 0;
     appconn->s_state.output_octets = 0;
+     syslog(LOG_INFO, "location set to zeros");
 
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
   }
@@ -3853,7 +4097,7 @@
 
   if (_options.macdown) {
     syslog(LOG_DEBUG, "%s(%d): Calling MAC down script: %s", __FUNCTION__, __LINE__, _options.macdown);
-    runscript(appconn, _options.macdown, 0, 0);
+    runscript(appconn, _options.macdown, 0, 0, NULL);
   }
 
   if (!dhcpconn || !dhcpconn->is_reserved) {
@@ -3878,10 +4122,8 @@
 
   struct dhcp_conn_t *dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
 
-#if(_debug_ > 1)
   if (_options.debug)
     syslog(LOG_DEBUG, "%s(%d): UPPROT - GETIP", __FUNCTION__, __LINE__);
-#endif
 
   /* If IP address is already allocated: Fill it in */
   /* This should only happen for UAM */
@@ -3926,7 +4168,6 @@
 }
 
 void session_param_defaults(struct session_params *params) {
-
   if (_options.defsessiontimeout && !params->sessiontimeout)
     params->sessiontimeout = _options.defsessiontimeout;
 
@@ -3941,6 +4182,52 @@
 
   if (_options.definteriminterval && !params->interim_interval)
     params->interim_interval = _options.definteriminterval;
+
+  if (_options.defmaxdownload && !params->maxinputoctets)
+    params->maxinputoctets = _options.defmaxdownload;
+
+  if (_options.defmaxupload && !params->maxoutputoctets)
+    params->maxoutputoctets = _options.defmaxupload;
+
+  if (_options.defwarning && !params->warningoctets)
+    params->warningoctets = _options.defwarning;
+
+  if (_options.deflimitperiod && !params->period)
+    params->period = _options.deflimitperiod;
+
+  if (_options.deflimitstart && !params->start)
+    params->start = _options.deflimitstart;
+
+  if (_options.defexpirationtime && !params->expiration)
+    params->expiration = _options.defexpirationtime;
+}
+
+void session_params_dyn(struct session_params *params) {
+    params->sessiontimeout = _options.dynsessiontimeout;
+    params->idletimeout = _options.dynidletimeout;
+    params->bandwidthmaxdown = _options.dynbandwidthmaxdown;
+    params->bandwidthmaxup = _options.dynbandwidthmaxup;
+    params->interim_interval = _options.dyninteriminterval;
+    params->maxinputoctets = _options.dynmaxdownload;
+    params->maxoutputoctets = _options.dynmaxupload;
+    params->warningoctets = _options.dynwarning;
+    params->period = _options.dynlimitperiod;
+    params->start = _options.dynlimitstart;
+    params->expiration = _options.dynexpirationtime;
+}
+
+void session_params_trial(struct session_params *params) {
+  params->sessiontimeout = _options.trialsessiontimeout;
+  params->idletimeout = _options.trialidletimeout;
+  params->bandwidthmaxdown = _options.trialbandwidthmaxdown;
+  params->bandwidthmaxup = _options.trialbandwidthmaxup;
+  params->interim_interval = _options.trialinteriminterval;
+  params->maxinputoctets = _options.trialmaxdownload;
+  params->maxoutputoctets = _options.trialmaxupload;
+  params->warningoctets = _options.trialwarning;
+  params->period = _options.triallimitperiod;
+  params->start = _options.triallimitstart;
+  params->expiration = _options.trialexpirationtime;
 }
 
 void
@@ -4044,6 +4331,14 @@
   else if (!reconfig)
     params->maxtotaloctets = 0;
 
+  /* Warning octets */
+  if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
+		      RADIUS_VENDOR_COOVACHILLI,
+		      RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS, 0))
+    params->warningoctets = ntohl(attr->v.i);
+  else if (!reconfig)
+    params->warningoctets = 0;
+
 
   /* Max input gigawords */
   if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
@@ -4961,6 +5256,70 @@
 }
 #endif
 
+static struct ippoolm_t* sms_auth_mac_authentication(struct app_conn_t *appconn) {
+  sqlite3 *db;
+
+  struct str_sms_user user = {0};
+  struct dhcp_conn_t *dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
+
+  if (!dhcpconn || !dhcpconn->hismac || !_options.usersdbpath)
+    return NULL;
+
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return NULL;
+  }
+
+  if (usr_sms_user_exists(db, NULL, dhcpconn->hismac) != USER_RET_ALREADY) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (usr_get_sms_user_phone(db, &user, NULL, dhcpconn->hismac)) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (user.username == NULL || user.username[0] == '\0' || user.used == 0) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (_options.duplicateusers && find_active_user(user.username)) {
+    syslog(LOG_INFO, "%s(%d): Found duplication on username: %s", __FUNCTION__, __LINE__, user.username);
+    sqlclose(db);
+    return NULL;
+  }
+
+  appconn->s_state.redir.user_time = user.user_time;
+  appconn->s_state.redir.auth_mode = AUTH_SMS_USER;
+  strncpy(appconn->s_state.redir.username, user.username, USER_RAND_USERNAME_LEN);
+  strlcpy(appconn->s_state.redir.phone, user.phone, sizeof(appconn->s_state.redir.phone));
+  session_params_dyn(&appconn->s_params);
+
+  uint32_t timestamp = (uint32_t)mainclock_now();
+  usr_update_sms_user(db, &user, user.phone, dhcpconn->hismac, timestamp, NULL);
+  session_param_defaults(&appconn->s_params);
+
+#ifdef ENABLE_DATABASE
+  if ((appconn->s_params.maxinputoctets || appconn->s_params.maxoutputoctets ||
+      appconn->s_params.sessiontimeout) && dbcheck_session(appconn) != ACCESS_ACCEPTED) {
+    sqlclose(db);
+    return NULL;
+  }
+#endif
+
+  syslog(LOG_INFO, "Granted PHONE=%s MAC="MAC_FMT" with IP=%s access by MAC authentication",
+                 user.phone, MAC_ARG(dhcpconn->hismac), inet_ntoa(appconn->hisip));
+
+  memcpy(appconn->hismac, dhcpconn->hismac, PKT_ETH_ALEN);
+
+  upprot_getip(appconn, &appconn->reqip, 0);
+
+  sqlclose(db);
+  return (struct ippoolm_t*) appconn->uplink;
+}
+
 /***********************************************************
  *
  * dhcp callback functions
@@ -5038,7 +5397,7 @@
 	if (_options.macallowlocal) {
 	  char mac[MACSTRLEN+1];
 
-	  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+	  snprintf(mac, sizeof(mac), get_mac_format(), MAC_ARG(conn->hismac));
 
 	  strlcpy(appconn->s_state.redir.username, mac, USERNAMESIZE);
 
@@ -5063,7 +5422,11 @@
 	  /*
 	   *  Otherwise, authenticate with RADIUS.
 	   */
-	  auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	  if (_options.smsusers) {
+	    ipm = sms_auth_mac_authentication(appconn);
+	  } else {
+	    auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	  }
 
 	  allocate = !_options.strictmacauth;
 	  domacauth = 0;
@@ -5077,7 +5440,11 @@
 	 */
 	appconn->dnprot = DNPROT_MAC;
 
-	auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	if (_options.smsusers) {
+		ipm = sms_auth_mac_authentication(appconn);
+	} else {
+		auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	}
 
 	allocate = !_options.strictmacauth;
 	domacauth = 0;
@@ -5085,8 +5452,11 @@
     }
   }
 
+  int ip_assigned = 1;
   if (!ipm) {
 
+    ip_assigned = 0;
+
     if (!allocate)
       return -1;
 
@@ -5151,17 +5521,27 @@
 		   &_options.dns1, &_options.dns2);
   }
 
-  if (!appconn->s_state.authenticated) {
+  if (_options.macup && (mainclock.tv_sec - appconn->s_state.dhcp_last_time > 1 || !ip_assigned)) {
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Calling MAC up script: %s", __FUNCTION__, __LINE__, _options.macup);
+    runscript(appconn, _options.macup, 0, 0, !ip_assigned ? "1" : "0");
+  }
 
-    if (domacauth) {
-      auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+  if (!appconn->s_state.authenticated) {
+    if (domacauth && mainclock.tv_sec - appconn->s_state.dhcp_last_time > 1) {
+      if (_options.smsusers) {
+        sms_auth_mac_authentication(appconn);
+      } else {
+        auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+      }
     }
 
     /* if not already authenticated, ensure DNAT authstate */
 #ifdef ENABLE_LAYER3
     if (!_options.layer3)
 #endif
-      conn->authstate = DHCP_AUTH_DNAT;
+      if (!appconn->s_state.authenticated)
+        conn->authstate = DHCP_AUTH_DNAT;
   }
 
   /* If IP was requested before authentication it was UAM */
@@ -5171,6 +5551,8 @@
   if (_options.dhcpnotidle)
     appconn->s_state.last_up_time = mainclock.tv_sec;
 
+  appconn->s_state.dhcp_last_time = mainclock.tv_sec;
+
   return 0;
 }
 
@@ -5229,12 +5611,6 @@
 
   conn->authstate = DHCP_AUTH_NONE; /* TODO: Not yet authenticated */
 
-  if (_options.macup) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Calling MAC up script: %s", __FUNCTION__, __LINE__, _options.macup);
-    runscript(appconn, _options.macup, 0, 0);
-  }
-
   return 0;
 }
 
@@ -5279,20 +5655,23 @@
 }
 #endif
 
-#ifdef ENABLE_CHILLIQUERY
-static char *state2name(int authstate) {
-  switch(authstate) {
-    case DHCP_AUTH_NONE:   return "none";
-    case DHCP_AUTH_DROP:   return "drop";
-    case DHCP_AUTH_PASS:   return "pass";
-    case DHCP_AUTH_DNAT:   return "dnat";
-    case DHCP_AUTH_SPLASH: return "splash";
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_UBUS)
+char *state2name(int authstate) {
+	switch(authstate) {
+	case DHCP_AUTH_NONE:   return "none";
+	case DHCP_AUTH_DROP:   return "drop";
+	case DHCP_AUTH_PASS:   return "pass";
+	case DHCP_AUTH_DNAT:   return "dnat";
+	case DHCP_AUTH_SPLASH: return "splash";
 #ifdef ENABLE_LAYER3
-    case DHCP_AUTH_ROUTER: return "layer2";
+	case DHCP_AUTH_ROUTER: return "layer2";
 #endif
-    default:               return "unknown";
-  }
+	default:               return "unknown";
+	}
 }
+#endif
+
+#ifdef ENABLE_CHILLIQUERY
 
 int chilli_getinfo(struct app_conn_t *appconn, bstring b, int fmt) {
   uint32_t sessiontime = 0;
@@ -5374,6 +5753,11 @@
                       appconn->s_params.maxtotaloctets, _options.swapoctets);
         bconcat(b, tmp);
 
+        /* adding: warning-octets */
+        bassignformat(tmp, " %lld",
+                      appconn->s_params.warningoctets);
+        bconcat(b, tmp);
+
 #ifdef ENABLE_LEAKYBUCKET
         /* adding: max-bandwidth-up max-bandwidth-down */
         if (appconn->s_state.bucketupsize) {
@@ -5553,10 +5937,12 @@
       appconn->s_params.maxinputoctets =
       appconn->s_params.maxoutputoctets =
       appconn->s_params.maxtotaloctets =
+      appconn->s_params.warningoctets =
       appconn->s_params.sessiontimeout = 0;
   appconn->s_params.idletimeout = 0;
   appconn->s_params.interim_interval = 0;
   appconn->s_params.sessionterminatetime = 0;
+  appconn->s_params.expiration = 0;
 }
 
 int terminate_appconn(struct app_conn_t *appconn, int terminate_cause) {
@@ -5580,11 +5966,15 @@
       }
     }
 #endif
+#ifdef  ENABLE_DATABASE
+      dbconupdate(appconn);
+#endif
 
     if (_options.condown && !(appconn->s_params.flags & NO_SCRIPT)) {
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): Calling connection down script: %s\n", __FUNCTION__, __LINE__, _options.condown);
-      runscript(appconn, _options.condown, 0, 0);
+
+      runscript(appconn, _options.condown, 0, 0, NULL);
     }
 
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_STOP);
@@ -5622,6 +6012,8 @@
 
   appconn = (struct app_conn_t*) conn->peer;
 
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
+
   return session_disconnect(appconn, conn, term_cause);
 }
 
@@ -6143,9 +6535,12 @@
         appconn->s_state.session_state =
             RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
 #endif
+        appconn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
         terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
         appconn->s_params.sessiontimeout = 0;
         appconn->s_params.idletimeout = 0;
+        appconn->s_params.expiration = 0;
       }
 
       appconn->uamabort = 0;
@@ -6191,57 +6586,75 @@
   return 0;
 }
 
-#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
-static struct app_conn_t * find_app_conn(struct cmdsock_request *req,
-                                         int *has_criteria) {
-  struct app_conn_t *appconn = 0;
-  struct dhcp_conn_t *dhcpconn = 0;
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER) || defined(ENABLE_UBUS)
+struct app_conn_t * find_app_conn(struct cmdsock_request *req,
+								  int *has_criteria) {
+	struct app_conn_t *appconn = 0;
+	struct dhcp_conn_t *dhcpconn = 0;
+
+	if (req->ip.s_addr) {
+		appconn = dhcp_get_appconn_ip(0, &req->ip);
+		if (has_criteria)
+			*has_criteria = 1;
+	} 
 
-  if (req->ip.s_addr) {
-    appconn = dhcp_get_appconn_ip(0, &req->ip);
-    if (has_criteria)
-      *has_criteria = 1;
-  } else {
+	if (!appconn) {
 #ifdef ENABLE_LAYER3
-    if (!_options.layer3)
+		if (!_options.layer3)
 #endif
-      if (req->mac[0]||req->mac[1]||req->mac[2]||
-	  req->mac[3]||req->mac[4]||req->mac[5]) {
-	dhcp_hashget(dhcp, &dhcpconn, req->mac);
-	if (has_criteria)
-	  *has_criteria = 1;
-      }
-  }
+		if (req->mac[0]||req->mac[1]||req->mac[2]||
+			req->mac[3]||req->mac[4]||req->mac[5]) {
+			dhcp_hashget(dhcp, &dhcpconn, req->mac);
+			if (has_criteria)
+				*has_criteria = 1;
+		}
+	}
 
-  if (!appconn && dhcpconn
+	if (!appconn && dhcpconn
 #ifdef ENABLE_LAYER3
-      && !_options.layer3
+		&& !_options.layer3
 #endif
-      )
-    appconn = (struct app_conn_t *) dhcpconn->peer;
+			)
+		appconn = (struct app_conn_t *) dhcpconn->peer;
 
-  if (!appconn && req->d.sess.sessionid[0] != 0) {
-    struct app_conn_t *aconn = firstusedconn;
-    if (has_criteria)
-      *has_criteria = 1;
-    while (aconn) {
-      if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
-	appconn = aconn;
-	break;
-      }
-      aconn = aconn->next;
-    }
-  }
+	if (!appconn && req->d.sess.sessionid[0] != 0) {
+		struct app_conn_t *aconn = firstusedconn;
+		if (has_criteria)
+			*has_criteria = 1;
+		while (aconn) {
+			if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
+				appconn = aconn;
+				break;
+			}
+			aconn = aconn->next;
+		}
+	}
 
-  if (appconn && !appconn->inuse) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
-    return 0;
-  }
+	if (appconn && !appconn->inuse) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
+		return 0;
+	}
 
-  return appconn;
+	return appconn;
 }
+#endif
+
+int find_active_user(char *username)
+{
+  struct app_conn_t *appconn = firstusedconn;
+  int match = 0;
+  while (appconn) { 
+    if (strcmp(appconn->s_state.redir.username, username) == 0 && appconn->s_state.authenticated == 1) {
+      match = 1;
+      break;
+    }
+    appconn = appconn->next;
+  }
+  return match;
+} 
 
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock) {
 
 #ifdef HAVE_NETFILTER_COOVA
@@ -6482,6 +6895,14 @@
             bconcat(s, tmp);
           }
 
+          if (appconn->s_params.warningoctets) {
+            bassignformat(tmp,
+                          "%20s: %lld\n",
+                          "warning octets in",
+                          appconn->s_params.warningoctets);
+            bconcat(s, tmp);
+          }
+
 #ifdef ENABLE_GARDENACCOUNTING
           if (_options.uamgardendata) {
             bassignformat(tmp,
@@ -6924,6 +7345,7 @@
         struct app_conn_t *appconn = find_app_conn(req, 0);
         if (appconn) {
           char *uname = req->d.sess.username;
+          char *uurl = req->d.sess.userurl;
 
           if (_options.debug)
             syslog(LOG_DEBUG, "%s(%d): remotely authorized session %s", __FUNCTION__, __LINE__,
@@ -6936,6 +7358,10 @@
             strlcpy(appconn->s_state.redir.username,
                     uname, USERNAMESIZE);
 
+          if (uurl[0])
+            strlcpy(appconn->s_state.redir.userurl,
+                    uurl, REDIR_USERURLSIZE);
+
           session_param_defaults(&appconn->s_params);
 
 #ifdef ENABLE_LEAKYBUCKET
@@ -6944,12 +7370,35 @@
 
           switch(req->type) {
             case CMDSOCK_LOGIN:
-              auth_radius(appconn, uname, req->d.sess.password, 0, 0);
+              if (_options.localusers) {
+                if (authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                  session_param_defaults(&appconn->s_params);
+                  dnprot_accept(appconn);
+                } else if (_options.registerusers) {
+                  if (dynamic_user_authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                    dnprot_accept(appconn);
+                  }
+                }
+              } else if (_options.smsusers) {
+                if (sms_user_authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                  session_param_defaults(&appconn->s_params);
+                  dnprot_accept(appconn);
+                }
+              } else if (_options.macusers) {
+                if (mac_user_authenticator_chilli(appconn, (uint8_t *)req->d.sess.password) == ACCESS_ACCEPTED) {
+                  dnprot_accept(appconn);
+                }
+              } else {
+                auth_radius(appconn, uname, req->d.sess.password, 0, 0);
+              }
               break;
             case CMDSOCK_AUTHORIZE:
               dnprot_accept(appconn);
               break;
             case CMDSOCK_UPDATE:
+              if (_options.conrestart) {
+                runscript(appconn, _options.conrestart, 0, 0, NULL);
+              }
               break;
           }
         }
@@ -7070,6 +7519,17 @@
 }
 #endif
 
+#ifdef ENABLE_UBUS
+static int ubus_sock_accept(void *ctx, int sock)
+{
+  struct ubus_context *uctx = (struct ubus_context *)ctx;
+
+  ubus_handle_event(uctx);
+
+  return 0;
+}
+#endif
+
 #if XXX_IO_DAEMON
 int chilli_io(int fd_ctrl_r, int fd_ctrl_w, int fd_pkt_r, int fd_pkt_w) {
   int maxfd = 0;
@@ -7190,7 +7650,11 @@
     if (conn->is_reserved && conn->peer) {
       appconn = (struct app_conn_t *)conn->peer;
       if (!appconn->s_state.authenticated) {
-	auth_radius((struct app_conn_t *)conn->peer, 0, 0, 0, 0);
+        if (_options.smsusers) {
+          sms_auth_mac_authentication((struct app_conn_t *)conn->peer);
+        } else {
+          auth_radius((struct app_conn_t *)conn->peer, 0, 0, 0, 0);
+        }
       }
     }
     conn = conn->next;
@@ -7216,6 +7680,12 @@
 }
 #endif
 
+static void signal_handler(int signum)
+{
+	(void)signum;
+	tun_runscript(tun, _options.ipup, 0);
+}
+
 int chilli_main(int argc, char **argv) {
   select_ctx sctx;
   int status;
@@ -7389,6 +7859,16 @@
     /* This has to be done after we have our final pid */
     log_pid((_options.pidfile && *_options.pidfile) ? _options.pidfile : DEFPIDFILE);
 
+    cap_t caps = cap_get_proc();
+    cap_value_t newcaps[2] = { CAP_NET_ADMIN, CAP_NET_RAW };
+    if (cap_set_flag(caps, CAP_INHERITABLE, 2, newcaps, CAP_SET) == -1) {
+      syslog(LOG_ERR, "Failed to set inheritable capabilities: %s", strerror(errno));
+    }
+    if (cap_set_proc(caps) == -1) {
+      syslog(LOG_ERR, "Failed to process inheritable capabilities: %s", strerror(errno));
+    }
+    cap_free(caps);
+
 #ifdef ENABLE_UAMANYIP
     /* setup IPv4LL/APIPA network ip and mask for uamanyip exception */
     inet_aton("169.254.0.0", &ipv4ll_ip);
@@ -7398,6 +7878,8 @@
     ssdp.s_addr = inet_addr(SSDP_MCAST_ADDR);
 #endif
 
+    alter_tables();
+
     syslog(LOG_INFO, "CoovaChilli %s. "
            "Copyright 2002-2005 Mondru AB. Licensed under GPL. "
            "Copyright 2006-2012 David Bird (Coova Technologies). "
@@ -7438,8 +7920,13 @@
 
     tun_set_cb_ind(tun, cb_tun_ind);
 
-    if (_options.ipup)
+    if (_options.ipup) {
       tun_runscript(tun, _options.ipup, 0);
+      // Firewall rule reinitialization signal handler
+      struct sigaction action = { 0 };
+      action.sa_handler	= signal_handler;
+      sigaction(SIGUSR1, &action, NULL);
+    }
 
     /* Allocate ippool for dynamic IP address allocation */
     if (ippool_new(&ippool,
@@ -7467,6 +7954,11 @@
       exit(1);
     }
 
+    g_ubus_event_ctx = ubus_connect(NULL);
+    if (!g_ubus_event_ctx) {
+      syslog(LOG_ERR, "Failed to set up ubus for event sending");
+    }
+
     dhcp_set_cb_request(dhcp, cb_dhcp_request);
     dhcp_set_cb_connect(dhcp, cb_dhcp_connect);
     dhcp_set_cb_disconnect(dhcp, cb_dhcp_disconnect);
@@ -7547,6 +8039,14 @@
       return -1;
     }
 #endif
+#ifdef ENABLE_UBUS
+    ubus_ctx = ubus_connect(NULL);
+	if (!ubus_ctx) {
+		syslog(LOG_ERR, "Failed to connect to ubus, exiting...");
+	}
+#endif
+
+
 
     if (_options.radsec) {
 #ifdef ENABLE_CHILLIRADSEC
@@ -7714,10 +8214,25 @@
 #ifdef ENABLE_CHILLIQUERY
     net_select_reg(&sctx, cmdsock, SELECT_READ,
                    (select_callback)cmdsock_accept, 0, cmdsock);
+
+#endif
+#ifdef ENABLE_UBUS
+    net_select_reg(&sctx, ubus_ctx->sock.fd, SELECT_READ,
+                   (select_callback)ubus_sock_accept, ubus_ctx, ubus_ctx->sock.fd);
+    chilli_ubus_add_obj(ubus_ctx);
+    
+    /* subscribe to hostapd to listen for dissasoc calls. */
+    chilli_ubus_subscribe_hostapd(ubus_ctx, _options);
+
 #endif
 
     mainclock_tick();
-    while (keep_going) {
+#ifdef ENABLE_DATABASE
+    syslog(LOG_INFO, "[%s] Checking data base %s", __FUNCTION__, sqlite3_libversion());
+    dbcheck_table();
+#endif
+
+  while (keep_going) {
 
       if (reload_config) {
 
@@ -7856,6 +8371,9 @@
     if (ippool)
       ippool_free(ippool);
 
+    if (g_ubus_event_ctx)
+      ubus_free(g_ubus_event_ctx);
+
     /*
      *  Terminate not-so-nicely
      */
@@ -7863,6 +8381,10 @@
 #ifdef ENABLE_CHILLIQUERY
     cmdsock_shutdown();
 #endif
+#ifdef ENABLE_UBUS
+	chilli_ubus_remove_obj(ubus_ctx);	//Workaround (?) Protection from Huawei
+    ubus_free(ubus_ctx);
+#endif
 
 #ifdef ENABLE_CHILLIREDIR
     if (redir_pid > 0) {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli.h src/src/chilli.h
--- upstream/src/chilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.h	2025-07-03 10:02:27.000000000 +0000
@@ -21,6 +21,7 @@
 #ifndef _CHILLI_H
 #define _CHILLI_H
 
+#include <sys/capability.h>
 #include "system.h"
 #include "debug.h"
 #include "chilli_limits.h"
@@ -35,11 +36,31 @@
 #include "net.h"
 #include "md5.h"
 #include "dns.h"
+#include "sqlite.h"
+#include "ubus.h"
+#ifdef  ENABLE_DATABASE
+#include "database.h"
+#endif
+#ifdef  USING_CURL
+#include "oauth2.h"
+#endif
+#include "users.h"
+#ifdef ENABLE_GSM
+#include "gsm.h"
+#endif
+#ifdef HAVE_OPENSSL
+#include "passwd_md5crypt.h"
+#include "passwd_shacrypt.h"
+#endif
 
 #ifndef HAVE_STRLCPY
 extern size_t strlcpy(char *dst, const char *src, size_t dsize);
 #endif
 
+#ifdef ENABLE_UBUS
+  struct ubus_context *ubus_ctx;
+#endif
+
 /*#define XXX_IO_DAEMON 1*/
 
 /* Authtype defs */
@@ -70,6 +91,8 @@
 #define DEBUG_REDIR       8
 #define DEBUG_CONF       16
 
+#define WARNING_FMT "You're about to reach your %s data limit, %.1f %s left.\n"
+
 /* Struct information for each connection */
 struct app_conn_t {
 
@@ -102,6 +125,11 @@
 
   struct session_params s_params;         /* Session parameters */
   struct session_state  s_state;          /* Session state */
+#ifdef ENABLE_DATABASE
+  struct session_history s_history;		/*Session history*/
+#endif
+
+
 
 #ifdef HAVE_PATRICIA
   patricia_tree_t *ptree;
@@ -177,6 +205,7 @@
 } acct_type;
 
 void set_env(char *name, char type, void *value, int len);
+void set_moreif_env();
 
 extern struct app_conn_t *firstfreeconn; /* First free in linked list */
 extern struct app_conn_t *lastfreeconn;  /* Last free in linked list */
@@ -212,6 +241,8 @@
 struct app_conn_t * chilli_connect_layer3(struct in_addr *src, struct dhcp_conn_t *conn);
 #endif
 
+int find_active_user(char *username);
+
 int chilli_getconn(struct app_conn_t **conn, uint32_t ip,
 		   uint32_t nasip, uint32_t nasport);
 
@@ -256,12 +287,24 @@
 
 void session_param_defaults(struct session_params *params);
 
+void session_params_dyn(struct session_params *params);
+
+void session_params_trial(struct session_params *params);
+
 int dnprot_accept(struct app_conn_t *appconn);
 
 int dnprot_reject(struct app_conn_t *appconn);
 
 int get_urlparts(char *src, char *host, int hostsize, int *port, int *uripos);
 
+int bstrtocstr(bstring src, char *dst, unsigned int len);
+
+int bescape_str(bstring src, bstring dst);
+
+int escape_cstr(char *src, char *dst);
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len);
+
 int cmdsock_init();
 
 int cmdsock_port_init();
@@ -320,6 +363,12 @@
 int chilli_getconn_byroute(struct app_conn_t **conn, int idx);
 #endif
 
+
+struct app_conn_t * find_app_conn(struct cmdsock_request *req, int *has_criteria);
+char *state2name(int authstate);
+int has_dhcp(void);
+
+
 uint8_t* chilli_called_station(struct session_state *state);
 
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock);
@@ -328,7 +377,7 @@
 void chilli_freeconn();
 
 int runscript(struct app_conn_t *appconn, char* script,
-	      char *loc, char *oloc);
+	      char *loc, char *oloc, char *dhcp_assign);
 
 /* utils.c */
 int statedir_file(char *dst, int dlen, char *file, char *deffile);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli_limits.h src/src/chilli_limits.h
--- upstream/src/chilli_limits.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli_limits.h	2025-07-03 10:02:27.000000000 +0000
@@ -112,20 +112,18 @@
 #endif
 
 #define MAX_EAP_LEN                     3000 /* Size of buffer to hold EAP message */
+#define PKT_MAX_LEN                    65535 /* Maximum packet size we receive */
+#define MAX_PASS_THROUGHS               1024 /* Max number of allowed UAM pass-throughs */
 
 #ifdef ENABLE_LARGELIMITS
-#define PKT_MAX_LEN                    65535 /* Maximum packet size we receive */
 #define SESSION_PASS_THROUGH_MAX          16
-#define MAX_PASS_THROUGHS               1024 /* Max number of allowed UAM pass-throughs */
 #define MAX_REGEX_PASS_THROUGHS          512 /* Max number of allowed UAM pass-throughs */
 #define MAX_UAM_DOMAINS                  128 /* Max number of allowed UAM domains */
 #define MACOK_MAX                         56
 #define MAX_SELECT                        56
 #define RADIUS_PACKSIZE                 4096
 #else
-#define PKT_MAX_LEN                     9000 /* Maximum packet size we receive */
 #define SESSION_PASS_THROUGH_MAX           8
-#define MAX_PASS_THROUGHS                128 /* Max number of allowed UAM pass-throughs */
 #define MAX_REGEX_PASS_THROUGHS            8 /* Max number of allowed UAM pass-throughs */
 #define MAX_UAM_DOMAINS                   32 /* Max number of allowed UAM domains */
 #define MACOK_MAX                         16
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdline.ggo src/src/cmdline.ggo
--- upstream/src/cmdline.ggo	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdline.ggo	2025-07-03 10:02:27.000000000 +0000
@@ -30,7 +30,7 @@
 option  "gid"         - "GID to run as, after being started as root" int default="0" no
 
 # NET/TUN parameters
-option "net"         n "Network"           string default="192.168.182.0/24" no
+option "net"         n "Network"           string no
 option "dhcpstart"   - "Network DHCP Starting IP"      int default="0" no
 option "dhcpend"     - "Network DHCP Ending IP"        int default="0" no
 option "dhcpbroadcast" - "Always broadcast DHCP responses" flag off
@@ -46,6 +46,7 @@
 option "ipdown"      - "Script to run after link-down" string no
 option "conup"       - "Script to run after user logon"  string no
 option "condown"     - "Script to run after user logoff" string no
+option "conrestart"  - "Script to run when changed session info" string no
 option "macup"       - "Script to run after initial DHCP"  string no
 option "macdown"     - "Script to run after DHCP release" string no
 option "vlanupdate"  - "Script to run after 802.1Q/VLAN id assignment" string no
@@ -99,6 +100,7 @@
 option "coaport"            - "Radius disconnect port to listen to" int default="0" no
 option "coanoipcheck"       - "Allow radius disconnect from any IP" flag   off
 option "noradallow"         - "Allow all sessions when RADIUS is not available" flag   off
+option "radiusrequiremessageauth" - "Radius packets must have valid Message-Authenticator" flag   off
 
 
 # Radius proxy parameters
@@ -166,6 +168,36 @@
 option "defbandwidthmaxdown" - "Default WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
 option "defbandwidthmaxup" - "Default WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
 option "definteriminterval" - "Default interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "defmaxdownload" - "Default CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "defmaxupload" - "Default CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "defwarning" - "Default CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "deflimitperiod" - "Default period for data limit calculations" int default="0" no
+option "deflimitstart" - "Default start point for data limit calculations" int default="0" no
+option "defexpirationtime" - "Default expiration time for dynamically allocated ussers" long default="0" no
+
+option "dynsessiontimeout" - "Dynamically created user session-timeout if not returned by RADIUS" long default="0" no
+option "dynidletimeout" - "Dynamically created user idle-timeout if not returned by RADIUS" int default="0" no
+option "dynbandwidthmaxdown" - "Dynamically created user WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "dynbandwidthmaxup" - "Dynamically created user WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "dyninteriminterval" - "Dynamically created user interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "dynmaxdownload" - "Dynamically created user CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "dynmaxupload" - "Dynamically created user CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "dynwarning" - "Dynamically created user CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "dynlimitperiod" - "Dynamically created user period for data limit calculations" int default="0" no
+option "dynlimitstart" - "Dynamically created user start point for data limit calculations" int default="0" no
+option "dynexpirationtime" - "Expiration time for dynamically allocated ussers" long default="0" no
+
+option "trialsessiontimeout" - "Trial session session-timeout if not returned by RADIUS" long default="0" no
+option "trialidletimeout" - "Trial session idle-timeout if not returned by RADIUS" int default="0" no
+option "trialbandwidthmaxdown" - "Trial session WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "trialbandwidthmaxup" - "Trial session WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "trialinteriminterval" - "Trial session interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "trialmaxdownload" - "Trial session CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "trialmaxupload" - "Trial session CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "trialwarning" - "Trial session CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "triallimitperiod" - "Trial session period for data limit calculations" int default="0" no
+option "triallimitstart" - "Trial session start point for data limit calculations" int default="0" no
+option "trialexpirationtime" - "Trial session expiration time" long default="0" no
 
 option "bwbucketupsize" - "Define the up-bound 'leaky bucket' size" int default="0" no
 option "bwbucketdnsize" - "Define the down-bound 'leaky bucket' size" int default="0" no
@@ -178,6 +210,8 @@
 option "macallowed"  - "List of allowed MAC addresses" string no multiple
 option "macsuffix"   - "Suffix to add to the MAC address" string no
 option "macpasswd"   - "Password used when performing MAC authentication" string no
+option "maclower"     - "MAC address in lower case" flag   off
+option "macdelimiter"  - "MAC address delimiter" int default="0" no
 option "macallowlocal" - "Do not use RADIUS for authenticating the macallowed" flag off
 option "strictmacauth" - "Be strict about MAC Auth (no DHCP reply until we get RADIUS reply)" flag off
 option "strictdhcp"    - "Be strict about only allocating dyn-pool from DHCP" flag off
@@ -211,7 +245,12 @@
 option "swapoctets"    - "Swap the meaning of input/output octets/packets" flag   off
 option "usestatusfile" - "Use the status file to keep track of sessions" string no
 option "statusfilesave" - "Aggressively save the status of sessions to status file" flag off
-option "localusers"    - "File keep 'Local' usernames and passwords" string no
+option "localusers"    - "Enable local users in database" flag   off
+option "oidc"    - "Enable OIDC SSO login" flag   off
+option "oidcforcehttps"    - "Force redirect_uri HTTPS through external redirect" flag   off
+option "oidcdiscoveryurl" - "OIDC Discovery Document URL" string no
+option "oidcclientid" - "OIDC Client ID" string no
+option "oidcclientsecret" - "OIDC Client Secret" string no
 option "postauthproxy" - "IP of an upstream transparent proxy" string no
 option "postauthproxyport" - "Port of an upstream transparent proxy" int default="0" no
 option "postauthproxyssl" - "Send SSL to upstream transparent proxy" flag off
@@ -267,6 +306,7 @@
 
 option "ipwhitelist" - "Binary IP White List file" string no
 option "uamdomainfile" - "Load uamdomains (regex) from file" string no
+option "uamblocklist" - "Allow all traffic, use uamdomainfile as a blocklist" flag off
 
 option "layer3" - "Layer3 only" flag off
 option "ipsrcallowed"  - "List of allowed source IP addresses, for Layer3" string no multiple
@@ -295,3 +335,34 @@
 option "ipv6mode" - "IPv6 mode is either 6and4 (default), 4to6, or 6to4" string no
 option "ipv6only" - "Enable IPv6-Only" flag off
 
+#Custom options
+option "successuserurl" - "Do not return to the UAM server on success, original url instead" flag  off
+option "successurlcustom" - "Return to the custom URL on success. Overwrites 'successuserurl' option" string no
+option "dbpath" - "Path to the statistics database" string no
+option "usersdbpath" - "Path to the users database" string no
+option "smsusers"    - "Enable SMS OTP for authentication" flag   off
+option "duplicateusers"    - "Enable same SMS OTP for more than one user" flag	off
+option "macusers"    - "Enable mac users for authentication" flag   off
+option "trialusers"    - "Enable trial logins" flag   off
+option "macpass"    - "Protects MAC users with password" string no
+option "registerusers"    - "Enable signup to create new users" flag   off
+option "modemid" - "GSM modem id" string no
+option "usersignup"     - "Script to run after user has been created" string no
+option "tos"    - "Enable Terms Of Service requirement" flag   off
+
+option "paramuamip"     - "Overwrites uamip parameter name" string no
+option "paramuamport"     - "Overwrites uamport parameter name" string no
+option "paramcalled"     - "Overwrites called parameter name" string no
+option "parammac"     - "Overwrites mac parameter name" string no
+option "paramip"     - "Overwrites ip parameter name" string no
+option "paramnasid"     - "Overwrites nasid parameter name" string no
+option "paramsessionid"     - "Overwrites sessionid parameter name" string no
+option "paramuserurl"     - "Overwrites userurl parameter name" string no
+option "paramchallenge"     - "Overwrites challenge parameter name" string no
+option "param1"     - "Adds custom parameter to redirect url" string no
+option "param1value"     - "The value of custom parameter" string no
+option "param2"     - "Adds custom parameter to redirect url" string no
+option "param2value"     - "The value of custom parameter" string no
+
+option "testtime"    - "Disables CLOCK_MONOTONIC and use CLOCK_REALTIME instead" flag   off
+
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdline.mini.c src/src/cmdline.mini.c
--- upstream/src/cmdline.mini.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdline.mini.c	2025-07-03 10:02:27.000000000 +0000
@@ -57,7 +57,7 @@
 		       void *d, char is_cmdline) {
   struct opt_def_t * opt = &opts[o];
 
-#if(_debug_)
+#if(_debug_ > 1)
   printf("%s opts[%d] %s [%s] offset %d\n", __FUNCTION__, o,
 	 opt->opt_name, d ? (char *)d : "(null)",
 	 opt->offset_arg);
@@ -72,7 +72,7 @@
       *p = d;
     } else {
       if (*p && !opt->multi_opt) {
-#if(_debug_)
+#if(_debug_ > 1)
 	fprintf(stderr, "Skipping option %s defined on command line\n",
 		opt->opt_name);
 #endif
@@ -85,17 +85,22 @@
 
     case OPT_integer:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
 #endif
-        *((int *)(((char *)args_info) + opt->offset_arg)) = atoi((char *)d);
+        long value = strtol((char *)d, NULL, 10);
+        if (value < INT_MIN || value > INT_MAX) {
+            fprintf(stderr, "Value out of range for int: '%s'\n", d);
+        } else {
+            *((int *)(((char *)args_info) + opt->offset_arg)) = (int)value;
+        }
       }
       *given = 1;
       break;
 
     case OPT_flag:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
 #endif
         *((int *)(((char *)args_info) + opt->offset_arg)) = 1;
@@ -135,11 +140,11 @@
 
     case OPT_long:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
         printf("long offset %d\n", opt->offset_arg);
 #endif
-        *((long *)(((char *)args_info) + opt->offset_arg)) = (long) atol((char *)d);
+        *((int64_t *)(((char *)args_info) + opt->offset_arg)) = (int64_t) strtoll((char *)d, NULL, 10);
         break;
       }
   }
@@ -232,7 +237,7 @@
       continue;
     }
 
-#if(_debug_)
+#if(_debug_ > 1)
     fprintf(stderr,"%s = %s\n", fopt, farg);
 #endif
 
@@ -250,6 +255,10 @@
     }
   }
 
+  if (line_num == 0) {
+    result = -1;
+  }
+
   return result;
 }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdsock.c src/src/cmdsock.c
--- upstream/src/cmdsock.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdsock.c	2025-07-03 10:02:27.000000000 +0000
@@ -47,7 +47,7 @@
 	cmdsock = -1;
       } else {
 	if (_options.uid) {
-	  if (chown(_options.cmdsocket, _options.uid, _options.gid)) {
+	  if (fchown(cmdsock, _options.uid, _options.gid)) {
 	    syslog(LOG_ERR, "%d could not chown() %s",
                    errno, _options.cmdsocket);
 	  }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdsock.h src/src/cmdsock.h
--- upstream/src/cmdsock.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdsock.h	2025-07-03 10:02:27.000000000 +0000
@@ -71,6 +71,7 @@
       char username[256];
       char password[256];
       char sessionid[17];
+      char userurl[REDIR_USERURLSIZE];
 #ifdef ENABLE_LOCATION
       char location[MAX_LOCATION_LENGTH];
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/database.c src/src/database.c
--- upstream/src/database.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,326 @@
+#include <inttypes.h>
+#include "chilli.h"
+
+static int _seletc_callback(void *str_session, int argc, char **argv, char **azColName) {
+    struct db_session_state *p_str_session = (struct db_session_state *)str_session;
+
+    if (argc > 0) {
+        p_str_session->input_packets = argv[0] ? strtol(argv[0], NULL, 0) : 0;
+        p_str_session->output_packets = argv[1] ? strtol(argv[1], NULL, 0) : 0;
+        p_str_session->input_octets = argv[2] ? strtol(argv[2], NULL, 0) : 0;
+        p_str_session->output_octets = argv[3] ? strtol(argv[3], NULL, 0) : 0;
+        p_str_session->sessiontime = argv[4] ? strtol(argv[4], NULL, 0) : 0;
+
+    }
+
+    return DB_SUCCESS;
+}
+
+static int dbsession_data(struct session_params *s_params, char *username, uint8_t *hismac,
+        struct db_session_state * db_state){
+    int ret;
+    char *sql;
+    char *err = 0;
+    sqlite3 *db;
+    time_t timestamp_now = mainclock_wall();
+    struct tm *time_now;
+    int start_wday, wday;
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] Trying to get sesions state %ld", __FUNCTION__, (long) timestamp_now);
+
+    time_now = localtime(&timestamp_now);
+    time_now->tm_min = 0;
+    time_now->tm_sec = 0;
+
+    switch (s_params->period)
+    {
+        case PERIOD_MONTH:
+            if (s_params->start > time_now->tm_mday)
+                time_now->tm_mon--;
+
+            time_now->tm_mday = s_params->start;
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_WEEK:
+            start_wday = s_params->start == 0 ? 7 : s_params->start;
+            wday = time_now->tm_wday == 0 ? 7 : time_now->tm_wday;
+
+            if (time_now->tm_wday != s_params->start){
+                if (start_wday > wday)
+                    time_now->tm_mday -= (7 - start_wday - wday);
+                else
+                    time_now->tm_mday -= wday -start_wday;
+            }
+
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_DAY:
+            if (s_params->start > time_now->tm_hour)
+                time_now->tm_mday--;
+
+            time_now->tm_hour = s_params->start;
+
+            break;
+    }
+
+    db = dbopen();
+    asprintf(&sql, "SELECT SUM(input_packets) AS input_packets, SUM(output_packets) AS output_packets," \
+                   "SUM(input_octets) AS input_octets, SUM(output_octets) AS output_octets," \
+                   " SUM(sessiontime) AS sessiontime FROM "TABLE_NAME \
+                   " WHERE start_time >= %"PRId64" AND username = '%s';", (uint64_t) mktime(time_now), username);
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = sqlite3_exec(db, sql, _seletc_callback, db_state, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    dbclose(db);
+    free(sql);
+
+    return ret;
+}
+
+sqlite3 *dbopen(void) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(_options.dbpath, &db);
+    if (ret)
+        syslog(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int dbclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int dbprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int dbcreate_table(sqlite3 *db){
+    int ret;
+    char *sql;
+
+    sql = "CREATE TABLE "TABLE_NAME"("
+      "id               INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE," \
+      "start_time       TIMESTAMP NOT NULL," \
+      "last_update      TIMESTAMP," \
+      "mac              VARCHAR(32)," \
+      "ip               VARCHAR(16)," \
+      "username         VARCHAR(64)," \
+      "sessiontime      BIGINT NOT NULL DEFAULT 0," \
+      "idletime         BIGINT NOT NULL DEFAULT 0," \
+      "input_octets     BIGINT NOT NULL DEFAULT 0," \
+      "output_octets    BIGINT NOT NULL DEFAULT 0," \
+      "input_packets    BIGINT NOT NULL DEFAULT 0," \
+      "output_packets   BIGINT NOT NULL DEFAULT 0," \
+      "session          BOOLEAN NOT NULL DEFAULT 0," \
+      "ifname           VARCHAR(16)," \
+      "sessionid        VARCHAR(33)," \
+      "terminate_cause  BIGINT NOT NULL DEFAULT 0," \
+      "custom           VARCHAR(64)," \
+      "url              VARCHAR(64)," \
+      "authmode         VARCHAR(64));";
+    ret = dbexec(db, sql, NULL);
+
+    return ret;
+}
+
+int dbwrite(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    time_t time_now;
+    struct session_state s_state;
+
+    time_now = mainclock_wall();
+    s_state = conn->s_state;
+
+    asprintf(&sql, INSERT_FMT, (uint64_t)time_now, MAC_ARG(conn->hismac),
+             inet_ntoa(conn->hisip), s_state.redir.username, s_state.authenticated,
+#ifdef ENABLE_MULTILAN
+			 app_conn_idx(conn) ? _options.moreif[app_conn_idx(conn)-1].dhcpif : _options.dhcpif,
+#else
+			 _options.dhcpif,
+#endif
+             s_state.sessionid, conn->s_state.redir.auth_mode, conn->s_state.redir.userurl);
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = dbexec(db, sql, NULL);
+
+    free(sql);
+    return ret;
+}
+
+int dbupdate(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    uint64_t time_now, idletime, sessiontime;
+    struct session_state s_state;
+
+    s_state = conn->s_state;
+    time_now = mainclock_wall();
+    idletime = mainclock_diffu(s_state.last_up_time);
+    sessiontime = mainclock_diffu(s_state.start_time);
+    asprintf(&sql, UPDATE_FMT, time_now, idletime, sessiontime,
+             s_state.input_octets, s_state.output_octets, s_state.input_packets,
+             s_state.output_packets, s_state.authenticated, s_state.terminate_cause_ui,
+			 MAC_ARG(conn->hismac), 1, s_state.sessionid);
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+    ret = dbexec(db, sql, NULL);
+    free(sql);
+
+    return ret;
+}
+
+int dbtable_exists(sqlite3 *db){
+    int ret;
+    int count = 0;
+    char *sql;
+    sqlite3_stmt *stmt;
+
+    sql = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='"TABLE_NAME"';";
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return DB_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? DB_FAIL : DB_SUCCESS;
+}
+
+int dbcheck_table(void){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (dbtable_exists(db) == DB_FAIL)
+        ret = dbcreate_table(db);
+
+    dbclose(db);
+
+    return ret;
+}
+
+int dbconup(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db != NULL) {
+        ret = dbwrite(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbconupdate(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db) {
+        ret = dbupdate(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbcheck_session(struct redir_conn_t *conn){
+    int ret = ACCESS_ACCEPTED;
+    uint64_t sessiontime, start_time;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (_options.debug)
+        syslog(LOG_INFO, "[%s] input_octets %" PRIi64 ", output_octets %" PRIi64 ",  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+
+    if (conn->s_params.maxinputoctets &&
+        conn->s_params.maxinputoctets < db_state.input_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.maxoutputoctets &&
+             conn->s_params.maxoutputoctets < db_state.output_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.sessiontimeout) {
+        start_time = mainclock_now() - db_state.sessiontime;
+        sessiontime = mainclock_diffu(start_time);
+        if (conn->s_params.sessiontimeout < sessiontime)
+            ret = ACCESS_DENIED_TIME;
+    }
+
+    return ret;
+}
+
+int dbsession_state(struct app_conn_t *conn){
+    int ret;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    ret = dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (!ret){
+        if (_options.debug)
+        syslog(LOG_INFO, "[%s] input_octets %" PRIi64 ", output_octets %" PRIi64 ",  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+        conn->s_history.input_packets = db_state.input_packets;
+        conn->s_history.output_packets = db_state.output_packets;
+        conn->s_history.input_octets = db_state.input_octets;
+        conn->s_history.output_octets = db_state.output_octets;
+        conn->s_history.sessiontime = db_state.sessiontime;
+    }
+
+    return ret;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/database.h src/src/database.h
--- upstream/src/database.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,43 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_DATABASE_H
+#define RUTX_DATABASE_H
+
+#include <inttypes.h>
+
+#define DB_SUCCESS 0
+#define DB_FAIL 1
+
+
+#define TABLE_NAME "statistics"
+#define INSERT_FMT "INSERT INTO "TABLE_NAME" (start_time, mac, ip, username, session, ifname, sessionid," \
+        "authmode, url) VALUES (%"PRId64", '"MAC_FMT"', '%s', '%s', %d, '%s', '%s', '%d', '%s');"
+#define UPDATE_FMT "UPDATE "TABLE_NAME \
+                 " SET last_update = %"PRId64", idletime = %"PRId64", sessiontime = %"PRId64", input_octets = %" PRIi64 "," \
+                 " output_octets = %" PRIi64 ", input_packets = %" PRIi64 ", output_packets = %" PRIi64 ", session = %d," \
+                 " terminate_cause = %d" \
+                 " WHERE mac = '"MAC_FMT"' AND session = %d AND sessionid = '%s';"
+
+struct db_session_state {
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint32_t sessiontime;
+};
+
+sqlite3 *dbopen(void);
+int dbclose(sqlite3 *db);
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int dbcreate_table(sqlite3 *db);
+int dbwrite(sqlite3 *db, struct app_conn_t *appconn);
+int dbupdate(sqlite3 *db, struct app_conn_t *appconn);
+int dbcheck_table(void);
+int dbconup(struct app_conn_t *conn);
+int dbconupdate(struct app_conn_t *conn);
+int dbsession_state(struct app_conn_t *conn);
+int dbcheck_session(struct redir_conn_t *conn);
+
+#endif //RUTX_DATABASE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dhcp.c src/src/dhcp.c
--- upstream/src/dhcp.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dhcp.c	2025-07-03 10:02:27.000000000 +0000
@@ -50,7 +50,7 @@
     struct chilli_peer *p;
     chilli_peers = (struct chilli_peer *)calloc(8, sizeof(struct chilli_peer));
     p = chilli_peers + _options.peerid;
-    memcpy(p->mac, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+    memcpy(p->mac, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
     memcpy(&p->addr, &_options.uamlisten, sizeof(_options.uamlisten));
     if (_options.peerid == 0)
       p->state = PEER_STATE_ACTIVE;
@@ -135,7 +135,7 @@
 
   packet_ethh->prot = htons(PKT_ETH_PROTO_CHILLI);
   memcpy(packet_ethh->dst, bmac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
   chilli_hdr.from = _options.peerid;
   chilli_hdr.type = type;
@@ -327,7 +327,7 @@
   packet_arp->op  = htons(DHCP_ARP_REPLY);
 
   /* Source address */
-  memcpy(packet_arp->sha, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_arp->sha, dhcp_nexthop(this, idx), PKT_ETH_ALEN);
   memcpy(packet_arp->spa, &_options.dhcplisten.s_addr, PKT_IP_ALEN);
 
   /* Target address */
@@ -339,7 +339,7 @@
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, bmac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, idx), PKT_ETH_ALEN);
   packet_ethh->prot = htons(PKT_ETH_PROTO_ARP);
 
   return dhcp_send(this, idx, bmac, packet, sizeofarp(packet));
@@ -573,7 +573,7 @@
   set_env("ADDR", VAL_IN_ADDR, &conn->ourip, 0);
   set_env("FRAMED_IP_ADDRESS", VAL_IN_ADDR, &conn->hisip, 0);
   set_env("CALLING_STATION_ID", VAL_MAC_ADDR, conn->hismac, 0);
-  set_env("CALLED_STATION_ID", VAL_MAC_ADDR, dhcp_nexthop(dhcp), 0);
+  set_env("CALLED_STATION_ID", VAL_MAC_ADDR, dhcp_nexthop(dhcp, 0), 0);
   set_env("NAS_ID", VAL_STRING, _options.radiusnasid, 0);
   set_env("8021Q_TAG", VAL_USHORT, &tag, 0);
   set_env("OLD_8021Q_TAG", VAL_USHORT, &oldtag, 0);
@@ -776,11 +776,16 @@
   return 0; /* Success */
 }
 
-uint8_t * dhcp_nexthop(struct dhcp_t *this) {
+uint8_t * dhcp_nexthop(struct dhcp_t *this, int idx) {
 #ifdef ENABLE_TAP
   if (_options.usetap && _options.has_nexthop)
     return _options.nexthop;
 #endif
+#ifdef HAVE_NETFILTER_COOVA
+  if (_options.kname) {
+    return this->rawif[idx].hwaddr;
+  }
+#endif
   return this->rawif[0].hwaddr;
 }
 
@@ -1073,8 +1078,8 @@
   if (getenv("NFQUEUE_IN") && getenv("NFQUEUE_OUT")) {
     int q1 = 0, q2 = 1;
     char *e;
-    if ((e = getenv("NFQUEUE_IN"))) q1 = atoi(e);
-    if ((e = getenv("NFQUEUE_OUT"))) q2 = atoi(e);
+    if ((e = getenv("NFQUEUE_IN"))) q1 = strtol(e, NULL, 0);
+    if ((e = getenv("NFQUEUE_OUT"))) q2 = strtol(e, NULL, 0);
     if (net_open_nfqueue(&dhcp->qif_in, q1, nfqueue_cb_in) == -1) {
       return -1;
     }
@@ -1234,10 +1239,6 @@
   return 0;
 }
 
-int dhcp_reopen() {
-  return 0;
-}
-
 int dhcp_reserve_ip(uint8_t *mac, struct in_addr *ip) {
   struct dhcp_conn_t *conn = 0;
 
@@ -1886,6 +1887,8 @@
       if (!match && hostname) {
 	match = dhcp_matchDNS(q, hostname);
 	if (match) {
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Hostname DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
 	  memcpy(reply, &_options.uamlisten.s_addr, 4);
 	}
       }
@@ -1893,7 +1896,9 @@
       if (!match && aliasname) {
 	match = dhcp_matchDNS(q, aliasname);
 	if (match) {
-	  memcpy(reply, &_options.uamalias.s_addr, 4);
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Alias DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
+	  memcpy(reply, &_options.uamlisten.s_addr, 4);
 	}
       }
 
@@ -1924,8 +1929,9 @@
 	     * count (recent) dns requests vs responses to get an
 	     * overall picture of on-line status.
 	     */
-
-	    memcpy(reply, &_options.uamalias.s_addr, 4);
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): Domain DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
+	    memcpy(reply, &_options.uamlisten.s_addr, 4);
 	    match = 1;
 	  }
 	}
@@ -2838,11 +2844,9 @@
 
 #ifdef ENABLE_TCPRESET
   if (do_reset && iph->protocol == PKT_IP_PROTO_TCP) {
-#if(_debug_ > 1)
     if (_options.debug)
       syslog(LOG_DEBUG, "%s(%d): Resetting connection on port %d->%d (undo)", __FUNCTION__, __LINE__,
              ntohs(tcph->src), ntohs(tcph->dst));
-#endif
     dhcp_sendRESET(conn, pack, 0);
     if (conn->peer) {
       tun_sendRESET(tun, pack, (struct app_conn_t *)conn->peer);
@@ -2942,7 +2946,7 @@
 
   /* Ethernet Header */
   memcpy(pack_ethh->dst, req_ethh->src, PKT_ETH_ALEN);
-  memcpy(pack_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(pack_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   /* UDP and IP Headers */
   pack_udph->src = htons(DHCP_BOOTPS);
@@ -3708,6 +3712,57 @@
 int dhcp_receive_eapol(struct dhcp_ctx *ctx, uint8_t *pack);
 int dhcp_receive_arp(struct dhcp_ctx *ctx, uint8_t *pack, size_t len);
 
+#ifdef ENABLE_TCPRESET
+static void dhcp_garden_process_tcpreset(struct dhcp_conn_t *conn, struct app_conn_t *appconn, 
+                             uint8_t *pack, struct pkt_iphdr_t *iph, struct pkt_tcphdr_t *tcph,
+                             pass_through *pass_throughs, int num_pass_throughs) {
+  for (int i = 0; i < num_pass_throughs; i++) {
+    if ((iph->saddr == pass_throughs[i].host.s_addr &&
+        (pass_throughs[i].port == 0 || tcph->src == htons(pass_throughs[i].port))) ||
+        (iph->daddr == pass_throughs[i].host.s_addr &&
+        (pass_throughs[i].port == 0 || tcph->dst == htons(pass_throughs[i].port))))
+    {
+      int found = 0;
+      for (int j = 0; j < appconn->s_params.num_tcp_reset_addr; j++) {
+        if (appconn->s_params.tcp_reset_addr[j].s_addr == pass_throughs[i].host.s_addr) {
+          found = 1;
+          break;
+        }
+      }
+      if (found)
+        continue;
+
+      uint8_t tcp_pack[1500];
+      dhcp_send(conn->parent, dhcp_conn_idx(conn), conn->hismac, tcp_pack, tcprst(tcp_pack, pack, 1));
+      dhcp_send(conn->parent, dhcp_conn_idx(conn), conn->hismac, tcp_pack, tcprst(tcp_pack, pack, 0));
+
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): Pass through TCP RESET %s:%d", __FUNCTION__, __LINE__,
+                inet_ntoa(pass_throughs[i].host),
+                pass_throughs[i].port);
+
+      appconn->s_params.tcp_reset_addr[appconn->s_params.num_tcp_reset_addr++] = pass_throughs[i].host;
+    }
+  }
+}
+
+static void dhcp_garden_tcpreset(struct dhcp_conn_t *conn, struct app_conn_t *appconn, uint8_t *pack) {
+  if (!appconn->s_state.authenticated)
+    return;
+
+  struct pkt_iphdr_t  *iph  = pkt_iphdr(pack);
+  struct pkt_tcphdr_t *tcph = pkt_tcphdr(pack);
+  if (iph->protocol != PKT_IP_PROTO_TCP)
+    return;
+
+  if (appconn->s_params.num_tcp_reset_addr >= _options.num_pass_throughs + dhcp->num_pass_throughs)
+    return;
+
+  dhcp_garden_process_tcpreset(conn, appconn, pack, iph, tcph, _options.pass_throughs, _options.num_pass_throughs);
+  dhcp_garden_process_tcpreset(conn, appconn, pack, iph, tcph, dhcp->pass_throughs, dhcp->num_pass_throughs);
+}
+#endif
+
 /**
  *  dhcp_receive_ip()
  *  Received a packet from the dhcpif
@@ -3760,7 +3815,7 @@
    */
   if (!dhcp_hashget(this, &conn, pack_ethh->src)) {
 
-    if (_options.debug)
+    if (_options.debug > 2)
       syslog(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
 
     ourip.s_addr = conn->ourip.s_addr;
@@ -3913,7 +3968,7 @@
   /*
    *  Check that the destination MAC address is our MAC or Broadcast
    */
-  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this), PKT_ETH_ALEN)) &&
+  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN)) &&
       (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
 #ifdef ENABLE_MDNS
     /* http://en.wikipedia.org/wiki/IP_multicast */
@@ -3926,10 +3981,12 @@
                MAC_ARG(pack_ethh->dst));
     } else {
 #endif
-#if(_debug_)
+#if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Not for our MAC or broadcast: "MAC_FMT, __FUNCTION__, __LINE__,
-               MAC_ARG(pack_ethh->dst));
+        syslog(LOG_DEBUG, "%s(%d): Not for our MAC ("MAC_FMT") or broadcast ("MAC_FMT"): "MAC_FMT, __FUNCTION__, __LINE__,
+                MAC_ARG(bmac),
+                MAC_ARG(dhcp_nexthop(this, dhcp_conn_idx(conn))),
+                MAC_ARG(pack_ethh->dst));
 #endif
       OTHER_RECEIVED(conn, pack_iph);
       return 0;
@@ -4119,8 +4176,9 @@
         if (appconn) {
           if (appconn->s_state.authenticated) {
             terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Dropping session due to request for auto-logout ip", __FUNCTION__, __LINE__);
+            char str[INET_ADDRSTRLEN] = {0};
+            inet_ntop(AF_INET, &(appconn->hisip), str, INET_ADDRSTRLEN);
+            syslog(LOG_INFO, "Dropping session due to request for auto-logout from username=%s IP=%s", appconn->s_state.redir.username, str);
             appconn->uamexit = 1;
           }
         }
@@ -4170,6 +4228,10 @@
           appconn = (struct app_conn_t *)conn->peer;
           appconn->s_state.last_up_time =
               appconn->s_state.last_time = mainclock_now();
+
+#ifdef ENABLE_TCPRESET
+          dhcp_garden_tcpreset(conn, appconn, pack);
+#endif
         }
         return 1;
       }
@@ -4440,7 +4502,7 @@
             data_len += 2 + PKT_ETH_ALEN;
             *payload++ = 1;
             *payload++ = 1;
-            memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+            memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
             payload += PKT_ETH_ALEN;
             
             /* MTU option */
@@ -4499,7 +4561,7 @@
             memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
             
             memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-            memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+            memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
             
             chksum6(packet_ip6h);
             
@@ -4555,7 +4617,7 @@
 	  data_len += 2 + PKT_ETH_ALEN;
 	  *payload++ = 2;
 	  *payload++ = 1;
-	  memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	  memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	  packet_ip6h->ver_class_label = iphdr->ver_class_label;
 	  packet_ip6h->next_header = iphdr->next_header;
@@ -4567,7 +4629,7 @@
 	  memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
 
 	  memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-	  memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	  memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	  chksum6(packet_ip6h);
 
@@ -4688,7 +4750,7 @@
 	      u = htons(1); memcpy(payload, &u, 2); payload+=2;
 	      u = htons(1); memcpy(payload, &u, 2); payload+=2;
 	      u2 = htonl(time(0)); memcpy(payload, &u2, 4); payload+=4;
-	      memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 	      payload+=PKT_ETH_ALEN;
 
 	      if (ia_type) {
@@ -4761,7 +4823,7 @@
 	      memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
 
 	      memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-	      memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	      chksum6(packet_ip6h);
 
@@ -4922,7 +4984,7 @@
 	       */
 
 	      memcpy(&answer_ethh->dst, &ethh->src, PKT_ETH_ALEN);
-	      memcpy(&answer_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(&answer_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	      dhcp_send(dhcp, ctx->idx, conn->hismac, answer, length);
 	    } break;
@@ -5069,7 +5131,7 @@
 	 */
 
 	memcpy(&answer_ethh->dst, &ethh->src, PKT_ETH_ALEN);
-	memcpy(&answer_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	memcpy(&answer_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
         
 	dhcp_send(dhcp, dhcp_conn_idx(conn), conn->hismac, answer, length);
       } break;
@@ -5519,16 +5581,18 @@
     }
   }
 
-  if (conn->authstate == DHCP_AUTH_NONE ||
-      conn->authstate == DHCP_AUTH_DNAT)
+  if (message_type->v[0] != DHCPNAK &&
+      (conn->authstate == DHCP_AUTH_NONE ||
+       conn->authstate == DHCP_AUTH_DNAT)) {
     this->cb_request(conn, (struct in_addr *)&packet.yiaddr, 0, 0);
+  }
 
   packet.giaddr = 0;
 
   memset(&fullpack, 0, sizeof(fullpack));
 
   dhcp_ethhdr(conn, fullpack, conn->hismac,
-	      dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+	      dhcp_nexthop(this, idx), PKT_ETH_PROTO_IP);
 
   {
     struct pkt_iphdr_t *fullpack_iph = pkt_iphdr(fullpack);
@@ -5556,7 +5620,7 @@
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): DHCP: Nak or Broadcast", __FUNCTION__, __LINE__);
       packet.flags[0] = 0x80;
-      dhcp_ethhdr(conn, fullpack, bmac, dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+      dhcp_ethhdr(conn, fullpack, bmac, dhcp_nexthop(this, idx), PKT_ETH_PROTO_IP);
     } else if (packet.yiaddr) {
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): DHCP: YIAddr", __FUNCTION__, __LINE__);
@@ -5691,7 +5755,7 @@
   authstate = conn->authstate;
 #endif
 
-  dhcp_ethhdr(conn, packet, conn->hismac, dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+  dhcp_ethhdr(conn, packet, conn->hismac, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_PROTO_IP);
 
   switch (dhcp_dnsunDNAT(conn, packet, &length, &do_checksum)) {
     case 0:  /* Not DNS */break;
@@ -5823,7 +5887,7 @@
 
   /* Source address */
   memcpy(packet_arp->spa, &reqaddr.s_addr, PKT_IP_ALEN);
-  memcpy(packet_arp->sha, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_arp->sha, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   /* Target address */
   memcpy(packet_arp->tha, &conn->hismac, PKT_ETH_ALEN);
@@ -5836,7 +5900,7 @@
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, conn->hismac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   OTHER_SENDING_LEN(conn,sizeof(struct arp_packet_t));
   return dhcp_send(this, dhcp_conn_idx(conn), conn->hismac,
@@ -5874,14 +5938,6 @@
     return 0;
   }
 
-  /* Check that MAC address is our MAC or Broadcast */
-  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this), PKT_ETH_ALEN)) &&
-      (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Received ARP request for other destination!", __FUNCTION__, __LINE__);
-    return 0;
-  }
-
   /* get sender IP address */
   memcpy(&reqaddr.s_addr, &pack_arp->spa, PKT_IP_ALEN);
 
@@ -5941,6 +5997,14 @@
     }
   }
 
+  /* Check that MAC address is our MAC or Broadcast */
+  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN)) &&
+      (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): ARP: Received ARP request for other destination!", __FUNCTION__, __LINE__);
+    return 0;
+  }
+
   OTHER_RECEIVED_LEN(conn, len-PKT_ETH_HLEN);
   dhcp_conn_set_idx(conn, ctx);
 
@@ -5955,9 +6019,11 @@
 #endif
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ARP: "MAC_FMT" asking about %s", __FUNCTION__, __LINE__,
-           MAC_ARG(conn->hismac),
-           inet_ntoa(taraddr));
+    syslog(LOG_DEBUG, "%s(%d): ARP: %s ("MAC_FMT") interface "MAC_FMT" asking about %s", __FUNCTION__, __LINE__,
+            this->rawif[dhcp_conn_idx(conn)].devname,
+            MAC_ARG(this->rawif[dhcp_conn_idx(conn)].hwaddr),
+            MAC_ARG(conn->hismac),
+            inet_ntoa(taraddr));
 
   if (conn->authstate == DHCP_AUTH_DROP) {
     return 0;
@@ -6095,7 +6161,7 @@
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, conn->hismac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   packet_ethh->prot = htons(PKT_ETH_PROTO_EAPOL);
 
@@ -6188,7 +6254,7 @@
 
     memset(&p, 0, sizeof(p));
     dhcp_ethhdr(conn, p, pack_ethh->src,
-		dhcp_nexthop(this), PKT_ETH_PROTO_EAPOL);
+		dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_PROTO_EAPOL);
 
     p_dot1x = pkt_dot1xhdr(p);
     p_eap = pkt_eappkt(p);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dhcp.h src/src/dhcp.h
--- upstream/src/dhcp.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dhcp.h	2025-07-03 10:02:27.000000000 +0000
@@ -300,7 +300,7 @@
 int dhcp_decaps(struct dhcp_t *this, int idx);
 int dhcp_relay_decaps(struct dhcp_t *this, int idx);
 int dhcp_data_req(struct dhcp_conn_t *conn, struct pkt_buffer *pb, int ethhdr);
-uint8_t * dhcp_nexthop(struct dhcp_t *);
+uint8_t * dhcp_nexthop(struct dhcp_t *, int idx);
 
 #if defined (__FreeBSD__) || defined (__APPLE__) || defined (__OpenBSD__) || defined (__NetBSD__)
 int dhcp_receive(struct dhcp_t *this, int idx);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dns.c src/src/dns.c
--- upstream/src/dns.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dns.c	2025-07-03 10:02:27.000000000 +0000
@@ -136,7 +136,11 @@
 	     int isReq, int *qmatch, int *modified, int mode) {
 
 #define return_error {                                                  \
-    if (_options.debug) syslog(LOG_DEBUG, "%s(%d): failed parsing DNS packet", __FUNCTION__, __LINE__); return -1; }
+		if (_options.debug)					\
+			syslog(LOG_DEBUG, "%s(%d): failed parsing DNS packet", __FUNCTION__, __LINE__); \
+									\
+		return -1; \
+}
 
   uint8_t *p_pkt = *pktp;
   size_t len = *left;
@@ -253,7 +257,7 @@
     }
 
 #ifdef ENABLE_UAMDOMAINFILE
-    if (!isReq && *qmatch == -1 && _options.uamdomainfile) {
+    if (!isReq && *qmatch == -1 && (_options.uamdomainfile || _options.uamblocklist)) {
       *qmatch = garden_check_domainfile((char *) question);
     }
 #endif
@@ -410,6 +414,10 @@
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): SRV record", __FUNCTION__, __LINE__);
       break;
+    case 35:
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): NAPTR record", __FUNCTION__, __LINE__);
+      break;
     case 41:
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): EDNS OPT pseudorecord", __FUNCTION__, __LINE__);
@@ -418,6 +426,14 @@
       if (_options.debug)
         syslog(LOG_DEBUG, "%s(%d): NSEC record", __FUNCTION__, __LINE__);
       break;
+    case 64:
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): SVCB record", __FUNCTION__, __LINE__);
+      break;
+    case 65:
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): HTTPS record", __FUNCTION__, __LINE__);
+      break;
   }
 
   if (antidnstunnel && !required) {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/garden.c src/src/garden.c
--- upstream/src/garden.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/garden.c	2025-07-03 10:02:27.000000000 +0000
@@ -478,7 +478,7 @@
   if (p3 == NULL)
      return 0;
 
-  strcpy(p3, s);
+  strncpy(p3, s, strlen(s));
   p1 = p3;
 
   if (_options.debug)
@@ -506,7 +506,7 @@
 	struct protoent *proto = getprotobyname(p1);
 
 	if (!proto && !strchr(p1, '.'))
-	  proto = getprotobynumber(atoi(p1));
+	  proto = getprotobynumber(strtol(p1, NULL, 0));
 
 	if (proto)
 	  pnum = proto->p_proto;
@@ -531,7 +531,7 @@
     {
       char *e = strchr(p1, '#');
       if (e) {
-	int add = atoi(e+1);
+	int add = strtol(e+1, NULL, 0);
 	pt.expiry = mainclock_now() + add;
 	*e = 0;
       }
@@ -540,7 +540,7 @@
 
     /* look for an optional port */
     if ((t = strchr(p1, ':'))) {
-      pt.port = atoi(t+1);
+      pt.port = strtol(t+1, NULL, 0);
       *t = 0;
     }
 
@@ -736,12 +736,12 @@
         syslog(LOG_DEBUG, "%s(%d): matched DNS name %s", __FUNCTION__, __LINE__, question);
 #endif
 
-    if (match) return uam_re->neg ? 0 : 1;
+    if (match) return uam_re->neg ? (_options.uamblocklist ? 1 : 0) : (_options.uamblocklist ? 0 : 1);
 
     uam_re = uam_re->next;
   }
 
-  return -1;
+  return _options.uamblocklist ? 1 : -1;
 }
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/gsm.c src/src/gsm.c
--- upstream/src/gsm.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,61 @@
+
+#ifdef HAVE_SYSLOG_H
+#include <syslog.h>
+#endif
+
+#include "system.h"
+#include <libgsm.h>
+#include <libgsm_utils.h>
+
+#include "gsm.h"
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	struct ubus_context *ubus;
+	lgsm_structed_info_t data = { 0 };
+	int ret = CHILLI_GSM_ERR;
+	int modem_num;
+
+	ubus = ubus_connect(NULL);
+	if (!ubus) {
+		return CHILLI_GSM_ERR;
+	}
+
+	if ((modem_num = lgsmu_modem_id_to_num(ubus, modem_id)) < 0) {
+		syslog(LOG_ERR, "Unable to get modem '%s' number", modem_id);
+
+		goto out;
+	}
+
+	if (lgsm_send_sms(ubus, phone, msg, &data, modem_num) == LGSM_SUCCESS) {
+		ret = CHILLI_GSM_OK;
+	} else {
+		syslog(LOG_ERR, "Unable to send SMS message to %s", phone);
+	}
+
+out:
+	ubus_free(ubus);
+	handle_gsm_structed_info_free(&data);
+
+	return ret;
+}
+
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	int status;
+
+	if ((status = fork()) < 0) {
+		syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+		return CHILLI_GSM_ERR;
+	}
+
+	if (status > 0) { /* Parent */
+		return CHILLI_GSM_OK;
+	}
+
+	chilli_send_sms(phone, msg, modem_id);
+
+	exit(0);
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/gsm.h src/src/gsm.h
--- upstream/src/gsm.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,20 @@
+
+#ifndef RUTX_GSM_H
+#define RUTX_GSM_H
+
+#include <libgsm.h>
+
+#define GSM_DEFAULT_USB_ID "3-1"
+
+typedef enum {
+    CHILLI_GSM_OK,
+    CHILLI_GSM_ERR
+} chilli_gsm_t;
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id);
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id);
+
+#endif //RUTX_GSM_H
+
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/linux/libxt_coova.c src/src/linux/libxt_coova.c
--- upstream/src/linux/libxt_coova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/linux/libxt_coova.c	2025-07-03 10:02:27.000000000 +0000
@@ -126,7 +126,7 @@
 	.extra_opts    = coova_opts,
 };
 
-void _init(void)
+void __attribute__ ((constructor)) libxt_coova_init(void)
 {
 	xtables_register_match(&coova_mt_reg);
 	xtables_register_match(&coova_mt6_reg);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/linux/xt_coova.c src/src/linux/xt_coova.c
--- upstream/src/linux/xt_coova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/linux/xt_coova.c	2025-07-03 10:02:27.000000000 +0000
@@ -45,9 +45,9 @@
 static unsigned int ip_list_tot = 100;
 static unsigned int ip_pkt_list_tot = 20;
 static unsigned int ip_list_hash_size = 0;
-static unsigned int ip_list_perms = 0644;
+static unsigned int ip_list_perms = 0660;
 static unsigned int ip_list_uid = 0;
-static unsigned int ip_list_gid = 0;
+static unsigned int ip_list_gid = 511;
 module_param(ip_list_tot, uint, 0400);
 module_param(ip_pkt_list_tot, uint, 0400);
 module_param(ip_list_hash_size, uint, 0400);
@@ -91,8 +91,12 @@
 
 #ifdef CONFIG_PROC_FS
 static struct proc_dir_entry *coova_proc_dir;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+static const struct proc_ops coova_old_fops, coova_mt_fops;
+#else
 static const struct file_operations coova_old_fops, coova_mt_fops;
 #endif
+#endif
 
 static u_int32_t hash_rnd;
 static bool hash_rnd_initted;
@@ -230,7 +234,7 @@
 		else
 			addr.ip = iph->saddr;
 
-		p_bytes = iph->tot_len;
+		p_bytes = ntohs(iph->tot_len);
 	} else {
 		const struct ipv6hdr *iph = ipv6_hdr(skb);
 
@@ -239,7 +243,7 @@
 		else
 			memcpy(&addr.in6, &iph->saddr, sizeof(addr.in6));
 
-		p_bytes = iph->payload_len;
+		p_bytes = ntohs(iph->payload_len);
 	}
 
 	if (info->side != XT_COOVA_DEST) {
@@ -305,14 +309,18 @@
 	    strnlen(info->name, XT_COOVA_NAME_LEN) == XT_COOVA_NAME_LEN)
 		return -EINVAL;
 
+#ifdef DEBUG
 	printk(KERN_INFO "xt_coova: looking for %s\n", info->name);
+#endif
 
 	mutex_lock(&coova_mutex);
 	t = coova_table_lookup(info->name);
 	if (t != NULL) {
 		t->refcnt++;
+#ifdef DEBUG
 		printk(KERN_INFO "xt_coova: found %s refcnt=%d\n", 
 		       info->name, t->refcnt);
+#endif
 		goto out;
 	}
 
@@ -323,7 +331,7 @@
 		goto out;
 	}
 	t->refcnt = 1;
-	strcpy(t->name, info->name);
+	strncpy(t->name, info->name, strlen(info->name));
 	INIT_LIST_HEAD(&t->lru_list);
 	for (i = 0; i < ip_list_hash_size; i++)
 		INIT_LIST_HEAD(&t->iphash[i]);
@@ -348,11 +356,15 @@
 	spin_lock_bh(&coova_lock);
 	list_add_tail(&t->list, &tables);
 	spin_unlock_bh(&coova_lock);
+#ifdef DEBUG
 	printk(KERN_INFO "xt_coova: created %s refcnt=%d\n", 
 	       t->name, t->refcnt);
+#endif
 out:
 	mutex_unlock(&coova_mutex);
-	printk(KERN_INFO "xt_coova: match ret=%d\n", ret); 
+#ifdef DEBUG
+	printk(KERN_INFO "xt_coova: match ret=%d\n", ret);
+#endif
 	return ret;
 }
 
@@ -406,12 +418,13 @@
 	const struct coova_entry *e = v;
 	const struct list_head *head = e->list.next;
 
+	(*pos)++;
 	while (head == &t->iphash[st->bucket]) {
 		if (++st->bucket >= ip_list_hash_size)
 			return NULL;
 		head = t->iphash[st->bucket].next;
 	}
-	(*pos)++;
+	
 	return list_entry(head, struct coova_entry, list);
 }
 
@@ -577,6 +590,14 @@
 	return size + 1;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+static const struct proc_ops coova_mt_fops = {
+	.proc_open    = coova_seq_open,
+	.proc_read    = seq_read,
+	.proc_write   = coova_mt_proc_write,
+	.proc_release = seq_release_private,
+};
+#else
 static const struct file_operations coova_mt_fops = {
 	.open    = coova_seq_open,
 	.read    = seq_read,
@@ -584,6 +605,7 @@
 	.release = seq_release_private,
 	.owner   = THIS_MODULE,
 };
+#endif
 #endif /* CONFIG_PROC_FS */
 
 static struct xt_match coova_mt_reg[] __read_mostly = {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-opt.c src/src/main-opt.c
--- upstream/src/main-opt.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-opt.c	2025-07-03 10:02:27.000000000 +0000
@@ -24,6 +24,10 @@
 #include "system.h"
 #include "chilli.h"
 
+#ifdef ENABLE_GSM
+#include <libgsm_utils.h>
+#endif
+
 struct options_t _options;
 
 static const char *description =
@@ -63,6 +67,9 @@
 #ifdef ENABLE_CHILLIQUERY
     "ENABLE_CHILLIQUERY "
 #endif
+#ifdef ENABLE_UBUS
+"ENABLE_UBUS "
+#endif
 #ifdef ENABLE_CHILLIPROXY
     "ENABLE_CHILLIPROXY "
 #endif
@@ -255,6 +262,12 @@
 #ifdef USING_POLL
     "USING_POLL "
 #endif
+#ifdef  ENABLE_DATABASE
+    "ENABLE_DATABASE "
+#endif
+#ifdef  ENABLE_GSM
+    "ENABLE_GSM "
+#endif
 #ifdef EX_OPT_FEATURES
 #include EX_OPT_FEATURES
 #endif
@@ -415,6 +428,8 @@
   _options.swapoctets = args_info.swapoctets_flag;
   _options.chillixml = args_info.chillixml_flag;
   _options.macauth = args_info.macauth_flag;
+  _options.macdelimiter = args_info.macdelimiter_arg;
+  _options.maclower = args_info.maclower_flag;
   _options.macreauth = args_info.macreauth_flag;
   _options.macauthdeny = args_info.macauthdeny_flag;
   _options.uamport = args_info.uamport_arg;
@@ -435,6 +450,37 @@
   _options.defbandwidthmaxdown = args_info.defbandwidthmaxdown_arg;
   _options.defbandwidthmaxup = args_info.defbandwidthmaxup_arg;
   _options.defidletimeout = args_info.defidletimeout_arg;
+  _options.defmaxdownload = args_info.defmaxdownload_arg;
+  _options.defmaxupload = args_info.defmaxupload_arg;
+  _options.defwarning = args_info.defwarning_arg;
+  _options.deflimitperiod = args_info.deflimitperiod_arg;
+  _options.deflimitstart = args_info.deflimitstart_arg;
+  _options.defexpirationtime = args_info.defexpirationtime_arg;
+
+  _options.dynsessiontimeout = args_info.dynsessiontimeout_arg;
+  _options.dynbandwidthmaxdown = args_info.dynbandwidthmaxdown_arg;
+  _options.dynbandwidthmaxup = args_info.dynbandwidthmaxup_arg;
+  _options.dynmaxdownload = args_info.dynmaxdownload_arg;
+  _options.dynwarning = args_info.dynwarning_arg;
+  _options.dynmaxupload = args_info.dynmaxupload_arg;
+  _options.dynexpirationtime = args_info.dynexpirationtime_arg;
+  _options.dyninteriminterval = args_info.dyninteriminterval_arg;
+  _options.dynidletimeout = args_info.dynidletimeout_arg;
+  _options.dynlimitperiod = args_info.dynlimitperiod_arg;
+  _options.dynlimitstart = args_info.dynlimitstart_arg;
+
+  _options.trialsessiontimeout = args_info.trialsessiontimeout_arg;
+  _options.trialinteriminterval = args_info.trialinteriminterval_arg;
+  _options.trialbandwidthmaxdown = args_info.trialbandwidthmaxdown_arg;
+  _options.trialbandwidthmaxup = args_info.trialbandwidthmaxup_arg;
+  _options.trialidletimeout = args_info.trialidletimeout_arg;
+  _options.trialmaxdownload = args_info.trialmaxdownload_arg;
+  _options.trialmaxupload = args_info.trialmaxupload_arg;
+  _options.trialwarning = args_info.trialwarning_arg;
+  _options.triallimitperiod = args_info.triallimitperiod_arg;
+  _options.triallimitstart = args_info.triallimitstart_arg;
+  _options.trialexpirationtime = args_info.dynexpirationtime_arg;
+
   _options.radiusnasporttype = args_info.radiusnasporttype_arg;
   _options.radiusauthport = args_info.radiusauthport_arg;
   _options.radiusacctport = args_info.radiusacctport_arg;
@@ -469,6 +515,7 @@
   _options.dhcp_broadcast = args_info.dhcpbroadcast_flag;
   _options.dhcpgwport = args_info.dhcpgatewayport_arg;
   _options.noc2c = args_info.noc2c_flag;
+  _options.radiusrequiremessageauth = args_info.radiusrequiremessageauth_flag;
   _options.tcpwin = args_info.tcpwin_arg;
   _options.tcpmss = args_info.tcpmss_arg;
   _options.max_clients = args_info.maxclients_arg;
@@ -477,10 +524,14 @@
   _options.uamdomain_ttl = args_info.uamdomainttl_arg;
   _options.seskeepalive = args_info.seskeepalive_flag;
   _options.uamallowpost = args_info.uamallowpost_flag;
+#ifdef ENABLE_UAMDOMAINFILE
+  _options.uamblocklist = args_info.uamblocklist_flag;
+#endif
   _options.redir = args_info.redir_flag;
   _options.redirurl = args_info.redirurl_flag;
   _options.statusfilesave = args_info.statusfilesave_flag;
   _options.dhcpnotidle = args_info.dhcpnotidle_flag;
+  _options.successuserurl = args_info.successuserurl_flag;
 #if(_debug_ && !defined(ENABLE_CHILLIREDIR))
   if (_options.redir)
     syslog(LOG_ERR, "chilli_redir not implemented. build with --enable-chilliredir");
@@ -718,6 +769,12 @@
   syslog(LOG_DEBUG, "DHCP Listen: %s", inet_ntoa(_options.dhcplisten));
   syslog(LOG_DEBUG, "UAM Listen: %s", inet_ntoa(_options.uamlisten));
 
+#ifdef HAVE_NETFILTER_COOVA
+  if (args_info.kname_arg) {
+    syslog(LOG_DEBUG, "Using kernel module for %s", args_info.kname_arg);
+  }
+#endif
+
   if (args_info.rfc7710uri_given) {
     /*
      * When given, but set to an empty string, the feature is disabled.
@@ -757,40 +814,49 @@
 	goto end_processing;
     }
 
-    if (!args_info.uamaliasname_arg ||
-	strncmp(args_info.uamaliasname_arg, hostname,
-		strlen(args_info.uamaliasname_arg))) {
-      if (!(host = gethostbyname(hostname))) {
-	syslog(LOG_ERR, "Could not resolve IP address of uamserver: %s!",
-               args_info.uamserver_arg);
+    // local domain should resolve to local ip
+    if (args_info.uamaliasname_arg && args_info.domain_arg) {
+      char full_local_hostname[USERURLSIZE];
+      strncpy(full_local_hostname, args_info.uamaliasname_arg, USERURLSIZE - 1);
+      strncat(full_local_hostname, ".", 1);
+      strncat(full_local_hostname, args_info.domain_arg, USERURLSIZE - strlen(full_local_hostname) - 1);
+      if (strcmp(full_local_hostname, hostname) == 0) {
+        strncpy(hostname, inet_ntoa(_options.uamlisten), USERURLSIZE - 1);
+        hostname[USERURLSIZE - 1] = '\0';
       }
-      else {
-	int j = 0;
-	pass_through pt;
+    }
 
-	memset(&pt, 0, sizeof(pt));
-	pt.port = uamserverport;
-	pt.mask.s_addr = ~0;
-
-	while (host->h_addr_list[j] != NULL) {
-	  if (_options.debug & DEBUG_CONF) {
-	    syslog(LOG_DEBUG, "Uamserver IP address #%d: %s\n", j,
-                   inet_ntoa(*(struct in_addr*) host->h_addr_list[j]));
-	  }
+    if (!(host = gethostbyname(hostname))) {
+syslog(LOG_ERR, "Could not resolve IP address of uamserver: %s!",
+            args_info.uamserver_arg);
+    }
+    else {
+
+int j = 0;
+pass_through pt;
+
+memset(&pt, 0, sizeof(pt));
+pt.port = uamserverport;
+pt.mask.s_addr = ~0;
+
+while (host->h_addr_list[j] != NULL) {
+  if (_options.debug & DEBUG_CONF) {
+    syslog(LOG_DEBUG, "Uamserver IP address #%d: %s\n", j,
+                  inet_ntoa(*(struct in_addr*) host->h_addr_list[j]));
+  }
 
-	  pt.host.s_addr = ((struct in_addr*) host->h_addr_list[j++])->s_addr;
+  pt.host.s_addr = ((struct in_addr*) host->h_addr_list[j++])->s_addr;
 
-	  if (pass_through_add(_options.pass_throughs,
-			       MAX_PASS_THROUGHS,
-			       &_options.num_pass_throughs, &pt, 0
+  if (pass_through_add(_options.pass_throughs,
+          MAX_PASS_THROUGHS,
+          &_options.num_pass_throughs, &pt, 0
 #ifdef HAVE_PATRICIA
-			       , 0
+          , 0
 #endif
-			       ))
-	    syslog(LOG_ERR, "Too many pass-throughs! skipped %s:%d",
-                   inet_ntoa(pt.host), pt.port);
-	}
-      }
+          ))
+    syslog(LOG_ERR, "Too many pass-throughs! skipped %s:%d",
+                inet_ntoa(pt.host), pt.port);
+}
     }
   }
 
@@ -1205,7 +1271,7 @@
 
     syslog(LOG_DEBUG, "Macallowed #%d: %s", numargs, args_info.macallowed_arg[numargs]);
 
-    strcpy(p3, args_info.macallowed_arg[numargs]);
+    strncpy(p3, args_info.macallowed_arg[numargs], strlen(args_info.macallowed_arg[numargs]));
     p1 = p3;
     if ((p2 = strchr(p1, ','))) {
       *p2 = '\0';
@@ -1317,7 +1383,7 @@
 	char s[256];
 
 	if (sscanf(args_info.extadmvsa_arg[numargs],
-		   "%u,%u:%s", &i[0], &i[1], s) == 3) {
+		   "%u,%u:%256s", &i[0], &i[1], s) == 3) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr_vsa = i[0];
 	  _options.extadmvsa[numargs].attr = i[1];
@@ -1329,7 +1395,7 @@
                     idx + 1, sizeof(_options.extadmvsa[numargs].data));
 	  }
 	} else if (sscanf(args_info.extadmvsa_arg[numargs],
-			  "%u:%s", &i[0], s) == 2) {
+			  "%u:%256s", &i[0], s) == 2) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr = i[0];
 	  if (idx) *idx = 0;
@@ -1358,7 +1424,14 @@
   _options.wwwdir = STRDUP(args_info.wwwdir_arg);
   _options.wwwbin = STRDUP(args_info.wwwbin_arg);
   _options.uamui = STRDUP(args_info.uamui_arg);
-  _options.localusers = STRDUP(args_info.localusers_arg);
+  _options.localusers = args_info.localusers_flag;
+#ifdef USING_CURL
+  _options.oidc = args_info.oidc_flag;
+  _options.oidcforcehttps = args_info.oidcforcehttps_flag;
+  _options.oidcdiscoveryurl = STRDUP(args_info.oidcdiscoveryurl_arg);
+  _options.oidcclientid = STRDUP(args_info.oidcclientid_arg);
+  _options.oidcclientsecret = STRDUP(args_info.oidcclientsecret_arg);
+#endif
   _options.uamurl = STRDUP(args_info.uamserver_arg);
   _options.uamaaaurl = STRDUP(args_info.uamaaaurl_arg);
   _options.uamhomepage = STRDUP(args_info.uamhomepage_arg);
@@ -1391,6 +1464,7 @@
   _options.ipdown = STRDUP(args_info.ipdown_arg);
   _options.conup = STRDUP(args_info.conup_arg);
   _options.condown = STRDUP(args_info.condown_arg);
+  _options.conrestart = STRDUP(args_info.conrestart_arg);
   _options.macup = STRDUP(args_info.macup_arg);
   _options.macdown = STRDUP(args_info.macdown_arg);
   _options.pidfile = STRDUP(args_info.pidfile_arg);
@@ -1409,6 +1483,43 @@
   _options.locationupdate = STRDUP(args_info.locationupdate_arg);
 #endif
   _options.nochallenge = args_info.nochallenge_flag;
+  _options.successurlcustom = STRDUP(args_info.successurlcustom_arg);
+  _options.dbpath = STRDUP(args_info.dbpath_arg);
+  _options.usersdbpath = STRDUP(args_info.usersdbpath_arg);
+  _options.smsusers = args_info.smsusers_flag;
+  _options.duplicateusers = args_info.duplicateusers_flag;
+  _options.macusers = args_info.macusers_flag;
+  _options.trialusers = args_info.trialusers_flag;
+  _options.usersignup = STRDUP(args_info.usersignup_arg);
+  _options.macpass = STRDUP(args_info.macpass_arg);
+  _options.tos = args_info.tos_flag;
+  _options.registerusers = args_info.registerusers_flag;
+
+  _options.paramuamip = STRDUP(args_info.paramuamip_arg);
+  _options.paramuamport = STRDUP(args_info.paramuamport_arg);
+  _options.paramcalled  = STRDUP(args_info.paramcalled_arg);
+  _options.parammac = STRDUP(args_info.parammac_arg);
+  _options.paramip = STRDUP(args_info.paramip_arg);
+  _options.paramnasid = STRDUP(args_info.paramnasid_arg);
+  _options.paramsessionid = STRDUP(args_info.paramsessionid_arg);
+  _options.paramuserurl = STRDUP(args_info.paramuserurl_arg);
+  _options.paramchallenge = STRDUP(args_info.paramchallenge_arg);
+  _options.param1 = STRDUP(args_info.param1_arg);
+  _options.param1value = STRDUP(args_info.param1value_arg);
+  _options.param2  = STRDUP(args_info.param2_arg);
+  _options.param2value = STRDUP(args_info.param2value_arg);
+
+  _options.testtime = args_info.testtime_flag;
+#ifdef ENABLE_GSM
+  _options.modemid = STRDUP(args_info.modemid_arg);
+  if (!_options.modemid) {
+  	struct ubus_context *ubus;
+  	if ((ubus = ubus_connect(NULL))) {
+  		_options.modemid = STRDUP(lgsmu_get_default_modem_id(ubus));
+  		ubus_shutdown(ubus);
+  	}
+  }
+#endif
 #ifdef EX_OPT_MAIN
 #include EX_OPT_MAIN
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-proxy.c src/src/main-proxy.c
--- upstream/src/main-proxy.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-proxy.c	2025-07-03 10:02:27.000000000 +0000
@@ -325,7 +325,7 @@
 	    switch(attrs[i].t) {
               case 0: /*integer*/
                 {
-                  uint32_t v = (uint32_t) atoi(ptr+strlen(attrs[i].n));
+                  uint32_t v = (uint32_t) strtol(ptr+strlen(attrs[i].n), NULL, 0);
                   if (v > 0) {
                     radius_addattr(radius, &req->radius_res, attrs[i].a, attrs[i].v, attrs[i].va, v, NULL, 0);
 #if(_debug_)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-query.c src/src/main-query.c
--- upstream/src/main-query.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-query.c	2025-07-03 10:02:27.000000000 +0000
@@ -150,6 +150,11 @@
     sizeof(request.d.sess.params.maxoutputoctets),
     &request.d.sess.params.maxoutputoctets,
     "Max output octets (bytes)", 0, 0 },
+  { "warningoctets",
+    CMDSOCK_FIELD_INTEGER,
+    sizeof(request.d.sess.params.warningoctets),
+    &request.d.sess.params.warningoctets,
+    "Data amount over which an SMS warning is sent (bytes)", 0, 0 },
   { "maxbwup",
     CMDSOCK_FIELD_INTEGER,
     sizeof(request.d.sess.params.bandwidthmaxup),
@@ -180,6 +185,11 @@
     &request.d.sess.params.url,
     "Set redirect url",
     &request.d.sess.params.flags, REQUIRE_REDIRECT },
+  { "userurl",
+    CMDSOCK_FIELD_STRING,
+    sizeof(request.d.sess.userurl),
+    &request.d.sess.userurl,
+    "Set URL requested by user", 0, 0 },
 #ifdef ENABLE_MULTIROUTE
   { "routeidx",
     CMDSOCK_FIELD_INTEGER,
@@ -323,16 +333,16 @@
           case CMDSOCK_FIELD_INTEGER:
             switch(args[i].length) {
               case 1:
-                *((uint8_t *)args[i].field) |= (uint8_t)atoi(argv[argidx+1]);
+                *((uint8_t *)args[i].field) |= (uint8_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 2:
-                *((uint16_t *)args[i].field) |= (uint16_t)atoi(argv[argidx+1]);
+                *((uint16_t *)args[i].field) |= (uint16_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 4:
-                *((uint32_t *)args[i].field) |= (uint32_t)atol(argv[argidx+1]);
+                *((uint32_t *)args[i].field) |= (uint32_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 8:
-                *((uint64_t *)args[i].field) |= (uint64_t)atol(argv[argidx+1]);
+                *((uint64_t *)args[i].field) |= (uint64_t)strtol(argv[argidx+1], NULL, 0);
                 break;
             }
             break;
@@ -425,7 +435,7 @@
   int query_timeout = QUERY_TIMEOUT;
 
   if ((query_timeout_env = getenv("QUERY_TIMEOUT"))) {
-    query_timeout = atoi(query_timeout_env);
+    query_timeout = strtol(query_timeout_env, NULL, 0);
   }
 
   set_signal(SIGALRM, timeout_alarm);
@@ -459,7 +469,7 @@
     } else if (!strcmp(argv[argidx], "-p")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      peerid = atoi(argv[argidx++]);
+      peerid = strtol(argv[argidx++], NULL, 0);
 #endif
     } else if (!strcmp(argv[argidx], "-json")) {
       request.options |= CMDSOCK_OPT_JSON;
@@ -467,7 +477,7 @@
     } else if (!strcmp(argv[argidx], "-P")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      cmdsockport = atoi(argv[argidx++]);
+      cmdsockport = strtol(argv[argidx++], NULL, 0);
     }
   }
 
@@ -548,7 +558,7 @@
               request.mac[i] = temp[i];
 
             argidx++;
-            request.d.sess.params.routeidx = atoi(argv[argidx]);
+            request.d.sess.params.routeidx = strtol(argv[argidx], NULL, 0);
 
             if (request.type != CMDSOCK_ROUTE_GW)
               request.type = CMDSOCK_ROUTE_SET;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-redir.c src/src/main-redir.c
--- upstream/src/main-redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-redir.c	2025-07-03 10:02:27.000000000 +0000
@@ -396,7 +396,7 @@
 	    if (!strncasecmp(hdr, "content-length:", 15)) {
 	      char c = hdr[l];
 	      hdr[l] = 0;
-	      clen = req->clen = atoi(hdr+15);
+	      clen = req->clen = strtol(hdr+15, NULL, 0);
 	      syslog(LOG_DEBUG, "Detected Content Length %d", req->clen);
 	      hdr[l] = c;
 	    } else if (!strncasecmp(hdr, "content-type:", 13)) {
@@ -676,7 +676,7 @@
 
     if ((p = strchr(httpreq->host, ':'))) {
       *p++ = 0;
-      port = atoi(p);
+      port = strtol(p, NULL, 0);
     }
 
     if (conn_setup(&req->conn, httpreq->host, port,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-response.c src/src/main-response.c
--- upstream/src/main-response.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-response.c	2025-07-03 10:02:27.000000000 +0000
@@ -97,7 +97,7 @@
     return usage(argv[0]);
 
   if (argc == 5)
-    chap_ident = atoi(argv[idx+4]);
+    chap_ident = strtol(argv[idx+4], NULL, 0);
 
   /* challenge - argv 1 */
   if (strlen(argv[idx+1]) >= sizeof(buffer))
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-rtmon.c src/src/main-rtmon.c
--- upstream/src/main-rtmon.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-rtmon.c	2025-07-03 10:02:27.000000000 +0000
@@ -70,7 +70,7 @@
     } else if (strcmp(argv[i], "-file")==0) {
       chilli_conf = argv[i+1];
     } else if (strcmp(argv[i], "-pid")==0) {
-      chilli_pid = atoi(argv[i+1]);
+      chilli_pid = strtol(argv[i+1], NULL, 0);
     }
   }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-script.c src/src/main-script.c
--- upstream/src/main-script.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-script.c	2025-07-03 10:02:27.000000000 +0000
@@ -30,73 +30,104 @@
 #define CHILLI_GROUP "chilli"
 #endif
 
-static void usage(char *prog) {
-  fprintf(stderr,"%s chilli-bin script-path [script-arguments]\n", prog);
-  exit(-1);
+static void usage(char *prog)
+{
+	fprintf(stderr, "%s chilli-bin script-path [script-arguments]\n", prog);
+	exit(-1);
 }
 
-int main(int argc, char **argv) {
-  struct stat statbuf;
-  uid_t uid = getuid();
-  uid_t gid = getgid();
-  uid_t euid = geteuid();
-  uid_t egid = getegid();
-
-  struct passwd * pwd = getpwuid(uid);
-  struct group * grp = getgrgid(gid);
-
-  if (argc < 3)
-    usage(argv[0]);
-
-  options_init();
-
-  openlog(PACKAGE, LOG_PID, LOG_DAEMON);
-
-  memset(&statbuf, 0, sizeof(statbuf));
-
-  if (!options_binload(argv[1])) {
-    syslog(LOG_ERR, "invalid binary config file %s", argv[1]);
-    usage(argv[0]);
-  }
-
-  if (uid != 0) {
-    if (strcmp(pwd->pw_name, CHILLI_USER)) {
-      syslog(LOG_ERR, "has to run as user %s or root", CHILLI_USER);
-      usage(argv[0]);
-    }
-
-    if (strcmp(grp->gr_name, CHILLI_GROUP)) {
-      syslog(LOG_ERR, "has to run as group %s or root", CHILLI_GROUP);
-      usage(argv[0]);
-    }
-  }
-
-  syslog(LOG_DEBUG, "USER %s(%d/%d), GROUP %s(%d/%d) CHILLI[UID %d, GID %d]",
-         pwd->pw_name, uid, euid, grp->gr_name, gid, egid,
-         _options.uid, _options.gid);
-
-  if (stat(argv[2], &statbuf)) {
-    syslog(LOG_ERR, "%s: %s does not exist", strerror(errno), argv[2]);
-    usage(argv[0]);
-  }
-
-  if (_options.uid &&                        /* chilli is running as non-root */
-      _options.uid == euid &&                /* current euid same as chilli uid */
-      _options.gid == egid &&                /* current egid same as chilli gid */
-      statbuf.st_uid == 0 &&                 /* script owned by root */
-      statbuf.st_gid == _options.gid &&      /* script group same as chilli gid */
-      (statbuf.st_mode & 0400) == 0400) {
-
-    if (setuid(0))
-      syslog(LOG_ERR, "%s: setuid %s", strerror(errno), argv[0]);
-  }
-
-  syslog(LOG_INFO, "Running %s (%d/%d)", argv[2], getuid(), geteuid());
-
-  if (execv(argv[2], &argv[2])) {
-    syslog(LOG_ERR, "%s: exec %s", strerror(errno), argv[2]);
-    usage(argv[0]);
-  }
+int main(int argc, char **argv)
+{
+	struct stat statbuf;
+	uid_t uid  = getuid();
+	uid_t gid  = getgid();
+	uid_t euid = geteuid();
+	uid_t egid = getegid();
+
+	struct passwd *pwd = getpwuid(uid);
+	struct group *grp  = getgrgid(gid);
+
+	struct passwd *chilli_pwd = getpwnam(CHILLI_USER);
+	struct group *chilli_grp  = getgrnam(CHILLI_GROUP);
+
+	if (isatty(STDIN_FILENO) || argc < 3 || !chilli_pwd || !chilli_grp)
+		usage(argv[0]);
+
+	uid_t chilli_uid = chilli_pwd->pw_uid;
+	gid_t chilli_gid = chilli_grp->gr_gid;
+
+	options_init();
+
+	openlog(PACKAGE, LOG_PID, LOG_DAEMON);
+
+	memset(&statbuf, 0, sizeof(statbuf));
+
+	if (!options_binload(argv[1])) {
+		syslog(LOG_ERR, "invalid binary config file %s", argv[1]);
+		usage(argv[0]);
+	}
+
+	if (strstr(argv[2], "..") || argv[2][0] != '/') {
+		if (_options.debug)
+			syslog(LOG_ERR, "script path %s is not absolute", argv[2]);
+		usage(argv[0]);
+	}
+
+	char resolved_path[PATH_MAX];
+	if (realpath(argv[2], resolved_path) == NULL) {
+		if (_options.debug)
+			syslog(LOG_ERR, "%s: %s", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
+
+	if (strncmp(resolved_path, "/etc/chilli/", 12) != 0 &&
+	    strncmp(resolved_path, "/tmp/run/chilli/", 16) != 0) {
+		if (_options.debug)
+			syslog(LOG_ERR, "script path %s is not valid", resolved_path);
+		usage(argv[0]);
+	}
+
+	if (uid != 0) {
+		if (strcmp(pwd->pw_name, CHILLI_USER)) {
+			if (_options.debug)
+				syslog(LOG_ERR, "has to run as user %s or root", CHILLI_USER);
+			usage(argv[0]);
+		}
+
+		if (strcmp(grp->gr_name, CHILLI_GROUP)) {
+			if (_options.debug)
+				syslog(LOG_ERR, "has to run as group %s or root", CHILLI_GROUP);
+			usage(argv[0]);
+		}
+	}
+
+	if (_options.debug) {
+		syslog(LOG_DEBUG, "USER %s(%d/%d), GROUP %s(%d/%d) CHILLI[UID %d, GID %d]", pwd->pw_name, uid,
+		       euid, grp->gr_name, gid, egid, chilli_uid, chilli_gid);
+	}
+
+	if (stat(argv[2], &statbuf)) {
+		if (_options.debug)
+			syslog(LOG_ERR, "%s: %s does not exist", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
+
+	if (chilli_uid && /* chilli user exists */
+	    statbuf.st_uid == 0 && /* script owned by root */
+	    statbuf.st_gid == chilli_gid && /* script group same as chilli gid */
+	    (statbuf.st_mode & 0400) == 0400) {
+		if (setuid(0))
+			syslog(LOG_ERR, "%s: setuid %s", strerror(errno), argv[0]);
+	} else {
+		usage(argv[0]);
+	}
+
+	syslog(LOG_INFO, "Running %s (%d/%d)", argv[2], getuid(), geteuid());
+
+	if (execv(argv[2], &argv[2])) {
+		syslog(LOG_ERR, "%s: exec %s", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
 
-  return 0;
+	return 0;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main.c src/src/main.c
--- upstream/src/main.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main.c	2025-07-03 10:02:27.000000000 +0000
@@ -83,14 +83,14 @@
 
 #if defined(__linux__)
   if ((ev = getenv("CHILLI_PRIORITY")) != NULL) {
-    if (setpriority(PRIO_PROCESS, getpid(), atoi(ev))) {
+    if (setpriority(PRIO_PROCESS, getpid(), strtol(ev, NULL, 0))) {
       perror("setpriority");
     }
   }
 
 #ifdef __NR_ioprio_set
   if ((ev = getenv("CHILLI_IOPRIO_RT")) != NULL) {
-    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), atoi(ev) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
+    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), strtol(ev, NULL, 0) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
       perror("ioprio_set");
     }
   }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/md5.h src/src/md5.h
--- upstream/src/md5.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/md5.h	2025-07-03 10:02:27.000000000 +0000
@@ -22,11 +22,22 @@
 #include "system.h"
 
 #if HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#include <openssl/evp.h>
+#else
 #include <openssl/md5.h>
+#endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#define MD5_CTX EVP_MD_CTX*
+#define MD5Init(context) do { *(context) = EVP_MD_CTX_new(); EVP_DigestInit_ex(*(context), EVP_md5(), NULL); } while(0)
+#define MD5Update(context, data, length) EVP_DigestUpdate(*(context), data, length)
+#define MD5Final(output, context) do { EVP_DigestFinal(*(context), output, NULL); EVP_MD_CTX_free(*(context)); } while(0)
+#else
 #define MD5Init MD5_Init
 #define MD5Update MD5_Update
 #define MD5Final MD5_Final
+#endif
 
 #elif HAVE_CYASSL
 #include <cyassl/openssl/md5.h>
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ms_chap.c src/src/ms_chap.c
--- upstream/src/ms_chap.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ms_chap.c	2025-07-03 10:02:27.000000000 +0000
@@ -41,6 +41,10 @@
 #include <openssl/md4.h>
 #include <openssl/md5.h>
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#include <openssl/evp.h>
+#endif
+
 /*
  * Documentation & specifications:
  *
@@ -69,6 +73,29 @@
   u_char UseNT;	/* If 1, ignore the LANMan response field */
 };
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+static void /* IN 8 octets IN 7 octets OUT 8 octets */
+DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
+{
+  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
+  const EVP_CIPHER *cipher_type = EVP_des_ecb();
+  int len;
+
+  if (!ctx) {
+    return;
+  }
+
+  if (!EVP_EncryptInit_ex(ctx, cipher_type, NULL, key, NULL) ||
+      !EVP_EncryptUpdate(ctx, cipher, &len, clear, 8) ||
+      !EVP_EncryptFinal_ex(ctx, cipher + len, &len))
+  {
+    EVP_CIPHER_CTX_free(ctx);
+    return;
+  }
+
+  EVP_CIPHER_CTX_free(ctx);
+}
+#else
 static u_char
 Get7Bits(u_char *input, int startBit)
 {
@@ -96,22 +123,30 @@
   des_key[6] = Get7Bits(key, 42);
   des_key[7] = Get7Bits(key, 49);
 
-  des_set_odd_parity((des_cblock *)des_key);
+  DES_set_odd_parity((DES_cblock *)des_key);
 }
 
 static void /* IN 8 octets IN 7 octest OUT 8 octets */
 DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
 {
-  des_cblock		des_key;
-  des_key_schedule	key_schedule;
+	DES_cblock des_key;
+	DES_key_schedule key_schedule;
 
-  MakeKey(key, des_key);
-  des_set_key(&des_key, key_schedule);
-  des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, key_schedule, 1);
+	MakeKey(key, des_key);
+	DES_set_key(&des_key, &key_schedule);
+	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
+			&key_schedule, 1);
 }
+#endif
 
 #define LENGTH 20
-static u_char *SHA1_End(SHA_CTX *ctx, u_char *buf)
+static u_char *SHA1_End(
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx,
+#else
+  SHA_CTX *ctx,
+#endif
+  u_char *buf)
 {
   int i;
   unsigned char digest[LENGTH];
@@ -123,7 +158,11 @@
   if (!buf)
     return 0;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_DigestFinal(ctx, digest, NULL);
+#else
   SHA1_Final(digest, ctx);
+#endif
 
   for (i = 0; i < LENGTH; i++) {
     buf[i+i] = hex[digest[i] >> 4];
@@ -167,15 +206,22 @@
 {
   if (!Password) return;
   else {
-    MD4_CTX MD4context;
-
     u_char *uniPassword = to_unicode(Password);
 
     len *= 2;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+    EVP_DigestInit(ctx, EVP_md4());
+    EVP_DigestUpdate(ctx, uniPassword, len);
+    EVP_DigestFinal(ctx, hash, NULL);
+    EVP_MD_CTX_free(ctx);
+#else
+    MD4_CTX MD4context;
     MD4_Init(&MD4context);
     MD4_Update(&MD4context, uniPassword, len);
     MD4_Final(hash, &MD4context);
+#endif
 
     free(uniPassword);
   }
@@ -184,18 +230,24 @@
 void
 HashNtPasswordHash(u_char *hash, u_char *hashhash)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_md4());
+  EVP_DigestUpdate(ctx, hash, 16);
+  EVP_DigestFinal(ctx, hashhash, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
   MD4_CTX MD4context;
-
   MD4_Init(&MD4context);
   MD4_Update(&MD4context, hash, 16);
   MD4_Final(hashhash, &MD4context);
+#endif
 }
 
 void
 ChallengeHash(u_char *PeerChallenge, u_char *AuthenticatorChallenge,
               u_char *UserName, int UserNameLen, u_char *Challenge)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
   u_char *Name;
 
@@ -205,6 +257,16 @@
   else
     Name++;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PeerChallenge, 16);
+  EVP_DigestUpdate(ctx, AuthenticatorChallenge, 16);
+  EVP_DigestUpdate(ctx, Name, strlen((char *)Name));
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
 
   SHA1_Update(&Context, PeerChallenge, 16);
@@ -212,6 +274,7 @@
   SHA1_Update(&Context, Name, strlen((char *)Name));
 
   SHA1_Final(Digest, &Context);
+#endif
   memcpy(Challenge, Digest, 8);
 }
 
@@ -236,7 +299,6 @@
                               u_char *AuthenticatorChallenge, u_char *UserName,
                               int UserNameLen, u_char *AuthenticatorResponse)
 {
-  SHA_CTX Context;
   u_char PasswordHash[16];
   u_char PasswordHashHash[16];
   u_char Challenge[8];
@@ -268,18 +330,37 @@
    */
   HashNtPasswordHash(PasswordHash, PasswordHashHash);
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PasswordHashHash, 16);
+  EVP_DigestUpdate(ctx, NTResponse, 24);
+  EVP_DigestUpdate(ctx, Magic1, 39);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, PasswordHashHash, 16);
   SHA1_Update(&Context, NTResponse, 24);
   SHA1_Update(&Context, Magic1, 39);
   SHA1_Final(Digest, &Context);
+#endif
 
   ChallengeHash(PeerChallenge, AuthenticatorChallenge, UserName, UserNameLen, Challenge);
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, Digest, 20);
+  EVP_DigestUpdate(ctx, Challenge, 8);
+  EVP_DigestUpdate(ctx, Magic2, 41);
+#else
   SHA1_Init(&Context);
   SHA1_Update(&Context, Digest, 20);
   SHA1_Update(&Context, Challenge, 8);
   SHA1_Update(&Context, Magic2, 41);
+#endif
 
   /*
    * Encode the value of 'Digest' as "S=" followed by
@@ -290,7 +371,12 @@
    */
   AuthenticatorResponse[0] = 'S';
   AuthenticatorResponse[1] = '=';
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  SHA1_End(ctx, AuthenticatorResponse + 2);
+  EVP_MD_CTX_free(ctx);
+#else
   SHA1_End(&Context, AuthenticatorResponse + 2);
+#endif
 
   for (i=2; i<42; i++)
     AuthenticatorResponse[i] = toupper(AuthenticatorResponse[i]);
@@ -299,18 +385,28 @@
 void
 GetMasterKey(char *PasswordHashHash, char *NTResponse, char *MasterKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
   static u_char Magic1[27] =
       {0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
        0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
        0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79};
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PasswordHashHash, 16);
+  EVP_DigestUpdate(ctx, NTResponse, 24);
+  EVP_DigestUpdate(ctx, Magic1, 27);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, PasswordHashHash, 16);
   SHA1_Update(&Context, NTResponse, 24);
   SHA1_Update(&Context, Magic1, 27);
   SHA1_Final(Digest, &Context);
+#endif
   memcpy(MasterKey, Digest, 16);
 }
 
@@ -319,7 +415,6 @@
                      int IsSend, int IsServer)
 {
   u_char Digest[SHA_DIGEST_LENGTH];
-  SHA_CTX Context;
   u_char *s;
 
   static u_char Magic2[84] =
@@ -358,12 +453,24 @@
     }
   }
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, MasterKey, 16);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, s, 84);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, MasterKey, 16);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, s, 84);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(SessionKey, Digest, SessionKeyLength);
 }
@@ -372,15 +479,26 @@
 GetNewKeyFromSHA(char *StartKey, char *SessionKey, long SessionKeyLength,
                  char *InterimKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, StartKey, SessionKeyLength);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, SessionKey, SessionKeyLength);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, StartKey, SessionKeyLength);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, SessionKey, SessionKeyLength);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(InterimKey, Digest, SessionKeyLength);
 }
@@ -390,15 +508,26 @@
 Get_Key(char *InitialSessionKey, char *CurrentSessionKey,
         int LengthOfDesiredKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, InitialSessionKey, LengthOfDesiredKey);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, CurrentSessionKey, LengthOfDesiredKey);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, InitialSessionKey, LengthOfDesiredKey);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, CurrentSessionKey, LengthOfDesiredKey);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(CurrentSessionKey, Digest, LengthOfDesiredKey);
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/mssl/httpsClient.c src/src/mssl/httpsClient.c
--- upstream/src/mssl/httpsClient.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/mssl/httpsClient.c	2025-07-03 10:02:27.000000000 +0000
@@ -156,7 +156,7 @@
 	  err_exit("Out of memory");
 	break;
       case 'p':
-	if(!(port=atoi(optarg)))
+	if(!(port=strtol(optarg, NULL, 0)))
 	  err_exit("Bogus port specified");
 	break;
       case 's':
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/net.c src/src/net.c
--- upstream/src/net.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.c	2025-07-03 10:02:27.000000000 +0000
@@ -939,7 +939,8 @@
   if (len < 0) {
     switch (errno) {
       case EWOULDBLOCK:
-        syslog(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
+        if (_options.debug)
+          syslog(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
         break;
 
 #ifdef ENETDOWN
@@ -960,7 +961,9 @@
 #endif
     }
 
-    syslog(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+    if (_options.debug)
+      syslog(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+
     return -1;
   }
 
@@ -1082,9 +1085,6 @@
   close(fd);
   return 0;
 
-#elif defined(__sun__)
-  syslog(LOG_ERR, "%s: Could not set up routing on Solaris. Please add route manually.", strerror(errno));
-  return 0;
 #else
 #error  "Unknown platform!"
 #endif
@@ -1263,11 +1263,6 @@
     ndelay_on(netif->fd);
     coe(netif->fd);
 
-    option = 1;
-    if (net_setsockopt(netif->fd, SOL_SOCKET, TCP_NODELAY,
-		       &option, sizeof(option)) < 0)
-      return -1;
-
     /* Enable reception and transmission of broadcast frames */
     option = 1;
     if (net_setsockopt(netif->fd, SOL_SOCKET, SO_BROADCAST,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/net.h src/src/net.h
--- upstream/src/net.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.h	2025-07-03 10:02:27.000000000 +0000
@@ -177,6 +177,7 @@
   struct pollfd pfds[MAX_SELECT];
 #endif
 #else
+  char padding[2]; // add padding to separate src and prot
   int maxfd;
   fd_set rfds, wfds, efds;
   struct timeval idleTime;
@@ -191,6 +192,7 @@
   uint8_t hwtype;
   uint8_t hwaddr[PKT_ETH_ALEN];
   char devname[IFNAMSIZ+1];
+  char padding[2]; // add padding to separate src and prot
   int devflags;
   int ifindex;
   int mtu;
@@ -251,6 +253,7 @@
   nat_t *nat;
 #endif
 
+  char padding2[2]; // add padding to separate src and prot
   select_ctx *sctx;
 
   uint8_t flags;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oauth2.c src/src/oauth2.c
--- upstream/src/oauth2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/oauth2.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,828 @@
+#include <inttypes.h>
+#include "chilli.h"
+#include <curl/curl.h>
+#include <json-c/json.h>
+#include <openssl/rsa.h>
+#include <openssl/sha.h>
+#include <openssl/bn.h>
+#include <openssl/evp.h>
+#include <openssl/core_names.h>
+#include <openssl/param_build.h>
+
+static int base64url_decode(const char *src, unsigned char *dest, size_t dest_len)
+{
+	size_t len	    = strlen(src);
+	size_t max_temp_len = len + 3;
+	char *temp	    = calloc(max_temp_len + 1, sizeof(char));
+	strncpy(temp, src, max_temp_len);
+
+	for (size_t i = 0; i < len; i++) {
+		if (temp[i] == '-') {
+			temp[i] = '+';
+		} else if (temp[i] == '_') {
+			temp[i] = '/';
+		}
+	}
+
+	size_t padding_len = 4 - (len % 4);
+	if (padding_len < 4) {
+		memset(temp + len, '=', padding_len);
+		len += padding_len;
+	}
+	temp[len] = '\0';
+
+	int ret = b64_decode(temp, dest, dest_len);
+	free(temp);
+	return ret;
+}
+
+static size_t write_callback(void *contents, size_t size, size_t nmemb, void *resp)
+{
+	size_t realsize		  = size * nmemb;
+	struct memory_struct *mem = (struct memory_struct *)resp;
+
+	size_t new_size = mem->size + realsize + 1;
+	mem->memory	= realloc(mem->memory, new_size + 1024);
+	if (mem->memory == NULL) {
+		free(mem->memory);
+		return OAUTH2_OK;
+	}
+
+	memcpy(&(mem->memory[mem->size]), contents, realsize);
+	mem->size += realsize;
+	mem->memory[mem->size] = 0;
+
+	return realsize;
+}
+
+static int oauth2_get_jwk_by_kid(_oauth2_session *session, const char *kid)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->jwks_uri;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	if (res != CURLE_OK) {
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+
+	struct json_object *root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	struct json_object *keys_obj;
+	if (!json_object_object_get_ex(root_obj, "keys", &keys_obj)) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	int keys_len		    = json_object_array_length(keys_obj);
+	struct json_object *key_obj = NULL;
+	const char *key_kid	    = NULL;
+	struct json_object *n_obj   = NULL;
+	struct json_object *e_obj   = NULL;
+
+	for (int i = 0; i < keys_len; i++) {
+		key_obj = json_object_array_get_idx(keys_obj, i);
+		if (json_object_object_get_ex(key_obj, "kid", &n_obj))
+			key_kid = json_object_get_string(n_obj);
+
+		if (key_kid != NULL && !strcmp(kid, key_kid))
+			break;
+
+		key_obj = NULL;
+		key_kid = NULL;
+	}
+
+	if (key_obj != NULL && json_object_object_get_ex(key_obj, "n", &n_obj) &&
+	    json_object_object_get_ex(key_obj, "e", &e_obj)) {
+		const char *n_value = json_object_get_string(n_obj);
+		const char *e_value = json_object_get_string(e_obj);
+
+		session->jwks_n = strdup(n_value);
+		session->jwks_e = strdup(e_value);
+
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_OK;
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+	return OAUTH2_ERR;
+}
+
+static int verify_jwt_alg_rs(const EVP_MD *sha_alg, _oauth2_session *session, char *header, char *payload,
+			     unsigned char *decoded_signature, int decoded_signature_len)
+{
+	OSSL_PARAM_BLD *bld;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY *pkey	   = NULL;
+
+	unsigned char decoded_n[4096];
+	int n_len = base64url_decode(session->jwks_n, decoded_n, sizeof(decoded_n));
+
+	unsigned char decoded_e[4096];
+	int e_len = base64url_decode(session->jwks_e, decoded_e, sizeof(decoded_e));
+
+	BIGNUM *bn_n = BN_bin2bn(decoded_n, n_len, NULL);
+	BIGNUM *bn_e = BN_bin2bn(decoded_e, e_len, NULL);
+	if (!bn_n || !bn_e) {
+		BN_free(bn_n);
+		BN_free(bn_e);
+		return OAUTH2_ERR;
+	}
+
+	bld = OSSL_PARAM_BLD_new();
+	if (bld && OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_RSA_N, bn_n) &&
+	    OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_RSA_E, bn_e)) {
+		params = OSSL_PARAM_BLD_to_param(bld);
+	}
+	OSSL_PARAM_BLD_free(bld);
+	BN_free(bn_n);
+	BN_free(bn_e);
+
+	EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL);
+	if (!params || !ctx || EVP_PKEY_fromdata_init(ctx) <= 0 ||
+	    EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		EVP_PKEY_CTX_free(ctx);
+		OSSL_PARAM_free(params);
+		return OAUTH2_ERR;
+	}
+
+	EVP_PKEY_CTX_free(ctx);
+	OSSL_PARAM_free(params);
+
+	EVP_MD_CTX *ctx_md = EVP_MD_CTX_new();
+	if (!ctx_md) {
+		EVP_PKEY_free(pkey);
+		return OAUTH2_ERR;
+	}
+
+	if (!EVP_VerifyInit_ex(ctx_md, sha_alg, NULL) || !EVP_VerifyUpdate(ctx_md, header, strlen(header)) ||
+	    !EVP_VerifyUpdate(ctx_md, ".", 1) || !EVP_VerifyUpdate(ctx_md, payload, strlen(payload))) {
+		EVP_MD_CTX_free(ctx_md);
+		EVP_PKEY_free(pkey);
+		return OAUTH2_ERR;
+	}
+
+	int ret = OAUTH2_ERR;
+	if (EVP_VerifyFinal(ctx_md, decoded_signature, decoded_signature_len, pkey) == 1) {
+		ret = OAUTH2_OK;
+	}
+
+	EVP_MD_CTX_free(ctx_md);
+	EVP_PKEY_free(pkey);
+	return ret;
+}
+
+static int verify_jwt_alg(_oauth2_session *session, const char *alg, const char *kid, char *header,
+			  char *payload, unsigned char *decoded_signature, int decoded_signature_len)
+{
+	if (oauth2_get_jwk_by_kid(session, kid) != OAUTH2_OK) {
+		return OAUTH2_ERR;
+	}
+
+	if (alg && !strcmp(alg, "RS256")) {
+		return verify_jwt_alg_rs(EVP_sha256(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	if (alg && !strcmp(alg, "RS384")) {
+		return verify_jwt_alg_rs(EVP_sha384(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	if (alg && !strcmp(alg, "RS512")) {
+		return verify_jwt_alg_rs(EVP_sha512(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	return OAUTH2_ERR;
+}
+
+static int validate_jwt_token(_oauth2_session *session)
+{
+	int ret	     = OAUTH2_ERR;
+	char *header = NULL, *payload = NULL, *signature = NULL;
+	char *token_copy = strdup(session->id_token);
+
+	char *saveptr = NULL;
+	header	      = strtok_r(token_copy, ".", &saveptr);
+	payload	      = strtok_r(NULL, ".", &saveptr);
+	signature     = strtok_r(NULL, ".", &saveptr);
+
+	unsigned char *decoded_header	 = calloc(strlen(header) * 2, sizeof(unsigned char));
+	unsigned char *decoded_payload	 = calloc(strlen(payload) * 2, sizeof(unsigned char));
+	unsigned char *decoded_signature = calloc(strlen(signature) * 2, sizeof(unsigned char));
+	if (!decoded_header || !decoded_payload || !decoded_signature) {
+		goto clean;
+	}
+
+	int decoded_header_len = base64url_decode(header, decoded_header, strlen(header) * 2);
+	if (decoded_header_len < 0) {
+		goto clean;
+	}
+
+	int decoded_payload_len = base64url_decode(payload, decoded_payload, strlen(payload) * 2);
+	if (decoded_payload_len < 0) {
+		goto clean;
+	}
+
+	int decoded_signature_len = base64url_decode(signature, decoded_signature, strlen(signature) * 2);
+	if (decoded_signature_len < 0) {
+		goto clean;
+	}
+
+	json_object *header_json  = json_tokener_parse((const char *)decoded_header);
+	json_object *payload_json = json_tokener_parse((const char *)decoded_payload);
+	if (!header_json || !payload_json) {
+		goto clean;
+	}
+
+	json_object *iss_obj;
+	if (!json_object_object_get_ex(payload_json, "iss", &iss_obj) ||
+	    strcmp(json_object_get_string(iss_obj), session->issuer) != 0) {
+		goto clean;
+	}
+
+	json_object *aud_obj;
+	if (!json_object_object_get_ex(payload_json, "aud", &aud_obj) ||
+	    strcmp(json_object_get_string(aud_obj), session->client_id) != 0) {
+		goto clean;
+	}
+
+	json_object *exp_obj;
+	if (json_object_object_get_ex(payload_json, "exp", &exp_obj)) {
+		time_t current_time = time(NULL);
+		uint64_t exp_time   = json_object_get_int64(exp_obj);
+		if (exp_time < (uint64_t)current_time) {
+			goto clean;
+		}
+	} else {
+		goto clean;
+	}
+
+	json_object *username_obj;
+	if (json_object_object_get_ex(payload_json, "preferred_username", &username_obj)) {
+		const char *username = json_object_get_string(username_obj);
+		if (username && username[0] != '\0') {
+			session->username = strdup(username);
+		}
+	}
+
+	const char *alg = NULL;
+	json_object *alg_obj;
+	if (json_object_object_get_ex(header_json, "alg", &alg_obj)) {
+		alg = json_object_get_string(alg_obj);
+	} else {
+		goto clean;
+	}
+
+	const char *kid = NULL;
+	json_object *kid_obj;
+	if (json_object_object_get_ex(header_json, "kid", &kid_obj)) {
+		kid = json_object_get_string(kid_obj);
+	} else {
+		goto clean;
+	}
+
+	ret = verify_jwt_alg(session, alg, kid, header, payload, decoded_signature, decoded_signature_len);
+
+clean:
+	free(token_copy);
+	free(decoded_header);
+	free(decoded_payload);
+	free(decoded_signature);
+	return ret;
+}
+
+void oauth2_init_session(_oauth2_session *session)
+{
+	session->response_type		= NULL;
+	session->oidc_endpoint		= NULL;
+	session->client_id		= NULL;
+	session->client_secret		= NULL;
+	session->redirect_uri		= NULL;
+	session->scope			= NULL;
+	session->state			= NULL;
+	session->code			= NULL;
+	session->token_endpoint		= NULL;
+	session->authorization_endpoint = NULL;
+	session->userinfo_endpoint	= NULL;
+	session->jwks_uri		= NULL;
+	session->authorization_url	= NULL;
+	session->id_token		= NULL;
+	session->access_token		= NULL;
+	session->username		= NULL;
+	session->issuer			= NULL;
+	session->jwks_n			= NULL;
+	session->jwks_e			= NULL;
+	session->token_type		= OAUTH2_TOKEN_UNKNOWN;
+}
+
+static void oauth2_set_str_parameter(_oauth2_session *session, unsigned int option, char *value)
+{
+	switch (option) {
+	case OAUTH2_OPT_OIDC_ENDPOINT:
+		session->oidc_endpoint = strdup(value);
+		break;
+	case OAUTH2_OPT_CLIENT_ID:
+		session->client_id = strdup(value);
+		break;
+	case OAUTH2_OPT_CLIENT_SECRET:
+		session->client_secret = strdup(value);
+		break;
+	case OAUTH2_OPT_REDIRECT_URI:
+		session->redirect_uri = strdup(value);
+		break;
+	case OAUTH2_OPT_SCOPE:
+		session->scope = strdup(value);
+		break;
+	case OAUTH2_OPT_STATE:
+		session->state = strdup(value);
+		break;
+	case OAUTH2_OPT_CODE:
+		session->code = strdup(value);
+		break;
+	default:
+		break;
+	}
+}
+
+static void oauth2_set_int_parameter(_oauth2_session *session, unsigned int option, unsigned int value)
+{
+	switch (option) {
+	case OAUTH2_OPT_RESPONSE_TYPE: {
+		switch (value) {
+		case OAUTH2_RESPONSE_TYPE_CODE:
+			session->response_type = "code";
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+static int oauth2_add_session_tokens(_oauth2_session *session, const char *id_token, const char *access_token,
+				     const char *token_type)
+{
+	int ret = OAUTH2_OK;
+	if (!session->id_token && id_token && id_token[0] != '\0') {
+		session->id_token = strdup(id_token);
+		ret		  = validate_jwt_token(session);
+	}
+
+	if (!session->access_token && access_token && access_token[0] != '\0') {
+		session->access_token = strdup(access_token);
+	}
+
+	if (token_type && !strcmp(token_type, "Bearer")) {
+		session->token_type = OAUTH2_TOKEN_BEARER;
+	} else {
+		session->token_type = OAUTH2_TOKEN_UNKNOWN;
+	}
+
+	return ret;
+}
+
+void oauth2_set_parameter_list(_oauth2_session *session, ...)
+{
+	va_list args;
+	va_start(args, session);
+
+	unsigned int option = 0;
+	while ((option = va_arg(args, unsigned int)) != OAUTH2_OPT_NONE) {
+		switch (option) {
+		case OAUTH2_OPT_OIDC_ENDPOINT:
+		case OAUTH2_OPT_CLIENT_ID:
+		case OAUTH2_OPT_CLIENT_SECRET:
+		case OAUTH2_OPT_REDIRECT_URI:
+		case OAUTH2_OPT_STATE:
+		case OAUTH2_OPT_SCOPE:
+		case OAUTH2_OPT_CODE: {
+			char *value = va_arg(args, char *);
+			oauth2_set_str_parameter(session, option, value);
+			break;
+		}
+		case OAUTH2_OPT_RESPONSE_TYPE: {
+			unsigned int value = va_arg(args, unsigned int);
+			oauth2_set_int_parameter(session, option, value);
+			break;
+		}
+		default:
+			break;
+		}
+	}
+
+	va_end(args);
+}
+
+int oauth2_get_openid_config(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->oidc_endpoint;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	if (session->token_endpoint || session->authorization_endpoint || session->jwks_uri ||
+	    session->userinfo_endpoint) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 openid endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 openid endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+
+	struct json_object *root_obj, *token_endpoint_obj, *authorization_endpoint_obj, *jwks_uri_obj,
+		*userinfo_endpoint_obj, *issuer_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_object_get_ex(root_obj, "token_endpoint", &token_endpoint_obj);
+	json_object_object_get_ex(root_obj, "authorization_endpoint", &authorization_endpoint_obj);
+	json_object_object_get_ex(root_obj, "jwks_uri", &jwks_uri_obj);
+	json_object_object_get_ex(root_obj, "userinfo_endpoint", &userinfo_endpoint_obj);
+	json_object_object_get_ex(root_obj, "issuer", &issuer_obj);
+
+	if (!token_endpoint_obj || !authorization_endpoint_obj || !jwks_uri_obj || !userinfo_endpoint_obj ||
+	    !issuer_obj) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	const char *token_endpoint	   = json_object_get_string(token_endpoint_obj);
+	const char *authorization_endpoint = json_object_get_string(authorization_endpoint_obj);
+	const char *jwks_uri		   = json_object_get_string(jwks_uri_obj);
+	const char *userinfo_endpoint	   = json_object_get_string(userinfo_endpoint_obj);
+	const char *issuer		   = json_object_get_string(issuer_obj);
+
+	if (!token_endpoint || !authorization_endpoint || !jwks_uri || !userinfo_endpoint || !issuer) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	session->token_endpoint		= strdup(token_endpoint);
+	session->authorization_endpoint = strdup(authorization_endpoint);
+	session->jwks_uri		= strdup(jwks_uri);
+	session->userinfo_endpoint	= strdup(userinfo_endpoint);
+	session->issuer			= strdup(issuer);
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	return OAUTH2_OK;
+}
+
+int oauth2_build_authorization_url(_oauth2_session *session)
+{
+	if (!session->authorization_endpoint || !session->client_id || !session->redirect_uri ||
+	    !session->scope || !session->response_type || !session->state) {
+		return OAUTH2_ERR;
+	}
+	if (session->authorization_url) {
+		free(session->authorization_url);
+		session->authorization_url = NULL;
+	}
+
+	int result = asprintf(&session->authorization_url,
+			      "%s?client_id=%s&redirect_uri=%s&scope=%s&response_type=%s&state=%s",
+			      session->authorization_endpoint, session->client_id, session->redirect_uri,
+			      session->scope, session->response_type, session->state);
+	if (result == -1) {
+		return OAUTH2_ERR;
+	}
+
+	return OAUTH2_OK;
+}
+
+int oauth2_exchange_token(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->token_endpoint;
+	struct memory_struct chunk = { 0 };
+	char *post_data = NULL;
+	char *auth_header = NULL;
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	if (!session->code || !session->redirect_uri || !session->client_secret || !session->client_id ||
+	    !session->response_type || (session->response_type && strcmp(session->response_type, "code"))) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	asprintf(&post_data, "grant_type=authorization_code&client_id=%s&client_secret=%s&redirect_uri=%s&code=%s",
+		 session->client_id, session->client_secret, session->redirect_uri, session->code);
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)strlen(post_data));
+
+	asprintf(&auth_header, "%s:%s", session->client_id, session->client_secret);
+	curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
+	curl_easy_setopt(curl, CURLOPT_USERPWD, auth_header);
+
+	struct curl_slist *headers = NULL;
+	headers = curl_slist_append(headers, "Content-Type: application/x-www-form-urlencoded");
+	headers = curl_slist_append(headers, "Accept: application/json");
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+	res = curl_easy_perform(curl);
+	free(post_data);
+	free(auth_header);
+
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 token endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200 && http_code != 201) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 token endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+	curl_slist_free_all(headers);
+
+	struct json_object *root_obj, *access_token_obj, *id_token_obj, *token_type_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_object_get_ex(root_obj, "access_token", &access_token_obj);
+	json_object_object_get_ex(root_obj, "id_token", &id_token_obj);
+	json_object_object_get_ex(root_obj, "token_type", &token_type_obj);
+
+	const char *access_token = access_token_obj ? json_object_get_string(access_token_obj) : NULL;
+	const char *id_token	 = id_token_obj ? json_object_get_string(id_token_obj) : NULL;
+	const char *token_type	 = token_type_obj ? json_object_get_string(token_type_obj) : NULL;
+
+	if (oauth2_add_session_tokens(session, id_token, access_token, token_type) != OAUTH2_OK) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Failed to get session tokens", __FUNCTION__, __LINE__);
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	if (!access_token && !id_token && !token_type) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Failed to get either access_token, id_token or token_type",
+			       __FUNCTION__, __LINE__);
+		return OAUTH2_ERR;
+	}
+
+	return OAUTH2_OK;
+}
+
+int oauth2_get_userinfo(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->userinfo_endpoint;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0' || !session->access_token || session->token_type != OAUTH2_TOKEN_BEARER) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	struct curl_slist *headers = NULL;
+	char *bearer_header;
+	asprintf(&bearer_header, "Authorization: Bearer %s", session->access_token);
+	headers = curl_slist_append(headers, bearer_header);
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	free(bearer_header);
+
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 userinfo endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 userinfo endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+	curl_slist_free_all(headers);
+
+	struct json_object *root_obj, *email_obj, *username_obj, *name_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	// prefered username is in JWT token for Microsoft,
+	// other providers may handle usernames differently
+	if (!session->username) {
+		json_object_object_get_ex(root_obj, "email", &email_obj);
+		json_object_object_get_ex(root_obj, "username", &username_obj);
+		json_object_object_get_ex(root_obj, "name", &name_obj);
+
+		const char *email    = email_obj ? json_object_get_string(email_obj) : NULL;
+		const char *username = username_obj ? json_object_get_string(username_obj) : NULL;
+		const char *name     = name_obj ? json_object_get_string(name_obj) : NULL;
+
+		if (email) {
+			session->username = strdup(email);
+		} else if (username) {
+			session->username = strdup(username);
+		} else if (name) {
+			session->username = strdup(name);
+		}
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	return OAUTH2_OK;
+}
+
+void oauth2_clean_session(_oauth2_session *session)
+{
+	if (session->oidc_endpoint != NULL) {
+		free(session->oidc_endpoint);
+	}
+	if (session->client_id != NULL) {
+		free(session->client_id);
+	}
+	if (session->client_secret != NULL) {
+		free(session->client_secret);
+	}
+	if (session->redirect_uri != NULL) {
+		free(session->redirect_uri);
+	}
+	if (session->scope != NULL) {
+		free(session->scope);
+	}
+	if (session->state != NULL) {
+		free(session->state);
+	}
+	if (session->code != NULL) {
+		free(session->code);
+	}
+	if (session->token_endpoint != NULL) {
+		free(session->token_endpoint);
+	}
+	if (session->authorization_endpoint != NULL) {
+		free(session->authorization_endpoint);
+	}
+	if (session->userinfo_endpoint != NULL) {
+		free(session->userinfo_endpoint);
+	}
+	if (session->jwks_uri != NULL) {
+		free(session->jwks_uri);
+	}
+	if (session->authorization_url != NULL) {
+		free(session->authorization_url);
+	}
+	if (session->id_token != NULL) {
+		free(session->id_token);
+	}
+	if (session->access_token != NULL) {
+		free(session->access_token);
+	}
+	if (session->username != NULL) {
+		free(session->username);
+	}
+	if (session->issuer != NULL) {
+		free(session->issuer);
+	}
+	if (session->jwks_n != NULL) {
+		free(session->jwks_n);
+	}
+	if (session->jwks_e != NULL) {
+		free(session->jwks_e);
+	}
+	oauth2_init_session(session);
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oauth2.h src/src/oauth2.h
--- upstream/src/oauth2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/oauth2.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,58 @@
+#ifndef OAUTH2_H
+#define OAUTH2_H
+
+#define OAUTH2_OK 0
+#define OAUTH2_ERR 1
+
+#define OAUTH2_OPT_NONE		 0
+#define OAUTH2_OPT_RESPONSE_TYPE 1
+#define OAUTH2_OPT_OIDC_ENDPOINT 2
+#define OAUTH2_OPT_CLIENT_ID	 3
+#define OAUTH2_OPT_CLIENT_SECRET 4
+#define OAUTH2_OPT_REDIRECT_URI	 5
+#define OAUTH2_OPT_SCOPE	 6
+#define OAUTH2_OPT_STATE	 7
+#define OAUTH2_OPT_CODE		 8
+
+#define OAUTH2_RESPONSE_TYPE_CODE 1
+
+#define OAUTH2_TOKEN_UNKNOWN 0
+#define OAUTH2_TOKEN_BEARER 1
+
+struct memory_struct {
+	char *memory;
+	size_t size;
+};
+
+typedef struct {
+	char *response_type;
+	char *oidc_endpoint;
+	char *token_endpoint;
+	char *authorization_endpoint;
+	char *userinfo_endpoint;
+	char *authorization_url;
+	char *jwks_uri;
+	char *jwks_n;
+	char *jwks_e;
+	char *client_id;
+	char *client_secret;
+	char *redirect_uri;
+	char *scope;
+	char *state;
+	char *code;
+	char *access_token;
+	char *id_token;
+	char *username;
+	char *issuer;
+	unsigned int token_type;
+} _oauth2_session;
+
+void oauth2_init_session(_oauth2_session *session);
+void oauth2_set_parameter_list(_oauth2_session *session, ...);
+int oauth2_get_openid_config(_oauth2_session *session);
+int oauth2_build_authorization_url(_oauth2_session *session);
+int oauth2_exchange_token(_oauth2_session *session);
+int oauth2_get_userinfo(_oauth2_session *session);
+void oauth2_clean_session(_oauth2_session *session);
+
+#endif //OAUTH2_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/options.c src/src/options.c
--- upstream/src/options.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.c	2025-07-03 10:02:27.000000000 +0000
@@ -113,7 +113,8 @@
 
   chilli_binconfig(file, sizeof(file), 0);
 
-  syslog(LOG_DEBUG, "(Re)processing options [%s]", file);
+  if (_options.debug)
+    syslog(LOG_DEBUG, "(Re)processing options [%s]", file);
 
   if ((status = fork()) < 0) {
     syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
@@ -137,7 +138,8 @@
   newargs[i++] = file;
   newargs[i++] = reload ? "-r" : NULL;
 
-  syslog(LOG_DEBUG, "running chilli_opt on %s", file);
+  if (_options.debug)
+    syslog(LOG_DEBUG, "running chilli_opt on %s", file);
 
   if (execv(SBINDIR "/chilli_opt", newargs) != 0) {
     syslog(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
@@ -189,7 +191,8 @@
   if (fd < 0) return 0;
   done_before = 1;
 
-  syslog(LOG_DEBUG, "PID %d rereading binary file %s", getpid(), file);
+  if (_options.debug)
+    syslog(LOG_DEBUG, "PID %d rereading binary file %s", getpid(), file);
   return options_fromfd(fd, bt);
 }
 
@@ -274,6 +277,7 @@
   if (!option_s_l(bt, &o.ipdown)) return 0;
   if (!option_s_l(bt, &o.conup)) return 0;
   if (!option_s_l(bt, &o.condown)) return 0;
+  if (!option_s_l(bt, &o.conrestart)) return 0;
   if (!option_s_l(bt, &o.macup)) return 0;
   if (!option_s_l(bt, &o.macdown)) return 0;
 #ifdef ENABLE_IEEE8021Q
@@ -311,6 +315,12 @@
   if (!option_s_l(bt, &o.macsuffix)) return 0;
   if (!option_s_l(bt, &o.macpasswd)) return 0;
 
+#ifdef USING_CURL
+  if (!option_s_l(bt, &o.oidcdiscoveryurl)) return 0;
+  if (!option_s_l(bt, &o.oidcclientid)) return 0;
+  if (!option_s_l(bt, &o.oidcclientsecret)) return 0;
+#endif
+
   if (!option_s_l(bt, &o.uamsecret)) return 0;
   if (!option_s_l(bt, &o.uamurl)) return 0;
   if (!option_s_l(bt, &o.uamaaaurl)) return 0;
@@ -320,7 +330,6 @@
   if (!option_s_l(bt, &o.wwwdir)) return 0;
   if (!option_s_l(bt, &o.wwwbin)) return 0;
   if (!option_s_l(bt, &o.uamui)) return 0;
-  if (!option_s_l(bt, &o.localusers)) return 0;
 #ifdef HAVE_SSL
   if (!option_s_l(bt, &o.sslkeyfile)) return 0;
   if (!option_s_l(bt, &o.sslkeypass)) return 0;
@@ -371,6 +380,29 @@
       return 0;
   }
 
+  if (!option_s_l(bt, &o.successurlcustom)) return 0;
+  if (!option_s_l(bt, &o.dbpath)) return 0;
+  if (!option_s_l(bt, &o.usersdbpath)) return 0;
+  if (!option_s_l(bt, &o.usersignup)) return 0;
+  if (!option_s_l(bt, &o.macpass)) return 0;
+  if (!option_s_l(bt, &o.paramuamip)) return 0;
+  if (!option_s_l(bt, &o.paramuamport)) return 0;
+  if (!option_s_l(bt, &o.paramcalled)) return 0;
+  if (!option_s_l(bt, &o.parammac)) return 0;
+  if (!option_s_l(bt, &o.paramip)) return 0;
+  if (!option_s_l(bt, &o.paramnasid)) return 0;
+  if (!option_s_l(bt, &o.paramsessionid)) return 0;
+  if (!option_s_l(bt, &o.paramuserurl)) return 0;
+  if (!option_s_l(bt, &o.paramchallenge)) return 0;
+  if (!option_s_l(bt, &o.param1)) return 0;
+  if (!option_s_l(bt, &o.param1value)) return 0;
+  if (!option_s_l(bt, &o.param2)) return 0;
+  if (!option_s_l(bt, &o.param2value)) return 0;
+
+#ifdef ENABLE_GSM
+  if (!option_s_l(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_LOAD
 #include EX_OPTIONS_LOAD
 #endif
@@ -473,6 +505,7 @@
   if (!option_s_s(bt, &o.ipdown)) return 0;
   if (!option_s_s(bt, &o.conup)) return 0;
   if (!option_s_s(bt, &o.condown)) return 0;
+  if (!option_s_s(bt, &o.conrestart)) return 0;
   if (!option_s_s(bt, &o.macup)) return 0;
   if (!option_s_s(bt, &o.macdown)) return 0;
 #ifdef ENABLE_IEEE8021Q
@@ -511,6 +544,12 @@
   if (!option_s_s(bt, &o.macsuffix)) return 0;
   if (!option_s_s(bt, &o.macpasswd)) return 0;
 
+#ifdef USING_CURL
+  if (!option_s_s(bt, &o.oidcdiscoveryurl)) return 0;
+  if (!option_s_s(bt, &o.oidcclientid)) return 0;
+  if (!option_s_s(bt, &o.oidcclientsecret)) return 0;
+#endif
+
   if (!option_s_s(bt, &o.uamsecret)) return 0;
   if (!option_s_s(bt, &o.uamurl)) return 0;
   if (!option_s_s(bt, &o.uamaaaurl)) return 0;
@@ -520,7 +559,6 @@
   if (!option_s_s(bt, &o.wwwdir)) return 0;
   if (!option_s_s(bt, &o.wwwbin)) return 0;
   if (!option_s_s(bt, &o.uamui)) return 0;
-  if (!option_s_s(bt, &o.localusers)) return 0;
 #ifdef HAVE_SSL
   if (!option_s_s(bt, &o.sslkeyfile)) return 0;
   if (!option_s_s(bt, &o.sslkeypass)) return 0;
@@ -571,6 +609,28 @@
       return 0;
   }
 
+  if (!option_s_s(bt, &o.successurlcustom)) return 0;
+  if (!option_s_s(bt, &o.dbpath)) return 0;
+  if (!option_s_s(bt, &o.usersdbpath)) return 0;
+  if (!option_s_s(bt, &o.usersignup)) return 0;
+  if (!option_s_s(bt, &o.macpass)) return 0;
+  if (!option_s_s(bt, &o.paramuamip)) return 0;
+  if (!option_s_s(bt, &o.paramuamport)) return 0;
+  if (!option_s_s(bt, &o.paramcalled)) return 0;
+  if (!option_s_s(bt, &o.parammac)) return 0;
+  if (!option_s_s(bt, &o.paramip)) return 0;
+  if (!option_s_s(bt, &o.paramnasid)) return 0;
+  if (!option_s_s(bt, &o.paramsessionid)) return 0;
+  if (!option_s_s(bt, &o.paramuserurl)) return 0;
+  if (!option_s_s(bt, &o.paramchallenge)) return 0;
+  if (!option_s_s(bt, &o.param1)) return 0;
+  if (!option_s_s(bt, &o.param1value)) return 0;
+  if (!option_s_s(bt, &o.param2)) return 0;
+  if (!option_s_s(bt, &o.param2value)) return 0;
+#ifdef ENABLE_GSM
+  if (!option_s_s(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_SAVE
 #include EX_OPTIONS_SAVE
 #endif
@@ -661,7 +721,8 @@
 int reload_options(int argc, char **argv) {
   bstring bt = bfromcstr("");
   int ok = options_load(argc, argv, bt);
-  syslog(LOG_DEBUG, "PID %d reloaded binary options file", getpid());
+  if (_options.debug)
+    syslog(LOG_DEBUG, "PID %d reloaded binary options file", getpid());
   bdestroy(bt);
   return ok;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/options.h src/src/options.h
--- upstream/src/options.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.h	2025-07-03 10:02:27.000000000 +0000
@@ -63,6 +63,7 @@
   char * ipdown;                 /* Script to run after link-down */
   char * conup;                  /* Script to run after session/connection-up */
   char * condown;                /* Script to run after session/connection-down */
+  char * conrestart;             /* Script to run after session info changed */
   char * macup;
   char * macdown;
   int txqlen;
@@ -188,7 +189,10 @@
   uint16_t forcedns2_port;        /* Port to force DNS to */
 #endif
 
+
+
   /* booleans */
+  uint8_t radiusrequiremessageauth:1; /* Radius packets must have valid Message-Authenticator  */
   uint8_t layer3;                   /* Layer3 only support */
   uint8_t allowdyn:1;               /* Allow dynamic address allocation */
   uint8_t allowstat:1;              /* Allow static address allocation */
@@ -240,6 +244,10 @@
   uint8_t uamauthedallowed:1;
   uint8_t postauth_proxyssl:1;
   uint8_t nochallenge:1;
+  uint8_t successuserurl:1;         /* Do not return to the UAM server on success, original url instead */
+  uint8_t maclower:1;
+
+  uint16_t macdelimiter;
 
 #ifdef USING_MMAP
   uint8_t mmapring:1;
@@ -338,6 +346,36 @@
   uint64_t defbandwidthmaxup;
   uint32_t defidletimeout;
   uint16_t definteriminterval;
+  uint64_t defmaxdownload;
+  uint64_t defmaxupload;
+  uint64_t defwarning;
+  uint16_t deflimitperiod;
+  uint16_t deflimitstart;
+  uint64_t defexpirationtime;
+
+  uint64_t dynsessiontimeout;
+  uint64_t dynbandwidthmaxdown;
+  uint64_t dynbandwidthmaxup;
+  uint32_t dynidletimeout;
+  uint16_t dyninteriminterval;
+  uint64_t dynmaxdownload;
+  uint64_t dynmaxupload;
+  uint64_t dynwarning;
+  uint16_t dynlimitperiod;
+  uint16_t dynlimitstart;
+  uint64_t dynexpirationtime;
+
+    uint64_t trialsessiontimeout;
+    uint64_t trialbandwidthmaxdown;
+    uint64_t trialbandwidthmaxup;
+    uint32_t trialidletimeout;
+    uint16_t trialinteriminterval;
+    uint64_t trialmaxdownload;
+    uint64_t trialmaxupload;
+    uint64_t trialwarning;
+    uint16_t triallimitperiod;
+    uint16_t triallimitstart;
+    uint64_t trialexpirationtime;
 
   uint32_t challengetimeout;
   uint32_t challengetimeout2;
@@ -363,7 +401,16 @@
   char *wwwdir;
   char *wwwbin;
   char *uamui;
-  char *localusers;
+  uint8_t localusers:1;
+
+#ifdef USING_CURL
+  /* OIDC configuration */
+  uint8_t oidc:1;
+  uint8_t oidcforcehttps:1;
+  char* oidcdiscoveryurl;
+  char* oidcclientid;
+  char* oidcclientsecret;
+#endif
 
   /* Admin RADIUS Authentication & Configuration */
   char *adminuser;
@@ -388,6 +435,7 @@
 
 #ifdef ENABLE_UAMDOMAINFILE
   char *uamdomainfile;
+  uint8_t uamblocklist:1;
 #endif
 
   /* Command-Socket */
@@ -426,6 +474,37 @@
   char *moddir;
 #endif
 
+  char *successurlcustom;
+  char *dbpath;
+  char *usersdbpath;
+  char * usersignup;                /* Script to run after user has been created */
+  char * macpass;
+#ifdef ENABLE_GSM
+  char *modemid;
+#endif
+  uint8_t smsusers:1;
+  uint8_t macusers:1;
+  uint8_t trialusers:1;
+  uint8_t registerusers:1;
+  uint8_t tos:1;
+  uint8_t duplicateusers:1;
+
+  char *paramuamip;
+  char *paramuamport;
+  char *paramcalled;
+  char *parammac;
+  char *paramip;
+  char *paramnasid;
+  char *paramsessionid;
+  char *paramuserurl;
+  char *paramchallenge;
+  char *param1;
+  char *param1value;
+  char *param2;
+  char *param2value;
+
+  uint8_t testtime:1;
+
   char * _data; /* actual data buffer for loaded options */
 };
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_md5crypt.c src/src/passwd_md5crypt.c
--- upstream/src/passwd_md5crypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,293 @@
+#include "chilli.h"
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+
+#define MD5_CTX MD5_CTX_OpenSSL
+#include <openssl/md5.h>
+#undef MD5_CTX
+
+static unsigned const char cov_2char[64] = {
+	/* from crypto/des/fcrypt.c */
+	0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+	0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
+	0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
+	0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
+	0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
+	0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 1 && *src; size--) {
+		*dst++ = *src++;
+		l++;
+	}
+	if (size)
+		*dst = CH_ZERO;
+	return l + strlen(src);
+}
+
+size_t OPENSSL_strlcat(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 0 && *dst; size--, dst++)
+		l++;
+	return l + OPENSSL_strlcpy(dst, src, size);
+}
+
+/*
+ * MD5-based password algorithm (should probably be available as a library
+ * function; then the static buffer would not be acceptable). For magic
+ * string "1", this should be compatible to the MD5-based BSD password
+ * algorithm. For 'magic' string "apr1", this is compatible to the MD5-based
+ * Apache password algorithm. (Apparently, the Apache password algorithm is
+ * identical except that the 'magic' string was changed -- the laziest
+ * application of the NIH principle I've ever encountered.)
+ */
+char *md5crypt(const char *passwd, const char *magic, const char *salt)
+{
+	/* "$apr1$..salt..$.......md5hash..........\0" */
+	static char out_buf[6 + 9 + 24 + 2];
+	unsigned char buf[MD5_DIGEST_LENGTH];
+	char ascii_magic[5]; /* "apr1" plus '\0' */
+	char ascii_salt[9]; /* Max 8 chars plus '\0' */
+	char *ascii_passwd = NULL;
+	char *salt_out;
+	int n;
+	unsigned int i;
+	EVP_MD_CTX *md = NULL, *md2 = NULL;
+	size_t passwd_len, salt_len, magic_len;
+
+	passwd_len = strlen(passwd);
+
+	out_buf[0] = 0;
+	magic_len  = strlen(magic);
+	OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+	if ((magic[0] & 0x80) != 0) /* High bit is 1 in EBCDIC alnums */
+		ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+	/* The salt gets truncated to 8 chars */
+	OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+	salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+	ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+	ascii_passwd = OPENSSL_strdup(passwd);
+	if (ascii_passwd == NULL)
+		return NULL;
+	ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+	passwd = ascii_passwd;
+#endif
+
+	if (magic_len > 0) {
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+
+		if (magic_len > 4) /* assert it's  "1" or "apr1" */
+			goto err;
+
+		OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+	}
+
+	OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+	if (strlen(out_buf) > 6 + 8) /* assert "$apr1$..salt.." */
+		goto err;
+
+	salt_out = out_buf;
+	if (magic_len > 0)
+		salt_out += 2 + magic_len;
+
+	if (salt_len > 8)
+		goto err;
+
+	md = EVP_MD_CTX_new();
+	if (md == NULL || !EVP_DigestInit_ex(md, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md, passwd, passwd_len))
+		goto err;
+
+	if (magic_len > 0)
+		if (!EVP_DigestUpdate(md, ascii_dollar, 1) ||
+		    !EVP_DigestUpdate(md, ascii_magic, magic_len) ||
+		    !EVP_DigestUpdate(md, ascii_dollar, 1))
+			goto err;
+
+	if (!EVP_DigestUpdate(md, ascii_salt, salt_len))
+		goto err;
+
+	md2 = EVP_MD_CTX_new();
+	if (md2 == NULL || !EVP_DigestInit_ex(md2, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestUpdate(md2, ascii_salt, salt_len) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestFinal_ex(md2, buf, NULL))
+		goto err;
+
+	for (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {
+		if (!EVP_DigestUpdate(md, buf, sizeof(buf)))
+			goto err;
+	}
+	if (!EVP_DigestUpdate(md, buf, i))
+		goto err;
+
+	n = passwd_len;
+	while (n) {
+		if (!EVP_DigestUpdate(md, (n & 1) ? "\0" : passwd, 1))
+			goto err;
+		n >>= 1;
+	}
+	if (!EVP_DigestFinal_ex(md, buf, NULL))
+		return NULL;
+
+	for (i = 0; i < 1000; i++) {
+		if (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))
+			goto err;
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? (unsigned const char *)passwd : buf,
+			    (i & 1) ? passwd_len : sizeof(buf)))
+			goto err;
+		if (i % 3) {
+			if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+				goto err;
+		}
+		if (i % 7) {
+			if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+				goto err;
+		}
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? buf : (unsigned const char *)passwd,
+			    (i & 1) ? sizeof(buf) : passwd_len))
+			goto err;
+		if (!EVP_DigestFinal_ex(md2, buf, NULL))
+			goto err;
+	}
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	md2 = NULL;
+	md  = NULL;
+
+	{
+		/* transform buf into output string */
+		unsigned char buf_perm[sizeof(buf)];
+		int dest, source;
+		char *output;
+
+		/* silly output permutation */
+		for (dest = 0, source = 0; dest < 14;
+		     dest++, source   = (source + 6) % 17)
+			  buf_perm[dest] = buf[source];
+		buf_perm[14] = buf[5];
+		buf_perm[15] = buf[11];
+#ifndef PEDANTIC /* Unfortunately, this generates a "no \
+                  * effect" warning */
+		assert(16 == sizeof(buf_perm));
+#endif
+
+		output = salt_out + salt_len;
+		// assert(output == out_buf + strlen(out_buf));
+		if (output != out_buf + strlen(out_buf))
+			return NULL;
+
+		*output++ = ascii_dollar[0];
+
+		for (i = 0; i < 15; i += 3) {
+			*output++ = cov_2char[buf_perm[i + 2] & 0x3f];
+			*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |
+					      (buf_perm[i + 2] >> 6)];
+			*output++ = cov_2char[((buf_perm[i] & 3) << 4) |
+					      (buf_perm[i + 1] >> 4)];
+			*output++ = cov_2char[buf_perm[i] >> 2];
+		}
+		assert(i == 15);
+		*output++ = cov_2char[buf_perm[i] & 0x3f];
+		*output++ = cov_2char[buf_perm[i] >> 6];
+		*output	  = 0;
+		assert(strlen(out_buf) < sizeof(out_buf));
+#ifdef CHARSET_EBCDIC
+		ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+	}
+
+	return out_buf;
+
+err:
+	OPENSSL_free(ascii_passwd);
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	return NULL;
+}
+
+int make_md5_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 8;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_md5_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(md5crypt(password, "1", salt));
+
+	return NULL;
+}
+
+char *hash_md5(char *password)
+{
+	char *salt = NULL;
+	if (!make_md5_salt(&salt)) {
+		char *hashed = hash_md5_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+// char *extract_salt(char *hash)
+// {
+// 	size_t i	    = 0;
+// 	int salt_offset	    = 0;
+// 	int separator_count = 0;
+// 	char *salt	    = malloc(strlen(hash) + 1);
+
+// 	if (!salt)
+// 		return NULL;
+
+// 	for (; i < strlen(hash); i++) {
+// 		if (separator_count == 1) {
+// 			salt_offset = i + 1;
+// 		} else if (separator_count == 2) {
+// 			salt[i - salt_offset] = hash[i];
+// 		} else if (separator_count >= 3) {
+// 			salt[i - salt_offset - 1] = '\0';
+// 			return salt;
+// 		}
+// 		if (hash[i] == '$')
+// 			separator_count++;
+// 	}
+
+// 	free(salt);
+// 	return NULL;
+// }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_md5crypt.h src/src/passwd_md5crypt.h
--- upstream/src/passwd_md5crypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,11 @@
+#ifndef PASSWD_MD5CRYPT_H__
+#define PASSWD_MD5CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+int make_md5_salt(char **salt_p);
+char *hash_md5_with_salt(char *password, char *salt);
+char *hash_md5(char *password);
+// char *extract_salt(char *hash);
+
+#endif /* passwd_md5crypt.h */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_shacrypt.c src/src/passwd_shacrypt.c
--- upstream/src/passwd_shacrypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,406 @@
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <string.h>
+
+#include "passwd_shacrypt.h"
+
+static const unsigned char cov_2char[64] = {
+    /* from crypto/des/fcrypt.c */
+    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
+    0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
+    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
+    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
+    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
+    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
+    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
+    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+/*
+ * SHA based password algorithm, describe by Ulrich Drepper here:
+ * https://www.akkadia.org/drepper/SHA-crypt.txt
+ * (note that it's in the public domain)
+ */
+static char *shacrypt(const char *passwd, const char *magic, const char *salt)
+{
+    /* Prefix for optional rounds specification.  */
+    static const char rounds_prefix[] = "rounds=";
+    /* Maximum salt string length.  */
+# define SALT_LEN_MAX 16
+    /* Default number of rounds if not explicitly specified.  */
+# define ROUNDS_DEFAULT 5000
+    /* Minimum number of rounds.  */
+# define ROUNDS_MIN 1000
+    /* Maximum number of rounds.  */
+# define ROUNDS_MAX 999999999
+
+    /* "$6$rounds=<N>$......salt......$...shahash(up to 86 chars)...\0" */
+    static char out_buf[3 + 17 + 17 + 86 + 1];
+    unsigned char buf[SHA512_DIGEST_LENGTH];
+    unsigned char temp_buf[SHA512_DIGEST_LENGTH];
+    size_t buf_size = 0;
+    char ascii_magic[2];
+    char ascii_salt[17];          /* Max 16 chars plus '\0' */
+    char *ascii_passwd = NULL;
+    size_t n;
+    EVP_MD_CTX *md = NULL, *md2 = NULL;
+    const EVP_MD *sha = NULL;
+    size_t passwd_len, salt_len, magic_len;
+    unsigned int rounds = ROUNDS_DEFAULT;        /* Default */
+    char rounds_custom = 0;
+    char *p_bytes = NULL;
+    char *s_bytes = NULL;
+    char *cp = NULL;
+
+    passwd_len = strlen(passwd);
+    magic_len = strlen(magic);
+
+    /* assert it's "5" or "6" */
+    if (magic_len != 1)
+        return NULL;
+
+    switch (magic[0]) {
+    case '5':
+        sha = EVP_sha256();
+        buf_size = 32;
+        break;
+    case '6':
+        sha = EVP_sha512();
+        buf_size = 64;
+        break;
+    default:
+        return NULL;
+    }
+
+    if (strncmp(salt, rounds_prefix, sizeof(rounds_prefix) - 1) == 0) {
+        const char *num = salt + sizeof(rounds_prefix) - 1;
+        char *endp;
+        unsigned long int srounds = strtoul (num, &endp, 10);
+        if (*endp == '$') {
+            salt = endp + 1;
+            if (srounds > ROUNDS_MAX)
+                rounds = ROUNDS_MAX;
+            else if (srounds < ROUNDS_MIN)
+                rounds = ROUNDS_MIN;
+            else
+                rounds = (unsigned int)srounds;
+            rounds_custom = 1;
+        } else {
+            return NULL;
+        }
+    }
+
+    OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+    if ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */
+        ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+    /* The salt gets truncated to 16 chars */
+    OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+    salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+    ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+    ascii_passwd = OPENSSL_strdup(passwd);
+    if (ascii_passwd == NULL)
+        return NULL;
+    ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+    passwd = ascii_passwd;
+#endif
+
+    out_buf[0] = 0;
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    if (rounds_custom) {
+        char tmp_buf[80]; /* "rounds=999999999" */
+        sprintf(tmp_buf, "rounds=%u", rounds);
+#ifdef CHARSET_EBCDIC
+        /* In case we're really on a ASCII based platform and just pretend */
+        if (tmp_buf[0] != 0x72)  /* ASCII 'r' */
+            ebcdic2ascii(tmp_buf, tmp_buf, strlen(tmp_buf));
+#endif
+        OPENSSL_strlcat(out_buf, tmp_buf, sizeof(out_buf));
+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    }
+    OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+    /* assert "$5$rounds=999999999$......salt......" */
+    if (strlen(out_buf) > 3 + 17 * rounds_custom + salt_len)
+        goto err;
+
+    md = EVP_MD_CTX_new();
+    if (md == NULL
+        || !EVP_DigestInit_ex(md, sha, NULL)
+        || !EVP_DigestUpdate(md, passwd, passwd_len)
+        || !EVP_DigestUpdate(md, ascii_salt, salt_len))
+        goto err;
+
+    md2 = EVP_MD_CTX_new();
+    if (md2 == NULL
+        || !EVP_DigestInit_ex(md2, sha, NULL)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestUpdate(md2, ascii_salt, salt_len)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestFinal_ex(md2, buf, NULL))
+        goto err;
+
+    for (n = passwd_len; n > buf_size; n -= buf_size) {
+        if (!EVP_DigestUpdate(md, buf, buf_size))
+            goto err;
+    }
+    if (!EVP_DigestUpdate(md, buf, n))
+        goto err;
+
+    n = passwd_len;
+    while (n) {
+        if (!EVP_DigestUpdate(md,
+                              (n & 1) ? buf : (const unsigned char *)passwd,
+                              (n & 1) ? buf_size : passwd_len))
+            goto err;
+        n >>= 1;
+    }
+    if (!EVP_DigestFinal_ex(md, buf, NULL))
+        goto err;
+
+    /* P sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = passwd_len; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((p_bytes = OPENSSL_zalloc(passwd_len)) == NULL)
+        goto err;
+    for (cp = p_bytes, n = passwd_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    /* S sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = 16 + buf[0]; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((s_bytes = OPENSSL_zalloc(salt_len)) == NULL)
+        goto err;
+    for (cp = s_bytes, n = salt_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    for (n = 0; n < rounds; n++) {
+        if (!EVP_DigestInit_ex(md2, sha, NULL))
+            goto err;
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? (const unsigned char *)p_bytes : buf,
+                              (n & 1) ? passwd_len : buf_size))
+            goto err;
+        if (n % 3) {
+            if (!EVP_DigestUpdate(md2, s_bytes, salt_len))
+                goto err;
+        }
+        if (n % 7) {
+            if (!EVP_DigestUpdate(md2, p_bytes, passwd_len))
+                goto err;
+        }
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? buf : (const unsigned char *)p_bytes,
+                              (n & 1) ? buf_size : passwd_len))
+                goto err;
+        if (!EVP_DigestFinal_ex(md2, buf, NULL))
+                goto err;
+    }
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    md2 = NULL;
+    md = NULL;
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    p_bytes = NULL;
+    s_bytes = NULL;
+
+    cp = out_buf + strlen(out_buf);
+    *cp++ = ascii_dollar[0];
+
+# define b64_from_24bit(B2, B1, B0, N)                                   \
+    do {                                                                \
+        unsigned int w = ((B2) << 16) | ((B1) << 8) | (B0);             \
+        int i = (N);                                                    \
+        while (i-- > 0)                                                 \
+            {                                                           \
+                *cp++ = cov_2char[w & 0x3f];                            \
+                w >>= 6;                                                \
+            }                                                           \
+    } while (0)
+
+    switch (magic[0]) {
+    case '5':
+        b64_from_24bit (buf[0], buf[10], buf[20], 4);
+        b64_from_24bit (buf[21], buf[1], buf[11], 4);
+        b64_from_24bit (buf[12], buf[22], buf[2], 4);
+        b64_from_24bit (buf[3], buf[13], buf[23], 4);
+        b64_from_24bit (buf[24], buf[4], buf[14], 4);
+        b64_from_24bit (buf[15], buf[25], buf[5], 4);
+        b64_from_24bit (buf[6], buf[16], buf[26], 4);
+        b64_from_24bit (buf[27], buf[7], buf[17], 4);
+        b64_from_24bit (buf[18], buf[28], buf[8], 4);
+        b64_from_24bit (buf[9], buf[19], buf[29], 4);
+        b64_from_24bit (0, buf[31], buf[30], 3);
+        break;
+    case '6':
+        b64_from_24bit (buf[0], buf[21], buf[42], 4);
+        b64_from_24bit (buf[22], buf[43], buf[1], 4);
+        b64_from_24bit (buf[44], buf[2], buf[23], 4);
+        b64_from_24bit (buf[3], buf[24], buf[45], 4);
+        b64_from_24bit (buf[25], buf[46], buf[4], 4);
+        b64_from_24bit (buf[47], buf[5], buf[26], 4);
+        b64_from_24bit (buf[6], buf[27], buf[48], 4);
+        b64_from_24bit (buf[28], buf[49], buf[7], 4);
+        b64_from_24bit (buf[50], buf[8], buf[29], 4);
+        b64_from_24bit (buf[9], buf[30], buf[51], 4);
+        b64_from_24bit (buf[31], buf[52], buf[10], 4);
+        b64_from_24bit (buf[53], buf[11], buf[32], 4);
+        b64_from_24bit (buf[12], buf[33], buf[54], 4);
+        b64_from_24bit (buf[34], buf[55], buf[13], 4);
+        b64_from_24bit (buf[56], buf[14], buf[35], 4);
+        b64_from_24bit (buf[15], buf[36], buf[57], 4);
+        b64_from_24bit (buf[37], buf[58], buf[16], 4);
+        b64_from_24bit (buf[59], buf[17], buf[38], 4);
+        b64_from_24bit (buf[18], buf[39], buf[60], 4);
+        b64_from_24bit (buf[40], buf[61], buf[19], 4);
+        b64_from_24bit (buf[62], buf[20], buf[41], 4);
+        b64_from_24bit (0, 0, buf[63], 2);
+        break;
+    default:
+        goto err;
+    }
+    *cp = '\0';
+#ifdef CHARSET_EBCDIC
+    ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+
+    return out_buf;
+
+ err:
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    OPENSSL_free(ascii_passwd);
+    return NULL;
+}
+
+int make_sha512_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 16;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_sha512_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(shacrypt(password, "6", salt));
+
+	return NULL;
+}
+
+char *hash_sha512(char *password)
+{
+	char *salt = NULL;
+	if (!make_sha512_salt(&salt)) {
+		char *hashed = hash_sha512_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+char *extract_salt(char *hash)
+{
+	size_t i	    = 0;
+	int salt_offset	    = 0;
+	int separator_count = 0;
+	char *salt	    = malloc(strlen(hash) + 1);
+
+	if (!salt)
+		return NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1) {
+			salt_offset = i + 1;
+		} else if (separator_count == 2) {
+			salt[i - salt_offset] = hash[i];
+		} else if (separator_count >= 3) {
+			salt[i - salt_offset - 1] = '\0';
+			return salt;
+		}
+		if (hash[i] == '$')
+			separator_count++;
+	}
+
+	free(salt);
+	return NULL;
+}
+
+hash_type get_hash_type(char *hash) {
+	hash_type hash_type = HASH_NULL;
+	size_t i	    = 0;
+	int hash_id_offset	    = 0;
+	int separator_count = 0;
+	char *hash_id	    = malloc(strlen(hash) + 1);
+
+	if (!hash_id)
+		return HASH_NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1 && hash[i] != '$') {
+			hash_id[i - hash_id_offset] = hash[i];
+		} else {
+			hash_id[i - hash_id_offset] = '\0';
+			hash_id_offset++;
+		}
+		if (hash[i] == '$') {
+			separator_count++;
+		}
+	}
+
+	if (!strcmp(hash_id, "1")) {
+		hash_type = HASH_MD5;
+	} else if (!strcmp(hash_id, "6")) {
+		hash_type = HASH_SHA512;
+	}
+
+	free(hash_id);
+	return hash_type;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_shacrypt.h src/src/passwd_shacrypt.h
--- upstream/src/passwd_shacrypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,18 @@
+#ifndef PASSWD_SHA512CRYPT_H__
+#define PASSWD_SHA512CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+typedef enum {
+	HASH_MD5,
+	HASH_SHA512,
+	HASH_NULL
+} hash_type;
+
+int make_sha512_salt(char **salt_p);
+char *hash_sha512_with_salt(char *password, char *salt);
+char *hash_sha512(char *password);
+char *extract_salt(char *hash);
+hash_type get_hash_type(char *hash);
+
+#endif /* passwd_sha512crypt.h */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/patricia.c src/src/patricia.c
--- upstream/src/patricia.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/patricia.c	2025-07-03 10:02:27.000000000 +0000
@@ -264,7 +264,7 @@
 #endif /* HAVE_IPV6 */
 
   if ((cp = strchr (string, '/')) != NULL) {
-    bitlen = atol (cp + 1);
+    bitlen = strtol(cp + 1, NULL, 0);
     /* *cp = '\0'; */
     /* copy the string to save. Avoid destroying the string */
     assert (cp - string < MAXLINE);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pkt.h src/src/pkt.h
--- upstream/src/pkt.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/pkt.h	2025-07-03 10:02:27.000000000 +0000
@@ -560,7 +560,20 @@
 #define pkt_buffer_is_eth(pb)  ((pb)->offset == PKT_BUFFER_ETHOFF)
 #define pkt_buffer_is_vlan(pb) ((pb)->offset == PKT_BUFFER_VLANOFF)
 
-#define MAC_FMT "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X"
-#define MAC_ARG(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]
+#define MAC_DELIM_DASH	0
+#define MAC_DELIM_COLON 1
+#define MAC_DELIM_NONE	2
+
+#define MAC_FMT_UPPER_DASH  "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X"
+#define MAC_FMT_UPPER_COLON "%.2X:%.2X:%.2X:%.2X:%.2X:%.2X"
+#define MAC_FMT_UPPER_NONE  "%.2X%.2X%.2X%.2X%.2X%.2X"
+
+#define MAC_FMT_LOWER_DASH  "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
+#define MAC_FMT_LOWER_COLON "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x"
+#define MAC_FMT_LOWER_NONE  "%.2x%.2x%.2x%.2x%.2x%.2x"
+
+#define MAC_FMT MAC_FMT_UPPER_DASH
+
+#define MAC_ARG(x) (x)[0], (x)[1], (x)[2], (x)[3], (x)[4], (x)[5]
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius.c src/src/radius.c
--- upstream/src/radius.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius.c	2025-07-03 10:02:27.000000000 +0000
@@ -25,6 +25,9 @@
 
 #define deeplog 0
 
+static int radius_verify_message_authenticator(struct radius_t *this, 
+		 struct radius_packet_t *pack, struct radius_packet_t *pack_req);
+
 static int
 radius_authcheck(struct radius_t *this, struct radius_packet_t *pack,
 		 struct radius_packet_t *pack_req);
@@ -408,12 +411,15 @@
 #endif
 
   if (RADIUS_QUEUE_HASPKT(this->queue[idx].p)) {
-    if (pack_in &&
-	radius_authcheck(this, pack_in,
-			 RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
+    if (pack_in && radius_authcheck(this, pack_in, RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
       syslog(LOG_WARNING, "Authenticator does not match! req-id=%d res-id=%d",
-             RADIUS_QUEUE_PKT(this->queue[idx].p,id),
-             pack_in->id);
+            RADIUS_QUEUE_PKT(this->queue[idx].p,id),
+            pack_in->id);
+      return -1;
+    }
+
+    if (pack_in && radius_verify_message_authenticator(this, pack_in, RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
+      syslog(LOG_WARNING, "Message-Authenticator is invalid!");
       return -1;
     }
 
@@ -1702,6 +1708,40 @@
   return 0;
 }
 
+/*
+ * radius_verify_message_authenticator()
+ * RFC2869 Section 5.14
+ */
+static int radius_verify_message_authenticator(struct radius_t *this, 
+		 struct radius_packet_t *pack, struct radius_packet_t *pack_req)
+{
+  struct radius_attr_t *ma = NULL;
+
+  /* If packet contains message authenticator: Validate it */
+  if (!radius_getattr(pack, &ma, RADIUS_ATTR_MESSAGE_AUTHENTICATOR, 0, 0, 0)) {
+    uint8_t reply[RADIUS_AUTHLEN];
+
+    memcpy(reply, ma->v.t, RADIUS_AUTHLEN);
+    memset(ma->v.t, 0, RADIUS_AUTHLEN);
+
+    memcpy(pack->authenticator, pack_req->authenticator, RADIUS_AUTHLEN);
+
+    radius_hmac_md5(this, pack, this->secret, this->secretlen, ma->v.t);
+
+    if (_options.debug) {
+      syslog(LOG_DEBUG, "Message-Authenticator "
+            AUTH_FMT"(pkt) == "AUTH_FMT"(calc)",
+            AUTH_ARG(reply),
+            AUTH_ARG(ma->v.t));
+    }
+
+    if (memcmp(ma->v.t, reply, RADIUS_AUTHLEN) != 0) return 1;
+  /* If packet doesn't contain message authenticator but it's required: Discard packet */
+  } else if (pack_req->code == RADIUS_CODE_ACCESS_REQUEST && _options.radiusrequiremessageauth) {
+    return 1;
+  }
+  return 0;
+}
 
 /*
  * radius_authcheck()
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius.h src/src/radius.h
--- upstream/src/radius.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius.h	2025-07-03 10:02:27.000000000 +0000
@@ -202,9 +202,9 @@
   struct in_addr addr0;
   struct in_addr addr1;
   char secret[RADIUS_SECRETSIZE];
-  size_t secretlen;
   uint16_t authport;
   uint16_t acctport;
+  size_t secretlen;
 };
 
 struct radius_t {
@@ -224,6 +224,8 @@
 
   struct in_addr hisaddr0;       /* Server address */
   struct in_addr hisaddr1;       /* Server address */
+  /* Padding to separate secret from preceding field */
+  char padding1[2];
   char secret[RADIUS_SECRETSIZE];/* Shared secret */
   size_t secretlen;              /* Length of sharet secret */
 
@@ -241,11 +243,15 @@
   uint16_t proxyport;            /* Proxy port to listen to */
   struct in_addr proxyaddr;      /* Proxy client address */
   struct in_addr proxymask;      /* Proxy client mask */
+  /* Padding to separate proxysecret from preceding field */
+  char padding2[2];
   char proxysecret[RADIUS_SECRETSIZE]; /* Proxy secret */
   size_t proxysecretlen;            /* Length of sharet secret */
 #endif
 
   unsigned char nas_hwaddr[6];   /* Hardware address of NAS */
+  /* Padding to separate debug from preceding field */
+  char padding3[2];
   int debug;                     /* Print debug messages */
 
   int (*cb_ind)       (struct radius_t *radius, struct radius_packet_t *pack,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius_coovachilli.h src/src/radius_coovachilli.h
--- upstream/src/radius_coovachilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius_coovachilli.h	2025-07-03 10:02:27.000000000 +0000
@@ -49,6 +49,7 @@
 #define	RADIUS_ATTR_COOVACHILLI_LOCATION                  25 /* string */
 #define	RADIUS_ATTR_COOVACHILLI_OLD_LOCATION              26 /* string */
 #define	RADIUS_ATTR_COOVACHILLI_LOCATION_CHANGE_COUNT     27 /* integer */
+#define	RADIUS_ATTR_COOVACHILLI_SSID                      28 /* string */
 
 #define RADIUS_ATTR_COOVACHILLI_SYS_UPTIME                40 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_SYS_LOADAVG               41 /* string */
@@ -84,6 +85,7 @@
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_OCTETS       85 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_INPUT_GIGAWORDS     86 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_GIGAWORDS    87 /* integer */
+#define	RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS            88 /* integer */
 
 #define RADIUS_VALUE_COOVACHILLI_NAS_VIEWPOINT             1
 #define RADIUS_VALUE_COOVACHILLI_CLIENT_VIEWPOINT          2
@@ -100,5 +102,6 @@
 #define RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED    15
 #define RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED  16
 #define RADIUS_VALUE_COOVACHILLI_SESSION_LOCATION_CHANGE          17
+#define RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED	          18
 
 #endif	/* !_RADIUS_COOVACHILLI_H */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/redir.c src/src/redir.c
--- upstream/src/redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.c	2025-07-03 10:02:27.000000000 +0000
@@ -18,21 +18,24 @@
  *
  */
 
+#include <inttypes.h>
 #include "system.h"
 #include "chilli.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
+#include "chilli_module.h"
 #endif
 #ifdef ENABLE_EWTAPI
 #include "ewt.h"
 #endif
 #include "json/json.h"
+#include <uci.h>
 
 static int optionsdebug = 0; /* TODO: Should be changed to instance */
 
 static int termstate = REDIR_TERM_INIT;    /* When we were terminated */
 
-char credits[] =
+const char credits[] =
     "<H1>CoovaChilli " VERSION "</H1>"
     "<p>Copyright 2002-2005 Mondru AB</p>"
     "<p>Copyright 2006-2012 David Bird (Coova Technologies)</p>"
@@ -202,16 +205,6 @@
   bcatcstr(s, "P3P: CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"\r\n");
 }
 
-static int bstrtocstr(bstring src, char *dst, unsigned int len) {
-  if (!src || src->slen == 0) {
-    dst[0] = 0;
-    return 0;
-  }
-
-  strlcpy(dst, (char*)src->data, len);
-  return 0;
-}
-
 /* Encode src as urlencoded and place null terminated result in dst */
 int redir_urlencode(bstring src, bstring dst) {
   char x[3];
@@ -412,21 +405,22 @@
 }
 
 static void bstring_buildurl(bstring str, struct redir_conn_t *conn,
-			     struct redir_t *redir, char *redir_url, char *resp,
+			     struct redir_t *redir, char *redir_url, const char *resp,
 			     long int timeleft, char* hexchal, char* uid,
 			     char* userurl, char* reply, char* redirurl,
 			     uint8_t *hismac, struct in_addr *hisip, char *amp) {
   bstring bt = bfromcstr("");
   bstring bt2 = bfromcstr("");
 
-  bassignformat(str, "%s%sres=%s%suamip=%s%suamport=%d",
-		redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
-		inet_ntoa(redir->addr), amp,
-		redir->port);
+  bassignformat(str, "%s%sres=%s%s%s=%s%s%s=%d",
+                redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
+                _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                amp, _options.paramuamport ? _options.paramuamport : "uamport", redir->port);
 
   if (!_options.nochallenge && hexchal) {
     bcatcstr(str, amp);
-    bassignformat(bt, "challenge=%s", hexchal);
+    bassignformat(bt, "%s=%s", _options.paramchallenge ? _options.paramchallenge : "challenge",
+                  hexchal);
     bconcat(str, bt);
     bassigncstr(bt,"");
   }
@@ -440,28 +434,68 @@
       sessiontime = timenow - starttime;
 
       bcatcstr(str, amp);
-      bassignformat(bt, "starttime=%ld", (long) starttime);
+      bassignformat(bt, "starttime=%" PRId64, (uint64_t) starttime);
       bconcat(str, bt);
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontime=%ld", (long) sessiontime);
+      bassignformat(bt, "sessiontime=%" PRId64, (uint64_t) sessiontime);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessiontimeout) {
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontimeout=%ld", (long) conn->s_params.sessiontimeout);
+      bassignformat(bt, "sessiontimeout=%" PRId64, (uint64_t) conn->s_params.sessiontimeout);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessionterminatetime) {
       bcatcstr(str, amp);
-      bassignformat(bt, "stoptime=%ld", (long) conn->s_params.sessionterminatetime);
+      bassignformat(bt, "stoptime=%" PRId64, (uint64_t) conn->s_params.sessionterminatetime);
+      bconcat(str, bt);
+    }
+  }
+
+  if (conn->type == REDIR_TRIAL || conn->type == REDIR_LOGIN || conn->type == REDIR_STATUS){
+    if (conn->s_params.maxinputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxinputoctets=%lld", conn->s_params.maxinputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.maxoutputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxoutputoctets=%lld", conn->s_params.maxoutputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.warningoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "warningoctets=%lld", conn->s_params.warningoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxup) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "bandwidthmaxup=%lld", conn->s_params.bandwidthmaxup);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxdown) {
+	  bcatcstr(str, amp);
+	  bassignformat(bt, "bandwidthmaxdown=%lld", conn->s_params.bandwidthmaxdown);
+	  bconcat(str, bt);
+	}
+
+    if (conn->s_params.expiration &&
+        conn->s_state.redir.auth_mode != AUTH_TRIAL_USER) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "expiration=%lld", conn->s_params.expiration);
       bconcat(str, bt);
     }
   }
 
   bcatcstr(str, amp);
-  bcatcstr(str, "called=");
+  bcatcstr(str, _options.paramcalled ? _options.paramcalled : "called");
+  bcatcstr(str, "=");
   if (_options.nasmac)
     bassigncstr(bt, _options.nasmac);
   else
@@ -488,7 +522,8 @@
 
   if (hismac) {
     bcatcstr(str, amp);
-    bcatcstr(str, "mac=");
+    bcatcstr(str, _options.parammac ? _options.parammac : "mac");
+    bcatcstr(str, "=");
     bassignformat(bt, "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
 		  hismac[0], hismac[1],
 		  hismac[2], hismac[3],
@@ -499,7 +534,7 @@
 
   if (hisip) {
     bcatcstr(str, amp);
-    bassignformat(bt, "ip=%s", inet_ntoa(*hisip));
+    bassignformat(bt, "%s=%s", _options.paramip ? _options.paramip : "ip", inet_ntoa(*hisip));
     bconcat(str, bt);
   }
 
@@ -521,12 +556,45 @@
 
   if (_options.radiusnasid) {
     bcatcstr(str, amp);
-    bcatcstr(str, "nasid=");
+    bcatcstr(str, _options.paramnasid ? _options.paramnasid : "nasid");
+    bcatcstr(str, "=");
     bassigncstr(bt, _options.radiusnasid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+	if (_options.tos) {
+		bcatcstr(str, amp);
+		bcatcstr(str, "tos=1");
+	}
+
+    if (_options.macpass) {
+      bcatcstr(str, amp);
+      bcatcstr(str, "macpass=1");
+    }
+
+#ifdef USING_CURL
+    if (_options.oidc) {
+      bcatcstr(str, amp);
+      bcatcstr(str, "oidc=1");
+    }
+#endif
+
+    if (_options.registerusers) {
+        bcatcstr(str, amp);
+        bcatcstr(str, "signup=1"); 
+    }
+
+  if (_options.trialusers) {
+    bcatcstr(str, amp);
+    bcatcstr(str, "trial=1");
+  }
+
+    if (conn->s_state.terminate_cause_ui){
+		bcatcstr(str, amp);
+		bassignformat(bt, "termcause=%d", (long) conn->s_state.terminate_cause_ui);
+		bconcat(str, bt);
+  	}
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && conn->s_state.tag8021q) {
     bcatcstr(str, amp);
@@ -580,8 +648,8 @@
   }
 
   if (conn->s_state.sessionid[0]) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "sessionid=");
+    bassignformat(bt, "%s%s=", amp, _options.paramsessionid ? _options.paramsessionid : "sessionid");
+    bconcat(str, bt);
     bassigncstr(bt, conn->s_state.sessionid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
@@ -597,13 +665,19 @@
     bcatcstr(str, amp);
     bcatcstr(str, "ssl=");
     if (_options.uamaliasname && _options.domain) {
-      bassignformat(bt, "https://%s.%s:%d/",
-                    _options.uamaliasname,
-                    _options.domain,
-                    _options.uamuiport);
+      if (_options.redirssl) {
+        bassignformat(bt, "https://%s.%s/",
+              _options.uamaliasname,
+              _options.domain);
+      } else {
+        bassignformat(bt, "https://%s.%s:%d/",
+              _options.uamaliasname,
+              _options.domain,
+              _options.uamuiport);
+      }
     } else {
       bassignformat(bt, "https://%s:%d/",
-                    inet_ntoa(_options.uamalias),
+                    inet_ntoa(_options.uamlisten),
                     _options.uamuiport);
     }
     redir_urlencode(bt, bt2);
@@ -620,13 +694,23 @@
   }
 
   if (userurl) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "userurl=");
+    bassignformat(bt, "%s%s=", amp, _options.paramuserurl ? _options.paramuserurl : "userurl");
+    bconcat(str, bt);
     bassigncstr(bt, userurl);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+  if (_options.param1 && _options.param1value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param1, _options.param1value);
+    bconcat(str, bt);
+  }
+
+  if (_options.param2 && _options.param2value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param2, _options.param2value);
+    bconcat(str, bt);
+  }
+
   if (redir->secret && *redir->secret) {
     /* take the md5 of the url+uamsecret as a checksum */
     redir_md_param(str, redir->secret, amp);
@@ -680,8 +764,8 @@
 
         bcatcstr(b, "<State>1</State>\r\n");
 
-        bassignformat(bt, "<StartTime>%d</StartTime>\r\n" ,
-                      conn->s_state.start_time);
+        bassignformat(bt, "<StartTime>%"PRId64"</StartTime>\r\n" ,
+                      (uint64_t)conn->s_state.start_time);
         bconcat(b, bt);
 
         bassignformat(bt, "<SessionTime>%d</SessionTime>\r\n",
@@ -717,6 +801,10 @@
         bassignformat(bt, "<MaxTotalOctets>%d</MaxTotalOctets>\r\n",
                       conn->s_params.maxtotaloctets);
         bconcat(b, bt);
+
+        bassignformat(bt, "<WarningOctets>%d</WarningOctets>\r\n",
+                      conn->s_params.warningoctets);
+        bconcat(b, bt);
       }
       else {
         bcatcstr(b, "<State>0</State>\r\n");
@@ -733,7 +821,10 @@
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       if (reply) {
         bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
         bconcat(b, bt);
@@ -760,7 +851,15 @@
 
     case REDIR_REQERROR:
       break;
-
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -779,9 +878,6 @@
 			 char* reply, char* redirurl, bstring b) {
   bstring bt = bfromcstr("");;
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -816,10 +912,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;&s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -860,7 +958,10 @@
     case REDIR_ERROR_PROTOCOL:
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       bcatcstr(b,
                "<AuthenticationPollReply>\r\n"
                "<MessageType>140</MessageType>\r\n" /* response to authentication notification */
@@ -953,6 +1054,29 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      bcatcstr(b,
+                "<AuthenticationPollReply>\r\n"
+                "<MessageType>170</MessageType>\r\n"  /* response to notification */
+                "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      bcatcstr(b, "</AuthenticationPollReply>\r\n");
+      break;
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -990,9 +1114,6 @@
   bstring bt = bfromcstr("");
   char eap64str [MAX_EAP_LEN*2];
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -1037,10 +1158,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;u%s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -1134,7 +1257,10 @@
       write_authentication_msg_footer(conn,b);
       break;
 
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       write_authentication_msg_header(conn,b);
 
       bcatcstr(b,
@@ -1166,10 +1292,12 @@
           syslog(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;continue=1&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;%s=%s&amp;continue=1&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bcatcstr(b, "</EAPAuthenticationReply>\r\n");
@@ -1259,6 +1387,25 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      write_authentication_msg_header(conn,b);
+      bcatcstr(b, "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      write_authentication_msg_footer(conn, b);
     default:
       syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
@@ -1300,6 +1447,8 @@
       break;
 
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
       flg |= FLG_chlg;
       flg |= FLG_redir;
@@ -1423,7 +1572,7 @@
 #endif
 
 static void redir_buildurl(struct redir_conn_t *conn, bstring str,
-			   struct redir_t *redir, char *resp,
+			   struct redir_t *redir, const char *resp,
 			   long int timeleft, char* hexchal, char* uid,
 			   char* userurl, char* reply, char* redirurl,
 			   uint8_t *hismac, struct in_addr *hisip) {
@@ -1500,7 +1649,7 @@
 		char* userurl, char* reply, char* redirurl,
 		uint8_t *hismac, struct in_addr *hisip, char *qs) {
 
-  char *resp = NULL;
+  const char *resp = NULL;
   bstring buffer;
 
   switch (res) {
@@ -1508,7 +1657,7 @@
       resp = "already";
       break;
     case REDIR_FAILED_REJECT:
-      resp = "failed&reason=reject";
+        resp = "failed&reason=reject";
       break;
     case REDIR_FAILED_TIMEOUT:
       resp = "failed&reason=timeout";
@@ -1516,10 +1665,19 @@
     case REDIR_FAILED_MTU:
       resp = "failed&reason=mtu";
       break;
+    case REDIR_FAILED_DATA:
+      resp = "failed&reason=data_limit";
+      break;
+    case REDIR_FAILED_TIME:
+      resp = "failed&reason=time_limit";
+        break;
     case REDIR_FAILED_OTHER:
     case REDIR_ERROR_PROTOCOL:
       resp = "failed&reason=other";
       break;
+    case REDIR_FAILED_TOS:
+      resp = "failed&reason=tos";
+      break;
     case REDIR_REQERROR:
       resp = "failed";
       break;
@@ -1530,7 +1688,7 @@
       resp = "logoff";
       break;
     case REDIR_NOTYET:
-      resp = "notyet";
+      resp = (_options.smsusers && conn->s_state.redir.otp_state == 1) ? "notyet&otpstate=active" : "notyet";
       break;
     case REDIR_SPLASH:
       resp = "splash";
@@ -1550,6 +1708,56 @@
     case REDIR_CHALLENGE:
       resp = "challenge";
       break;
+    case REDIR_SMSSIGNUP_FAILED:
+      resp = "smssignup_fail&reason=err";
+      break;
+  	case REDIR_SMSSIGNUP_ALREADY:
+      resp = "smssignup_fail&reason=already";
+      break;
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+      resp = "smssignup_fail&reason=sms";
+      break;
+  	case REDIR_SMSSIGNUP_DENIED:
+      resp = "smssignup_fail&reason=denied";
+      break;
+    case REDIR_SMSSIGNUP_SUCCESS:
+      resp = "smssuccess";
+      break;
+  	case REDIR_SIGNUP_SUCCESS:
+      resp = "signup_success";
+      break;
+  	case REDIR_SIGNUP_FAILED:
+      resp = "signup_fail&reason=err";
+      break;
+  	case REDIR_SIGNUP_ALREADY:
+      resp = "signup_fail&reason=already";
+      break;
+    case REDIR_SIGNUP_DENIED:
+      resp = "signup_fail&reason=denied";
+      break;
+    case REDIR_TRIALLOGIN_DENIED:
+      resp = "failed&reason=trial_denied";
+      break;
+    case REDIR_TRIALLOGIN_FAILED:
+      resp = "failed&reason=trial_fail";
+      break;
+#ifdef USING_CURL
+    case REDIR_SSO_DENIED:
+      resp = "failed&reason=sso_denied";
+      break;
+    case REDIR_SSO_FAILED:
+      resp = "failed&reason=sso_fail";
+      break;
+#endif
+    case REDIR_TRIAL_FAILED_DATA:
+      resp = "failed&reason=data_limit_trial";
+          break;
+    case REDIR_TRIAL_FAILED_TIME:
+      resp = "failed&reason=time_limit_trial";
+          break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      resp = "failed&reason=user_duplicate";
+      break;
     default:
       syslog(LOG_ERR, "Unknown res in switch");
       return -1;
@@ -1577,12 +1785,10 @@
       bcatcstr(buffer, "Location: ");
 
       if (url) {
-
-        bconcat(buffer, url);
-
-      } else if (!_options.redirurl && redirurl && *redirurl) {
-	bcatcstr(buffer, redirurl);
-      } else {
+          bconcat(buffer, url);
+      }else if (!_options.redirurl && redirurl && *redirurl)
+	    bcatcstr(buffer, redirurl);
+      else {
         bt = bfromcstralloc(1024,"");
         redir_buildurl(conn, bt, redir, resp, timeleft, hexchal,
                        uid, userurl, reply, redirurl, hismac, hisip);
@@ -2171,6 +2377,18 @@
 	  conn->type = REDIR_LOGIN;
 	else if ((!strcmp(path, "logoff")) || (!strcmp(path, "logout")))
 	  conn->type = REDIR_LOGOUT;
+	else if (!strcmp(path, "trial"))
+	  conn->type = REDIR_TRIAL;
+    else if ((!strcmp(path, "signup")) || (!strcmp(path, "register")))
+      conn->type = REDIR_SIGNUP;
+    else if ((!strcmp(path, "smssignup")) || (!strcmp(path, "smsregister")))
+      conn->type = REDIR_SMSSIGNUP;
+#ifdef USING_CURL
+    else if (!strcmp(path, "ssologin"))
+      { conn->type = REDIR_SSOLOGIN; }
+    else if (!strcmp(path, "ssocallback"))
+      conn->type = REDIR_SSOCALLBACK;
+#endif
 	else if (!strncmp(path, "www/", 4) && strlen(path) > 4)
 	  conn->type = REDIR_WWW;
 	else if (!strcmp(path, "status"))
@@ -2234,7 +2452,16 @@
 	  p = buffer + 15;
 	  while (*p && isspace((int) *p)) p++;
 	  len = strlen(p);
-	  if (len > 0) httpreq->clen = atoi(p);
+	  if (len > 0) {
+		  char *endptr;
+		  long int clen = strtol(p, &endptr, 10);
+      if(p != endptr && *endptr != '\0')
+      {
+	      httpreq->clen = clen;
+      } else {
+        syslog(LOG_DEBUG, "%s(%d): Bad Content-Length: %s", __FUNCTION__, __LINE__, p);
+      }
+	  }
 #if(_debug_ > 1)
           if (_options.debug)
             syslog(LOG_DEBUG, "%s(%d): Content-Length: %s", __FUNCTION__, __LINE__, p);
@@ -2280,7 +2507,7 @@
       for (i = 0; i < (int)(buflen - linelen); i++)
 	buffer[i] = buffer[(int)linelen + i];
 
-      /*syslog(LOG_DEBUG, "linelen=%d buflen=%d", linelen, buflen);*/
+
       buflen -= linelen;
     }
 
@@ -2317,6 +2544,18 @@
         if (!redir_getparam(redir, httpreq->qs, "lang", bt))
           bstrtocstr(bt, conn->lang, sizeof(conn->lang));
 
+	  	if (_options.tos){
+		  if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+		      if (_options.debug)
+			    syslog(LOG_ERR, "No agreetos found in login request");
+
+			  conn->response = REDIR_FAILED_TOS;
+			  bdestroy(bt);
+			  return 0;
+		  }
+		  conn->s_state.redir.tos = 1;
+	  	}
+
         if (redir_getparam(redir, httpreq->qs, "username", bt)) {
           syslog(LOG_ERR, "No username found in login request");
           conn->response = REDIR_ERROR_PROTOCOL;
@@ -2324,8 +2563,7 @@
           return -1;
         }
 
-        bstrtocstr(bt, conn->s_state.redir.username,
-                   sizeof(conn->s_state.redir.username));
+        besc_strtocstr(bt, conn->s_state.redir.username, sizeof(conn->s_state.redir.username));
 
         if (_options.debug)
           syslog(LOG_DEBUG, "%s(%d): -->> Setting username=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.username);
@@ -2376,11 +2614,16 @@
                           conn->authdata.v.chapmsg.password,
                           RADIUS_CHAPSIZE);
 
-          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen)
-            conn->authdata.v.chapmsg.identity = atoi((char*)bt->data);
-          else
+          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen) {
+            char *endptr;
+            unsigned long value = strtoul((char *)bt->data, &endptr, 10);
+            if(*endptr == '\0' && value <= UINT8_MAX) {
+              conn->authdata.v.chapmsg.identity = (uint8_t)value;
+            }
+          } else {
             conn->authdata.v.chapmsg.identity = 0;
-        }
+          }
+	}
         else if (!redir_getparam(redir, httpreq->qs, "password", bt)) {
           conn->authdata.type = REDIR_AUTH_PAP;
           if (_options.nochallenge) {
@@ -2471,7 +2714,171 @@
         bdestroy(bt);
       }
       break;
+    case REDIR_SIGNUP:
+      {
+      	if (!_options.registerusers){
+      	  if (_options.debug)
+			syslog(LOG_ERR, "Signup method is not allowed");
+
+          conn->response = REDIR_SIGNUP_DENIED;
+          return 0;
+      	}
+
+        bstring bt = bfromcstr("");
+        if (redir_getparam(redir, httpreq->qs, "email", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No email found in signup request");
 
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+        besc_strtocstr(bt, conn->s_state.redir.email,
+                       sizeof(conn->s_state.redir.email));
+        if (redir_getparam(redir, httpreq->qs, "phone", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No phone found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.phone,
+                       sizeof(conn->s_state.redir.phone));
+        if (redir_getparam(redir, httpreq->qs, "password", bt)) {
+          if (_options.debug)
+            syslog(LOG_ERR, "No password found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.signup_password,
+                       sizeof(conn->s_state.redir.signup_password));
+        bdestroy(bt);
+      }
+      break;
+    case REDIR_SMSSIGNUP:
+    {
+		if (!_options.smsusers){
+			syslog(LOG_ERR, "SMSsignup method not allowed");
+			conn->response = REDIR_SMSSIGNUP_DENIED;
+			return 0;
+		}
+
+		bstring bt = bfromcstr("");
+		if (redir_getparam(redir, httpreq->qs, "phone", bt)){
+		syslog(LOG_ERR, "No phone found in smssignup request");
+		conn->response = REDIR_SMSSIGNUP_FAILED;
+		bdestroy(bt);
+		return -1;
+		}
+
+		besc_strtocstr(bt, conn->s_state.redir.phone,
+					 sizeof(conn->s_state.redir.phone));
+		bdestroy(bt);
+    }
+    break;
+    case REDIR_TRIAL:
+    {
+		if (!_options.trialusers){
+			syslog(LOG_ERR, "Trial login is not allowed");
+			conn->response = REDIR_TRIALLOGIN_DENIED;
+			return 0;
+		}
+
+      bstring bt = bfromcstr("");
+
+      //if (!redir_getparam(redir, httpreq->qs, "lang", bt))
+        //bstrtocstr(bt, conn->lang, sizeof(conn->lang));
+
+      if (_options.tos){
+        if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+          if (_options.debug)
+            syslog(LOG_ERR, "No agreetos found in login request");
+
+          conn->response = REDIR_FAILED_TOS;
+          bdestroy(bt);
+          return 0;
+        }
+        conn->s_state.redir.tos = 1;
+      }
+
+      bdestroy(bt);
+    }
+    break;
+#ifdef USING_CURL
+    case REDIR_SSOCALLBACK:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid || !_options.oidcclientsecret) {
+          syslog(LOG_ERR, "SSO Login not allowed");
+          conn->response = REDIR_SSO_DENIED;
+          return 0;
+        }
+
+        char state[128];
+        bstring bt = bfromcstr("");
+        if (redir_getparam(redir, httpreq->qs, "state", bt)){
+          if (_options.debug)
+            syslog(LOG_ERR, "No state found in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+        bstrtocstr(bt, state, sizeof(state));
+
+        char chal_buffer[64];
+        redir_chartohex(conn->s_state.redir.uamchal, chal_buffer, REDIR_MD5LEN);
+        if(strncmp(state, chal_buffer, sizeof(state))) {
+          if (_options.debug)
+            syslog(LOG_ERR, "Invalid state in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+
+        if (redir_getparam(redir, httpreq->qs, "code", bt)){
+          if (_options.debug)
+            syslog(LOG_ERR, "No code found in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+
+        bstrtocstr(bt, conn->s_state.redir.code, sizeof(conn->s_state.redir.code));
+		    bdestroy(bt);
+      }
+      break;
+    case REDIR_SSOLOGIN:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid || !_options.oidcclientsecret) {
+          syslog(LOG_ERR, "SSO Login not allowed");
+          conn->response = REDIR_SSO_DENIED;
+          return 0;
+        }
+
+        bstring bt = bfromcstr("");
+        if (_options.tos) {
+          if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+            if (_options.debug)
+              syslog(LOG_ERR, "No agreetos found in login request");
+
+            conn->response = REDIR_FAILED_TOS;
+            bdestroy(bt);
+            return 0;
+          }
+          conn->s_state.redir.tos = 1;
+        }
+        bdestroy(bt);
+      }
+      break;
+#endif
     case REDIR_WWW:
       {
         bstring bt = bfromcstr(path+4);
@@ -2961,32 +3368,254 @@
   return 0;
 }
 
-int is_local_user(struct redir_t *redir, struct redir_conn_t *conn) {
-  uint8_t user_password[RADIUS_PWSIZE+1];
-  uint8_t chap_challenge[REDIR_MD5LEN];
-  char u[256]; char p[256];
-  size_t usernamelen, sz=1024;
-  ssize_t len;
-  int match=0;
-  char *line=0;
-  MD5_CTX context;
-  FILE *f;
+void session_param_from_config(struct session_params *params, const char *group_name) {
+  const char *tmp = NULL;
+
+  struct uci_context *uci_ctx = uci_alloc_context();
+  if (!uci_ctx) {
+    syslog(LOG_ERR, "Failed to allocate uci context");
+    return;
+  }
+
+  struct uci_package *package = NULL;
+  if (uci_load(uci_ctx, CHILLI_CONFIG, &package)) {
+    syslog(LOG_ERR, "Failed to load '%s' config", CHILLI_CONFIG);
+    uci_free_context(uci_ctx);
+    return;
+  }
+
+  struct uci_element *e = NULL;
+  uci_foreach_element(&package->sections, e) {
+    struct uci_section *s = uci_to_section(e);
+    if (!s || strcmp(s->type, "group"))
+      continue;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "name");
+    if (!tmp || strcmp(tmp, group_name))
+      continue;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "defsessiontimeout");
+    params->sessiontimeout = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "defidletimeout");
+    params->idletimeout = tmp ? strtoul(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "downloadlimit");
+    params->maxinputoctets = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "uploadlimit");
+    params->maxoutputoctets = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "downloadbandwidth");
+    params->bandwidthmaxdown = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "uploadbandwidth");
+    params->bandwidthmaxup = tmp ? strtoull(tmp, NULL, 0) : 0;
 
-  if (!_options.localusers) return 0;
+    tmp = uci_lookup_option_string(uci_ctx, s, "period");
+    params->period = tmp ? strtol(tmp, NULL, 0) : 3;
+
+    switch (params->period) {
+    case 3:
+      tmp = uci_lookup_option_string(uci_ctx, s, "day");
+      break;
+    case 2:
+      tmp = uci_lookup_option_string(uci_ctx, s, "weekday");
+      break;
+    case 1:
+      tmp = uci_lookup_option_string(uci_ctx, s, "hour");
+      break;
+    default:
+      tmp = NULL;
+      break;
+    }
+    params->start = tmp ? strtol(tmp, NULL, 0) : 1;
+    goto clean;
+  }
+
+  params->sessiontimeout = 0;
+  params->idletimeout = 0;
+  params->maxinputoctets = 0;
+  params->maxoutputoctets = 0;
+  params->bandwidthmaxdown = 0;
+  params->bandwidthmaxup = 0;
+  params->period = 3;
+  params->start = 1;
+
+clean:
+  uci_unload(uci_ctx, package);
+  uci_free_context(uci_ctx);
+}
+
+int auth_chap(struct redir_conn_t *conn, MD5_CTX *context, uint8_t *chap_challenge,
+		uint8_t *user_password, char *password)
+{
+    uint8_t tmp[REDIR_MD5LEN];
+    MD5Init(context);
+    MD5Update(context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
+    MD5Update(context, (uint8_t*)password, strlen(password));
+    MD5Update(context, chap_challenge, REDIR_MD5LEN);
+    MD5Final(tmp, context);
+
+    if (!memcmp(user_password, tmp,  REDIR_MD5LEN)) {
+		return ACCESS_ACCEPTED;
+	}
+    else {
+      if (_options.debug)
+		syslog(LOG_INFO, "%s(%d): bad password", __FUNCTION__, __LINE__);
+	}
+
+	return ACCESS_DENIED;
+}
+
+void mac_block_invoke(const char *command, struct redir_conn_t *conn)
+{
+  uint32_t tmp_id = 0;
+  struct blob_buf b = { 0 };
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  ubus_ctx = ubus_connect(NULL);
+  if (!ubus_ctx) {
+    syslog(LOG_WARNING, "Warning: Failed to connect to ubus.");
+    return;
+  }
+
+  int ret = ubus_lookup_id(ubus_ctx, "ip_block", &tmp_id);
+  if (ret) {
+    syslog(LOG_WARNING, "Warning: Failed to find 'ip_block' object.");
+    goto end;
+  }
+
+  blob_buf_init(&b, 0);
+  blobmsg_add_string(&b, "mac", mac);
+  void *r = blobmsg_open_array(&b, "interface");
+  if(_options.dhcpif)
+    blobmsg_add_string(&b, NULL, _options.dhcpif);
+  for (int i = 0; i < MAX_MOREIF; i++) {
+    if(!_options.moreif[i].dhcpif)
+	    continue;
+    blobmsg_add_string(&b, NULL, _options.moreif[i].dhcpif);
+	}
+  blobmsg_close_array(&b, r);
+
+  ubus_invoke(ubus_ctx, tmp_id, command, b.head, NULL, NULL, 1000);
+  blob_buf_free(&b);
+
+end:
+  ubus_free(ubus_ctx);
+}
+
+int authenticator(struct redir_t *redir, struct redir_conn_t *conn, MD5_CTX *context,
+			  uint8_t *user_password, uint8_t *chap_challenge)
+{
+  char username_escaped[REDIR_USERNAMESIZE + 1];
+  int match = ACCESS_DENIED;
+	struct str_luser user;
+  sqlite3 *db;
+
+  if (!_options.usersdbpath)
+    return ACCESS_DENIED;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__, _options.localusers, conn->s_state.redir.username);
+    syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.usersdbpath, conn->s_state.redir.username);
 
-  if (!(f = fopen(_options.localusers, "r"))) {
-    syslog(LOG_ERR, "%s: fopen() failed opening %s!", strerror(errno), _options.localusers);
-    return 0;
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return ACCESS_DENIED;
+  }
+
+  escape_cstr(conn->s_state.redir.username, username_escaped);
+  if (_options.debug)
+    syslog(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
+
+  if (!lusr_get_user(db, &user, username_escaped) &&
+	    !strncmp(user.username, username_escaped, USER_USERNAMENAMESIZE)) {
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+    char *salt = extract_salt(user.password);
+    char *plain_password = strndup((char *)user_password, sizeof(user.password));
+
+    if (salt) {
+      user_password	 = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
+
+      if (!user_password) {
+        syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+          __FUNCTION__, __LINE__, user.username);
+        // When hashing fails, make sure password check fails too
+        user_password = (uint8_t *)strdup("");
+      }
+
+      // Check for hash match, if hashes do not match, try again with MD5 hash
+      if (strncmp((char *)user_password, user.password, sizeof(user.password))) {
+        user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+        if (!user_password) {
+          syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+            __FUNCTION__, __LINE__, user.username);
+          // When hashing fails, make sure password check fails too
+          user_password = (uint8_t *)strdup("");
+        }
+      }
+}
+#endif
+      if (!strncmp((char *)user_password, user.password, sizeof(user.password))) {
+#ifdef HAVE_OPENSSL
+        // Update password hash on the database
+        if(get_hash_type(user.password) == HASH_MD5) {
+          syslog(LOG_INFO, "%s(%d): updating user MD5 hash to SHA-512",
+            __FUNCTION__, __LINE__);
+          // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+          lusr_update_user_pwd(db, &user, username_escaped, plain_password);
+        }
+#endif
+        match = ACCESS_ACCEPTED;
+      }
+
+#ifdef HAVE_OPENSSL
+      // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+      if (salt) {
+        free(user_password);
+        free(salt);
+      }
+      free(plain_password);
+#endif
+    }
+    else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.auth_mode = AUTH_LOCAL_USER;
+      session_param_from_config(&conn->s_params, user.group);
+    }
   }
 
+  if (_options.debug)
+    syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+      conn->s_state.redir.username,
+      match ? "found" : "not found");
+
+  sqlclose(db);
+
+  return match;
+}
+
+int is_local_user(struct redir_t *redir, struct redir_conn_t *conn,
+				  int (*cb_validator) (struct redir_t *, struct redir_conn_t *,
+				  		MD5_CTX *, uint8_t *, uint8_t *))
+{
+  uint8_t user_password[RADIUS_PWSIZE+1];
+  uint8_t chap_challenge[REDIR_MD5LEN];
+  int match=ACCESS_DENIED;
+  MD5_CTX context;
+
   if (_options.debug) {/*debug*/
     char buffer[64];
     redir_chartohex(conn->s_state.redir.uamchal, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
+      syslog(LOG_INFO, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   if (redir->secret && *redir->secret) {
@@ -3003,7 +3632,7 @@
     char buffer[64];
     redir_chartohex(chap_challenge, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
+      syslog(LOG_INFO, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   switch (conn->authdata.type){
@@ -3019,85 +3648,438 @@
             user_password[m] =
                 conn->authdata.v.papmsg.password[m] ^ chap_challenge[n];
       }
+      // Correctly NUL terminate password string
+      size_t len = conn->authdata.v.papmsg.len;
+      if (len >= sizeof(user_password))
+        len = sizeof(user_password) - 1;
+      user_password[len] = 0;
       break;
     case REDIR_AUTH_CHAP:
       memcpy(user_password, conn->authdata.v.chapmsg.password, REDIR_MD5LEN);
       break;
     default:
-      syslog(LOG_ERR, "Authentication method not supported for locally authenticated users: %d",
+      syslog(LOG_INFO, "Authentication method not supported for locally authenticated users: %d",
              conn->authdata.type);
-      fclose(f);
-      return 0;
+      conn->response = REDIR_FAILED_REJECT;
+      return ACCESS_DENIED;
   }
 
   user_password[RADIUS_PWSIZE] = 0;
+  if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_ACCEPTED) {
+  	conn->response = REDIR_SUCCESS;
+  }
+  else if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_DENIED_UDUPCLICATE) {
+  	conn->response = REDIR_FAILED_USER_DUPLICATE;
+  }
+  else{
+    mac_block_invoke("push_mac", conn);
+  	conn->response = REDIR_FAILED_REJECT;
+  }
+
+#ifdef ENABLE_DATABASE
+	if (match == ACCESS_ACCEPTED){
+		if (conn->s_params.maxinputoctets || conn->s_params.maxoutputoctets ||
+				conn->s_params.sessiontimeout) {
+		  match = dbcheck_session(conn);
+		  switch (match){
+			case ACCESS_DENIED_DATA:
+			  conn->response = REDIR_FAILED_DATA;
+			  break;
+			case ACCESS_DENIED_TIME:
+			  conn->response = REDIR_FAILED_TIME;
+			  break;
+			case ACCESS_DENIED_UDUPCLICATE:
+			  conn->response = REDIR_FAILED_USER_DUPLICATE;
+			  break;
+		  }
+		}
+	}
+#endif
+
+  return match;
+}
+
+int dynamic_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+		MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge)
+{
+  char email_escaped[REDIR_USERNAMESIZE + 1];
+  int match = ACCESS_DENIED;
+	struct str_user user;
+  sqlite3 *db;
+
+  if (!_options.usersdbpath)
+    return ACCESS_DENIED;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
-  usernamelen = strlen(conn->s_state.redir.username);
+    syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.usersdbpath, conn->s_state.redir.username);
 
-  line=(char*)malloc(sz);
-  while ((len = getline(&line, &sz, f)) > 0) {
-    if (len > 3 && len < sizeof(u) && line[0] != '#') {
-      char *pl=line,  /* pointer to current line */
-          *pu=u,     /* pointer to username     */
-          *pp=p;     /* pointer to password     */
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return ACCESS_DENIED;
+  }
 
-      /* username until the first ':' */
-      while (*pl && *pl != ':')	*pu++ = *pl++;
+  escape_cstr(conn->s_state.redir.username, email_escaped);
+  if (_options.debug)
+    syslog(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
 
-      /* skip over ':' otherwise error */
-      if (*pl == ':') pl++;
-      else {
-	syslog(LOG_WARNING, "not a valid localusers line: %s", line);
-	continue;
+  if (!usr_get_user(db, &user, email_escaped) &&
+	    !strncmp(user.email, email_escaped, USER_EMAILSIZE)) {
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+    char *salt = extract_salt(user.password);
+    char *plain_password = strndup((char *)user_password, sizeof(user.password));
+
+    if (salt) {
+      user_password	 = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
+
+      if (!user_password) {
+        syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+          __FUNCTION__, __LINE__, user.username);
+        // When hashing fails, make sure password check fails too
+        user_password = (uint8_t *)strdup("");
+      }
+
+      // Check for hash match, if hashes do not match, try again with MD5 hash
+      if (strncmp((char *)user_password, user.password, sizeof(user.password))) {
+        user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+        if (!user_password) {
+          syslog(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+            __FUNCTION__, __LINE__, user.username);
+          // When hashing fails, make sure password check fails too
+          user_password = (uint8_t *)strdup("");
+        }
+      }
+}
+#endif
+      if (!strncmp((char *)user_password, user.password, sizeof(user.password))) {
+#ifdef HAVE_OPENSSL
+        // Update password hash on the database
+        if(get_hash_type(user.password) == HASH_MD5) {
+          syslog(LOG_INFO, "%s(%d): updating user MD5 hash to SHA-512",
+            __FUNCTION__, __LINE__);
+          // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+          usr_update_user_pwd(db, &user, email_escaped, plain_password);
+        }
+#endif
+        match = ACCESS_ACCEPTED;
       }
 
-      /* password until the next ':' */
-      while (*pl && *pl != ':' && *pl != '\n') *pp++ = *pl++;
+#ifdef HAVE_OPENSSL
+      // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+      if (salt) {
+        free(user_password);
+        free(salt);
+      }
+      free(plain_password);
+#endif
+    }
+    else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+    }
 
-      *pu = 0; /* null terminate */
-      *pp = 0;
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.user_time = user.user_time;
+      conn->s_state.redir.auth_mode = AUTH_DYN_USER;
+      session_params_dyn(&conn->s_params);
+      strlcpy(conn->s_state.redir.username, user.email, USER_EMAILSIZE);
+    }
+  }
 
-      if (usernamelen == strlen(u) &&
-	  !strncmp(conn->s_state.redir.username, u, usernamelen)) {
+  if (_options.debug)
+    syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+      conn->s_state.redir.username, match ? "found" : "not found");
 
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): found %s, checking password", __FUNCTION__, __LINE__, u);
+  sqlclose(db);
+
+  return match;
+}
 
-	if (conn->authdata.type == REDIR_AUTH_PAP) {
-	  if (!strcmp((char*)user_password, p))
-	    match = 1;
+int sms_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+						   MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+	char user_pass_escaped[RADIUS_PWSIZE + 1];
+	int match = ACCESS_DENIED;
+	struct str_sms_user user = {0};
+	sqlite3 *db;
+
+	if (!_options.usersdbpath)
+		return ACCESS_DENIED;
+
+	if (_options.debug)
+		syslog(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+			   _options.usersdbpath, conn->s_state.redir.username);
+
+	if (!(db = sqlopen(_options.usersdbpath))) {
+		syslog(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+		return ACCESS_DENIED;
 	}
-	else if (conn->authdata.type == REDIR_AUTH_CHAP) {
-	  uint8_t tmp[REDIR_MD5LEN];
-	  MD5Init(&context);
-	  MD5Update(&context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
-	  MD5Update(&context, (uint8_t*)p, strlen(p));
-	  MD5Update(&context, chap_challenge, REDIR_MD5LEN);
-	  MD5Final(tmp, &context);
-
-	  if (!memcmp(user_password, tmp,  REDIR_MD5LEN))
-	    match = 1;
-	  else {
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): bad password for %s", __FUNCTION__, __LINE__, u);
-	  }
+  
+	user_password[USER_RAND_PASSWORD_LEN] = 0;
+	escape_cstr((char *) user_password, user_pass_escaped);
+    if (_options.debug)
+      syslog(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, user_pass_escaped);
+
+	if (!usr_get_sms_user(db, &user, user_pass_escaped) && user.username[0] != '\0') {
+    if (user.used != 0) {
+      match = ACCESS_DENIED;
+    } else if (_options.duplicateusers && find_active_user(user.username)) {
+      syslog(LOG_INFO, "%s(%d): Found duplication on username: %s", __FUNCTION__, __LINE__, user.username);
+      match = ACCESS_DENIED_UDUPCLICATE;
+    }
+    else {
+      if (_options.duplicateusers) {
+        syslog(LOG_INFO, "%s(%d): Duplication on username %s was not found", __FUNCTION__, __LINE__, user.username);
+      }
+      if (_options.debug)
+        syslog(LOG_INFO, "%s(%d): found %s ", __FUNCTION__, __LINE__, user.username);
+
+      if (conn->authdata.type == REDIR_AUTH_PAP) {
+          if (!strncmp((char *) user_password, user.password, USER_RAND_PASSWORD_LEN))
+              match = ACCESS_ACCEPTED;
+      } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+          match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+      }
+
+      if (match == ACCESS_ACCEPTED) {
+        conn->s_state.redir.user_time = user.user_time;
+        conn->s_state.redir.auth_mode = AUTH_SMS_USER;
+        strncpy(conn->s_state.redir.username, user.username, USER_RAND_USERNAME_LEN);
+        strlcpy(conn->s_state.redir.phone, user.phone, sizeof(conn->s_state.redir.phone));
+        session_params_dyn(&conn->s_params);
+
+        uint32_t timestamp = (uint32_t)mainclock_now();
+        usr_update_sms_user(db, &user, user.phone, conn->hismac, timestamp, NULL);
+      }
+    }
 	}
 
-	break;
+	if (_options.debug)
+		syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+			   conn->s_state.redir.username, match ? "found" : "not found");
+
+	sqlclose(db);
+
+	return match;
+}
+
+int mac_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+                           MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+  int match = ACCESS_DENIED;
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  if (_options.macpass) {
+    if (_options.debug)
+      syslog(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, _options.macpass);
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+      if (!strcmp((char *) user_password, _options.macpass))
+        match = ACCESS_ACCEPTED;
+    } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, _options.macpass);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+      session_params_dyn(&conn->s_params);
+    }
+
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, match ? "found" : "not found");
+  }
+  else {
+    conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+    session_params_dyn(&conn->s_params);
+    match = ACCESS_ACCEPTED;
+  }
+
+  return match;
+}
+
+int trial_user_authenticator(struct redir_conn_t *conn) {
+  char mac[MACSTRLEN+7];
+
+  snprintf(mac, sizeof(mac), "trial-"MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  conn->s_state.redir.auth_mode = AUTH_TRIAL_USER;
+  session_params_trial(&conn->s_params);
+
+  return ACCESS_ACCEPTED;
+}
+
+#ifdef USING_CURL
+int sso_user_authenticator(struct redir_conn_t *conn) {
+  char callback_url[256];
+  _oauth2_session oauth2_session = { 0 };
+
+  if (_options.uamuissl && _options.uamuiport) {
+    if (_options.uamaliasname && _options.domain) {
+      if (_options.redirssl) {
+        sprintf(callback_url, "https://%s.%s/ssocallback",
+              _options.uamaliasname,
+              _options.domain);
+      } else {
+        sprintf(callback_url, "https://%s.%s:%d/ssocallback",
+              _options.uamaliasname,
+              _options.domain,
+              _options.uamuiport);
       }
+    } else {
+      sprintf(callback_url, "https://%s:%d/ssocallback", inet_ntoa(_options.uamlisten), _options.uamuiport);
     }
+  } else if (_options.uamaliasname && _options.domain) {
+    sprintf(callback_url, "http://%s.%s/ssocallback",
+                  _options.uamaliasname,
+                  _options.domain);
+  } else {
+    sprintf(callback_url, "%shttp://%s:%d/ssocallback", _options.oidcforcehttps ? "https://redirectmeto.com/" : "",
+      inet_ntoa(_options.uamlisten), _options.uamport);
   }
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
-           conn->s_state.redir.username,
-           match ? "found" : "not found");
+  oauth2_set_parameter_list(&oauth2_session,
+    OAUTH2_OPT_RESPONSE_TYPE, OAUTH2_RESPONSE_TYPE_CODE,
+    OAUTH2_OPT_OIDC_ENDPOINT, _options.oidcdiscoveryurl,
+    OAUTH2_OPT_CLIENT_ID, _options.oidcclientid,
+    OAUTH2_OPT_CLIENT_SECRET, _options.oidcclientsecret,
+    OAUTH2_OPT_REDIRECT_URI, callback_url,
+    OAUTH2_OPT_CODE, conn->s_state.redir.code,
+    OAUTH2_OPT_NONE);
+
+  if (oauth2_get_openid_config(&oauth2_session) != OAUTH2_OK) {
+   if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Failed get oauth2 openid configuration",
+             __FUNCTION__, __LINE__);
+    return ACCESS_DENIED;
+  }
 
-  fclose(f);
-  free(line);
-  return match;
+  if (oauth2_exchange_token(&oauth2_session) != OAUTH2_OK) {
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Failed to validate oauth2 code exchange",
+             __FUNCTION__, __LINE__);
+    return ACCESS_DENIED;
+  }
+
+  if (oauth2_get_userinfo(&oauth2_session) != OAUTH2_OK) {
+    if (_options.debug)
+      syslog(LOG_DEBUG, "%s(%d): Failed to get oauth2 user information",
+             __FUNCTION__, __LINE__);
+    if (!oauth2_session.username || oauth2_session.username[0] == '\0')
+      return ACCESS_DENIED;
+  }
+
+  if (oauth2_session.username && oauth2_session.username[0] != '\0') {
+    strlcpy(conn->s_state.redir.username, oauth2_session.username, USERNAMESIZE);
+  } else {
+    char username[USER_USERNAMENAMESIZE + 1];
+    if (usr_random_hex(username, USER_RAND_USERNAME_LEN)) {
+      return ACCESS_DENIED;
+    }
+    strlcpy(conn->s_state.redir.username, username, USERNAMESIZE);
+  }
+
+  conn->s_state.redir.auth_mode = AUTH_SSO_USER;
+  session_params_dyn(&conn->s_params);
+
+  oauth2_clean_session(&oauth2_session);
+  return ACCESS_ACCEPTED;
+}
+#endif
+
+int authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int dynamic_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = dynamic_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int sms_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = sms_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int mac_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = mac_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
 }
 
 /* redir_accept() does the following:
@@ -3345,7 +4327,7 @@
 
   /* We are forked when the redir_request is null */
   int forked = (rreq == 0);
-  int err;
+  int err, ret;
 
 
   memset(&httpreq,0,sizeof(httpreq));
@@ -3397,6 +4379,7 @@
   memset(hexchal, 0, sizeof(hexchal));
   memset(&conn, 0, sizeof(conn));
   memset(&msg, 0, sizeof(msg));
+  conn.s_state.redir.tos = 0;
 
   socket.fd[0] = infd;
   socket.fd[1] = outfd;
@@ -3561,8 +4544,8 @@
                                 || isWPAD
 #endif
                                 )) {
-          char *ctype = "text/plain";
-          char *filename = conn.wwwfile;
+          const char *ctype = "text/plain";
+          const char *filename = conn.wwwfile;
           size_t namelen = strlen(filename);
           int parse = 0;
 
@@ -3582,7 +4565,7 @@
             } else
 #endif
             {
-              char *p;
+              const char *p;
               int cnt = 0;
               for (p=filename; *p; p++) {
                 if (*p == '.' || *p == '_'|| *p == '-' || *p == '/') {
@@ -3889,6 +4872,18 @@
 
   /* default hexchal for use in replies */
   redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
+  if (_options.smsusers && _options.usersdbpath){
+    sqlite3 *db;
+    conn.s_state.redir.otp_state = 0;
+    if ((db = sqlopen(_options.usersdbpath))) {
+      struct str_sms_user user = {0};
+      if (usr_sms_user_exists(db, NULL, conn.hismac) == USER_RET_ALREADY && \
+          !usr_get_sms_user_phone(db, &user, NULL, conn.hismac) && user.used == 0) {
+        conn.s_state.redir.otp_state = 1;
+      }
+      sqlclose(db);
+    }
+  }
 
   switch (conn.type) {
 
@@ -3897,21 +4892,17 @@
 
       /* Was client was already logged on? */
       if (state == 1) {
-
         if (splash) {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
           reauth = 1;
-
         } else {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
 
           redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
                       NULL, NULL, conn.s_state.redir.userurl, NULL,
-                      (char *)conn.s_params.url, conn.hismac,
+                      (char *) conn.s_params.url, conn.hismac,
                       &conn.hisip, httpreq.qs);
 
           return redir_main_exit(&socket, forked, rreq);
@@ -3920,11 +4911,11 @@
 
       /* Did the challenge expire? */
       if (_options.challengetimeout2 &&
-          (conn.s_state.uamtime + _options.challengetimeout2) <
-          mainclock_now()) {
+        (conn.s_state.uamtime + _options.challengetimeout2) <
+        mainclock_now()) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
-                 (long) conn.s_state.uamtime, (long) mainclock_now());
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                   (long) conn.s_state.uamtime, (long) mainclock_now());
 
         redir_memcopy(REDIR_CHALLENGE);
         redir_msg_send(REDIR_MSG_OPT_REDIR);
@@ -3936,74 +4927,204 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
-      if (is_local_user(redir, &conn)) {
-        session_param_defaults(&conn.s_params);
-        conn.response = REDIR_SUCCESS;
-      }
-      else {
+	  if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		if (_options.localusers) {
+			if ((ret = is_local_user(redir, &conn, authenticator)) == ACCESS_ACCEPTED) {
+              session_param_defaults(&conn.s_params);
+            }
+			else if (_options.registerusers && conn.response == REDIR_FAILED_REJECT) {
+				ret = is_local_user(redir, &conn, dynamic_user_authenticator);
+			}
+
+		} else if (_options.smsusers) {
+		    if (is_local_user(redir, &conn, sms_user_authenticator) == ACCESS_ACCEPTED) {
+		      session_param_defaults(&conn.s_params);
+		    }
+    } else if (_options.macusers) {
+      is_local_user(redir, &conn, mac_user_authenticator);
+		} else {
 
 #ifdef ENABLE_MODULES
-        int i;
-        int flags = 0;
+			int i;
+			int flags = 0;
 #endif
 
-        if (!forked) {
-          /*
-           *  When waiting for RADIUS, we need to be forked.
-           *  TODO: make redir_radius asynchronous.
-           */
-          pid_t forkpid = redir_fork(infd, outfd);
-          if (forkpid) { /* parent or error */
-            return redir_main_exit(&socket, forked, rreq);
-          }
-        }
+			if (!forked) {
+				/*
+				 *  When waiting for RADIUS, we need to be forked.
+				 *  TODO: make redir_radius asynchronous.
+				 */
+				pid_t forkpid = redir_fork(infd, outfd);
+				if (forkpid) { /* parent or error */
+					return redir_main_exit(&socket, forked, rreq);
+				}
+			}
 
 #ifdef ENABLE_MODULES
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
-        for (i=0; i < MAX_MODULES; i++) {
-          if (!_options.modules[i].name[0]) break;
-          if (_options.modules[i].ctx) {
-            struct chilli_module *m =
-                (struct chilli_module *)_options.modules[i].ctx;
-            if (m->redir_login) {
-              int modresult = m->redir_login(redir, &conn, &socket);
-              flags |= modresult;
-              switch(chilli_mod_state(modresult)) {
-                case CHILLI_MOD_ERROR:
-                  return redir_main_exit(&socket, forked, rreq);
-                default:
-                  break;
+            if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
+            for (i=0; i < MAX_MODULES; i++) {
+              if (!_options.modules[i].name[0]) break;
+              if (_options.modules[i].ctx) {
+                struct chilli_module *m =
+                    (struct chilli_module *)_options.modules[i].ctx;
+                if (m->redir_login) {
+                  int modresult = m->redir_login(redir, &conn, &socket);
+                  flags |= modresult;
+                  switch(chilli_mod_state(modresult)) {
+                    case CHILLI_MOD_ERROR:
+                      return redir_main_exit(&socket, forked, rreq);
+                    default:
+                      break;
+                  }
+                }
               }
             }
-          }
-        }
-        if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
-          if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
-        } else {
+			if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
+			  if (_options.debug)
+				syslog(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
+			} else {
 #endif
 
-          termstate = REDIR_TERM_RADIUS;
+			termstate = REDIR_TERM_RADIUS;
+
+			if (optionsdebug)
+				syslog(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
 
-          if (optionsdebug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
+			redir_radius(redir, &address->sin_addr, &conn, reauth);
+			termstate = REDIR_TERM_REPLY;
 
-          redir_radius(redir, &address->sin_addr, &conn, reauth);
-          termstate = REDIR_TERM_REPLY;
+      if (conn.response != REDIR_SUCCESS) {
+        mac_block_invoke("push_mac", &conn);
+      }
 
 #ifdef ENABLE_MODULES
-        }
+			}
 #endif
 
 #if(_debug_ > 1)
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
+			if (_options.debug)
+			  syslog(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
 #endif
-      }
+		}
+    if (conn.response == REDIR_SUCCESS) {
+      mac_block_invoke("unblock_mac", &conn);
+    }
+	  }
 
       if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
+        conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
+
+        if (reauth) {
+          conn.s_params.flags |= IS_UAM_REAUTH;
+        }
+
+        msg.mtype = REDIR_LOGIN;
+
+        if (_options.debug)
+          syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+//        if (_options.successuserurl || _options.successurlcustom){
+            bstring successurl;
+            successurl = bfromcstralloc(1024,"");
+            if (_options.successuserurl)
+                bcatcstr(successurl, conn.s_state.redir.userurl);
+            else if (_options.successurlcustom)
+                bcatcstr(successurl, _options.successurlcustom);
+            else
+                successurl = NULL;
+
+            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
+                        conn.s_params.sessiontimeout, NULL,
+                        conn.s_state.redir.username,
+                        conn.s_state.redir.userurl, conn.reply,
+                        (char *)conn.s_params.url,
+                        conn.hismac, &conn.hisip, httpreq.qs);
+            bdestroy(successurl);
+//        } else {
+//            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+//                        conn.s_params.sessiontimeout, NULL,
+//                        conn.s_state.redir.username,
+//                        conn.s_state.redir.userurl, conn.reply,
+//                        (char *)conn.s_params.url,
+//                        conn.hismac, &conn.hisip, httpreq.qs);
+//        }
+
+        /* set params and redir data */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
+
+      } else { /* Access-Reject */
+        int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+        if (_options.debug)
+          syslog(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
 
+        if (!hasnexturl) {
+          if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+        } else {
+          msg.mtype = REDIR_NOTYET;
+        }
+
+        redir_reply(redir, &socket, &conn, conn.response,
+                    NULL,
+                    0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                    (char *)conn.s_params.url, conn.hismac,
+                    &conn.hisip, httpreq.qs);
+
+        /* set params, redir data, and reset session-id */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                       (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+      }
+
+      if (_options.debug)
+        syslog(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+      return redir_main_exit(&socket, forked, rreq);
+    }
+
+    case REDIR_TRIAL: {
+      char reauth = 0;
+
+      /* Was client was already logged on? */
+      if (state == 1) {
+        if (splash) {
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+          reauth = 1;
+        } else {
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+          redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                      NULL, NULL, conn.s_state.redir.userurl, NULL,
+                      (char *) conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+      }
+
+      //Setting conn.response here.
+      if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		  if (_options.trialusers && trial_user_authenticator(&conn)) {
+			  conn.response = REDIR_SUCCESS;
+#ifdef ENABLE_DATABASE
+			  if (conn.s_params.maxinputoctets || conn.s_params.maxoutputoctets ||
+					  conn.s_params.sessiontimeout) {
+				switch (dbcheck_session(&conn)){
+				  case ACCESS_DENIED_DATA:
+					conn.response = REDIR_TRIAL_FAILED_DATA;
+					break;
+				  case ACCESS_DENIED_TIME:
+					conn.response = REDIR_TRIAL_FAILED_TIME;
+					break;
+				}
+			  }
+#endif
+		  }
+	  }
+
+      if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
         conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
 
         if (reauth) {
@@ -4015,18 +5136,28 @@
         if (_options.debug)
           syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
 
-        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+//        if (_options.successuserurl || _options.successurlcustom){
+        bstring successurl;
+        successurl = bfromcstralloc(1024,"");
+        if (_options.successuserurl)
+          bcatcstr(successurl, conn.s_state.redir.userurl);
+        else if (_options.successurlcustom)
+          bcatcstr(successurl, _options.successurlcustom);
+        else
+          successurl = NULL;
+
+        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
                     conn.s_params.sessiontimeout, NULL,
                     conn.s_state.redir.username,
                     conn.s_state.redir.userurl, conn.reply,
                     (char *)conn.s_params.url,
                     conn.hismac, &conn.hisip, httpreq.qs);
+        bdestroy(successurl);
 
         /* set params and redir data */
         redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
 
       } else { /* Access-Reject */
-
         int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
 
         if (_options.debug)
@@ -4034,9 +5165,9 @@
 
         if (!hasnexturl) {
           if (_options.challengetimeout)
-            redir_memcopy(REDIR_CHALLENGE);
+          redir_memcopy(REDIR_CHALLENGE);
         } else {
-          msg.mtype = REDIR_NOTYET;
+          msg.mtype = REDIR_TRIALLOGIN_FAILED;
         }
 
         redir_reply(redir, &socket, &conn, conn.response,
@@ -4148,6 +5279,316 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
+    case REDIR_SIGNUP:
+		if (_options.registerusers)
+			usr_add_user(&conn);
+
+		redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+			  hexchal, NULL, conn.s_state.redir.userurl, NULL,
+			  NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+      return redir_main_exit(&socket, forked, rreq);
+    case REDIR_SMSSIGNUP:
+    	{
+    		if (_options.smsusers) {
+				int ret;
+
+				if (strlen(conn.s_state.redir.phone) < USER_MIN_PHONE_LEN) {
+					conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else if ((ret = usr_add_sms_user(&conn, conn.s_state.redir.phone, hexchal))) {
+					if (ret == USER_RET_ALREADY)
+						conn.response = REDIR_SMSSIGNUP_ALREADY;
+					else if (ret == USER_RET_SMS_ERR)
+						conn.response = REDIR_SMSSIGNUP_SMS_FAIL;
+					else
+						conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else {
+					conn.response = REDIR_SMSSIGNUP_SUCCESS;
+				}
+			}
+
+			redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+						hexchal, NULL, conn.s_state.redir.userurl, NULL,
+						NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+			return redir_main_exit(&socket, forked, rreq);
+		}
+#ifdef USING_CURL
+    case REDIR_SSOCALLBACK:
+      {
+        char reauth = 0;
+
+        /* Was client was already logged on? */
+        if (state == 1) {
+          if (splash) {
+            if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+            reauth = 1;
+          } else {
+            if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+            redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                        NULL, NULL, conn.s_state.redir.userurl, NULL,
+                        (char *) conn.s_params.url, conn.hismac,
+                        &conn.hisip, httpreq.qs);
+
+            return redir_main_exit(&socket, forked, rreq);
+          }
+        }
+
+        /* Did the challenge expire? */
+        if (_options.challengetimeout2 &&
+          (conn.s_state.uamtime + _options.challengetimeout2) <
+          mainclock_now()) {
+          if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                    (long) conn.s_state.uamtime, (long) mainclock_now());
+
+          redir_memcopy(REDIR_CHALLENGE);
+          redir_msg_send(REDIR_MSG_OPT_REDIR);
+
+          redir_reply(redir, &socket, &conn, REDIR_FAILED_OTHER, NULL,
+                      0, hexchal, NULL, NULL, NULL,
+                      0, conn.hismac, &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        if (_options.oidc) {
+          if (sso_user_authenticator(&conn)) {
+            conn.response = REDIR_SUCCESS;
+  #ifdef ENABLE_DATABASE
+            if (conn.s_params.maxinputoctets || conn.s_params.maxoutputoctets ||
+                    conn.s_params.sessiontimeout) {
+              switch (dbcheck_session(&conn)){
+                case ACCESS_DENIED_DATA:
+                  conn.response = REDIR_FAILED_DATA;
+                  break;
+                case ACCESS_DENIED_TIME:
+                  conn.response = REDIR_FAILED_TIME;
+                  break;
+              }
+            }
+  #endif
+          } else {
+            conn.response = REDIR_SSO_FAILED;
+            mac_block_invoke("push_mac", &conn);
+          }
+        } else {
+          conn.response = REDIR_SSO_DENIED;
+        }
+
+        if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
+          mac_block_invoke("unblock_mac", &conn);
+          conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
+
+          if (reauth) {
+            conn.s_params.flags |= IS_UAM_REAUTH;
+          }
+
+          msg.mtype = REDIR_LOGIN;
+
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+          bstring successurl;
+          successurl = bfromcstralloc(1024,"");
+          if (_options.successuserurl)
+            bcatcstr(successurl, conn.s_state.redir.userurl);
+          else if (_options.successurlcustom)
+            bcatcstr(successurl, _options.successurlcustom);
+          else
+            successurl = NULL;
+
+          redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
+                      conn.s_params.sessiontimeout, NULL,
+                      conn.s_state.redir.username,
+                      conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url,
+                      conn.hismac, &conn.hisip, httpreq.qs);
+          bdestroy(successurl);
+
+          /* set params and redir data */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
+
+        } else { /* Access-Reject */
+          int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+
+          if (!hasnexturl) {
+            if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+          } else {
+            msg.mtype = REDIR_SSO_FAILED;
+          }
+
+          redir_reply(redir, &socket, &conn, conn.response,
+                      NULL,
+                      0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          /* set params, redir data, and reset session-id */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                        (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+        }
+
+        if (_options.debug)
+          syslog(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+        return redir_main_exit(&socket, forked, rreq);
+      }
+    case REDIR_SSOLOGIN:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid ||
+            !_options.oidcclientsecret || (_options.tos && conn.response == REDIR_FAILED_TOS)) {
+          int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+
+          if (!hasnexturl) {
+            if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+          } else {
+            msg.mtype = REDIR_SSO_FAILED;
+          }
+
+          redir_reply(redir, &socket, &conn, conn.response,
+                      NULL,
+                      0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          /* set params, redir data, and reset session-id */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                        (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        if (state == 1 && !splash) {
+          if (_options.debug)
+            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+          redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                      NULL, NULL, conn.s_state.redir.userurl, NULL,
+                      (char *) conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        /* Did the challenge expire? */
+        if (_options.challengetimeout2 &&
+          (conn.s_state.uamtime + _options.challengetimeout2) <
+          mainclock_now()) {
+          if (_options.debug)
+              syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                    (long) conn.s_state.uamtime, (long) mainclock_now());
+
+          redir_memcopy(REDIR_CHALLENGE);
+          redir_msg_send(REDIR_MSG_OPT_REDIR);
+
+          redir_reply(redir, &socket, &conn, REDIR_FAILED_OTHER, NULL,
+                      0, hexchal, NULL, NULL, NULL,
+                      0, conn.hismac, &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        char callback_url[256];
+        char chal_buffer[64];
+        _oauth2_session oauth2_session = { 0 };
+
+        if (_options.uamuissl && _options.uamuiport) {
+          if (_options.uamaliasname && _options.domain) {
+            if (_options.redirssl) {
+              sprintf(callback_url, "https://%s.%s/ssocallback",
+                    _options.uamaliasname,
+                    _options.domain);
+            } else {
+              sprintf(callback_url, "https://%s.%s:%d/ssocallback",
+                    _options.uamaliasname,
+                    _options.domain,
+                    _options.uamuiport);
+            }
+          } else {
+            sprintf(callback_url, "https://%s:%d/ssocallback", inet_ntoa(_options.uamlisten), _options.uamuiport);
+          }
+        } else if (_options.uamaliasname && _options.domain) {
+          sprintf(callback_url, "http://%s.%s/ssocallback",
+                        _options.uamaliasname,
+                        _options.domain);
+        } else {
+          sprintf(callback_url, "%shttp://%s:%d/ssocallback", _options.oidcforcehttps ? "https://redirectmeto.com/" : "",
+            inet_ntoa(_options.uamlisten), _options.uamport);
+        }
+
+        redir_chartohex(conn.s_state.redir.uamchal, chal_buffer, REDIR_MD5LEN);
+
+        oauth2_set_parameter_list(&oauth2_session,
+          OAUTH2_OPT_RESPONSE_TYPE, OAUTH2_RESPONSE_TYPE_CODE,
+          OAUTH2_OPT_OIDC_ENDPOINT, _options.oidcdiscoveryurl,
+          OAUTH2_OPT_CLIENT_ID, _options.oidcclientid,
+          OAUTH2_OPT_CLIENT_SECRET, _options.oidcclientsecret,
+          OAUTH2_OPT_REDIRECT_URI, callback_url,
+          OAUTH2_OPT_SCOPE, "openid email profile",
+          OAUTH2_OPT_STATE, chal_buffer,
+          OAUTH2_OPT_NONE);
+
+        if (oauth2_get_openid_config(&oauth2_session) != OAUTH2_OK ||
+            oauth2_build_authorization_url(&oauth2_session) != OAUTH2_OK) {
+          oauth2_clean_session(&oauth2_session);
+          snprintf(buffer, bufsize, "HTTP/1.0 403 Forbidden\r\n\r\n");
+          redir_write(&socket, buffer, strlen(buffer));
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        bstring buffer1 = bfromcstralloc(1024, "");
+        if (!buffer1) {
+          syslog(LOG_ERR, "%s: bfromcstralloc() memory allocation error.", __FUNCTION__);
+          return -1;
+        }
+
+        redir_http(buffer1, "302 Moved Temporarily");
+        bcatcstr(buffer1, "Location: ");
+
+        bconcat(buffer1, bfromcstr(oauth2_session.authorization_url));
+
+        bcatcstr(buffer1, "\r\nContent-Type: text/html; charset=UTF-8\r\n");
+
+        bstring bbody1 = bfromcstralloc(512, "<HTML><BODY><H2>Browser error!</H2>"
+                    "Browser does not support redirects!</BODY>\r\n");
+
+        bcatcstr(bbody1, "\r\n</HTML>\r\n");
+
+        bstring bt1 = bfromcstralloc(128, "");
+        bassignformat(bt1, "Content-Length: %d\r\n", blength(bbody1));
+        bconcat(buffer1, bt1);
+
+        bcatcstr(buffer1, "\r\n"); /* end of headers */
+        bconcat(buffer1, bbody1);
+
+        bdestroy(bbody1);
+        bdestroy(bt1);
+
+        if (redir_write(&socket, (char *)buffer1->data, buffer1->slen) < 0) {
+          syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+          bdestroy(buffer1);
+          oauth2_clean_session(&oauth2_session);
+          return -1;
+        }
+        bdestroy(buffer1);
+        oauth2_clean_session(&oauth2_session);
+
+        return redir_main_exit(&socket, forked, rreq);
+      }
+#endif
     case REDIR_MSDOWNLOAD:
       snprintf(buffer, bufsize, "HTTP/1.0 403 Forbidden\r\n\r\n");
       redir_write(&socket, buffer, strlen(buffer));
@@ -4314,11 +5755,8 @@
     redir_memcopy(REDIR_CHALLENGE);
     redir_msg_send(REDIR_MSG_OPT_REDIR);
   }
-  else {
-    redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
-    msg.mtype = splash ? REDIR_ALREADY : REDIR_NOTYET;
-    redir_msg_send(REDIR_MSG_OPT_REDIR);
-  }
+
+  redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
 
 #if(_debug_ > 1)
   if (_options.debug)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/redir.h src/src/redir.h
--- upstream/src/redir.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.h	2025-07-03 10:02:27.000000000 +0000
@@ -45,6 +45,11 @@
 #define REDIR_SPLASH          8
 #define REDIR_MACREAUTH       9
 #define REDIR_REQERROR       10  /* Used internally when the HTTP request parsing created an error */
+#define REDIR_SIGNUP		11
+#define REDIR_SMSSIGNUP		12
+#define REDIR_TRIAL			13
+#define REDIR_SSOLOGIN     14
+#define REDIR_SSOCALLBACK 15
 
 #define REDIR_WWW            20
 #ifdef ENABLE_EWTAPI
@@ -70,6 +75,25 @@
 #define REDIR_FAILED_NOROUTE 60 /* Reply to /logon - no route for NAI */
 #define REDIR_ERROR_PROTOCOL 61 /* Reply to /logon - the client software is not matching the protocol (e.g. WISPr 1.0 or WISPr 2.0) */
 #define REDIR_CHALLENGE      62 /* Reply to /logon - if Radius challenge received in EAP authentication */
+#define REDIR_FAILED_DATA	 63 /* Reply to /logon if data limit reached */
+#define REDIR_FAILED_TIME	 64 /* Reply to /logon if time limit reached */
+#define REDIR_SIGNUP_FAILED	 65 /* Reply to /signup if no username or password found */
+#define REDIR_SIGNUP_SUCCESS 66 /* Reply to /signup user registered successfully */
+#define REDIR_SIGNUP_ALREADY 67 /* Reply to /signup user registered unsuccessfully */
+#define REDIR_SIGNUP_DENIED 68 /* Reply to /signup if method is disabled */
+#define REDIR_SMSSIGNUP_FAILED 69 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_ALREADY 70 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_SUCCESS 71 /* Reply to /smssignup user registered successfully */
+#define REDIR_SMSSIGNUP_SMS_FAIL 72 /* Reply to /smssignup user registered unsuccessfully (sms failure) */
+#define REDIR_SMSSIGNUP_DENIED 73 /* Reply to /smssignup if method is disabled */
+#define REDIR_FAILED_TOS 74 /* Reply to /logon - the client does not accepted TOS */
+#define REDIR_TRIALLOGIN_DENIED 75 /* Reply to /trial - method not allowed */
+#define REDIR_TRIALLOGIN_FAILED 76 /* Reply to /trial - login failed */
+#define REDIR_TRIAL_FAILED_DATA	 77 /* Reply to /trial if data limit reached */
+#define REDIR_TRIAL_FAILED_TIME	 78 /* Reply to /trial if time limit reached */
+#define REDIR_FAILED_USER_DUPLICATE	 79 /* Reply to /logon if user duplicates with other */
+#define REDIR_SSO_DENIED 80 /* Reply to /ssocallback - method not allowed */
+#define REDIR_SSO_FAILED 81 /* Reply to /ssocallback - login failed */
 
 /* If more than one format flag is set, it indicates that Coova advertises several
    protocols that can be used by the client. Once the client has choosen which protocol
@@ -92,6 +116,19 @@
 #define REDIR_MSG_OPT_PARAMS  2
 #define REDIR_MSG_NSESSIONID  4
 
+#define ACCESS_DENIED 0
+#define ACCESS_ACCEPTED 1
+#define ACCESS_DENIED_DATA 2
+#define ACCESS_DENIED_TIME 3
+#define ACCESS_DENIED_UDUPCLICATE 4
+
+#define AUTH_LOCAL_USER 0
+#define AUTH_DYN_USER 1
+#define AUTH_SMS_USER 2
+#define AUTH_MAC_USER 3
+#define AUTH_TRIAL_USER 4
+#define AUTH_SSO_USER 5
+
 struct eapmsg_t {
   uint16_t len;
   uint8_t data[MAX_EAP_LEN];
@@ -156,6 +193,10 @@
    */
   struct session_params s_params;
   struct session_state s_state;
+#ifdef ENABLE_DATABASE
+    struct session_history s_history;		/*Session history*/
+#endif
+
 } __attribute__((packed));
 
 /* HTTP request parsing context */
@@ -243,7 +284,7 @@
   int uiport;
 #endif
 
-  int starttime;
+  time_t starttime;
 
   char *url;
   char *homepage;
@@ -353,4 +394,9 @@
 
 ssize_t redir_write(struct redir_socket_t *sock, char *buf, size_t len);
 
+int authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int dynamic_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int sms_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int mac_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+
 #endif	/* !_REDIR_H */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/session.c src/src/session.c
--- upstream/src/session.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.c	2025-07-03 10:02:27.000000000 +0000
@@ -68,16 +68,16 @@
   bcatcstr(json,"\",\"userName\":\"");
   bcatcstr(json,state->redir.username);
   bcatcstr(json, "\",\"startTime\":");
-  bassignformat(tmp, "%ld", (long) mainclock_towall(init ? mainclock_now() : starttime));
+  bassignformat(tmp, "%"PRId64, (uint64_t) mainclock_towall(init ? mainclock_now() : starttime));
   bconcat(json, tmp);
   bcatcstr(json,",\"sessionTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->sessiontimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessiontimeout);
   bconcat(json, tmp);
   bcatcstr(json,",\"terminateTime\":");
-  bassignformat(tmp, "%ld", (long) params->sessionterminatetime);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessionterminatetime);
   bconcat(json, tmp);
   bcatcstr(json,",\"idleTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->idletimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->idletimeout);
   bconcat(json, tmp);
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && state->tag8021q) {
@@ -101,6 +101,11 @@
     bassignformat(tmp, "%lld", params->maxtotaloctets);
     bconcat(json, tmp);
   }
+  if (params->warningoctets) {
+    bcatcstr(json,",\"warningOctets\":");
+    bassignformat(tmp, "%lld", params->warningoctets);
+    bconcat(json, tmp);
+  }
 
   bdestroy(tmp);
   return 0;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/session.h src/src/session.h
--- upstream/src/session.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.h	2025-07-03 10:02:27.000000000 +0000
@@ -25,7 +25,6 @@
 #include "garden.h"
 
 struct session_params {
-  uint8_t url[REDIR_USERURLSIZE];
   uint8_t filteridbuf[256];
   uint8_t filteridlen;
   uint8_t routeidx;
@@ -34,10 +33,20 @@
   uint64_t maxinputoctets;
   uint64_t maxoutputoctets;
   uint64_t maxtotaloctets;
+  uint64_t warningoctets; /* Data amount over which an SMS warning is sent */
   uint64_t sessiontimeout;
   uint32_t idletimeout;
   uint16_t interim_interval;     /* Seconds. 0 = No interim accounting */
   time_t sessionterminatetime;
+  int period; /* Data limit period */
+  int start;  /* Data limit start point */
+  uint64_t expiration;  /* Expiration time for dynamically allocated users */
+  uint32_t padding;
+  uint8_t url[REDIR_USERURLSIZE];
+
+#define PERIOD_DAY 1
+#define PERIOD_WEEK 2
+#define PERIOD_MONTH 3
 
 #define REQUIRE_UAM_AUTH   (1<<0)
 #define REQUIRE_UAM_SPLASH (1<<1)
@@ -63,6 +72,9 @@
   struct in_addr dns1;
 #endif
 
+  struct in_addr tcp_reset_addr[MAX_PASS_THROUGHS * 2];
+  uint32_t num_tcp_reset_addr;
+
 #ifdef ENABLE_SESSGARDEN
   pass_through pass_throughs[SESSION_PASS_THROUGH_MAX];
   uint32_t pass_through_count;
@@ -74,27 +86,26 @@
 
   char username[REDIR_USERNAMESIZE];
   char userurl[REDIR_USERURLSIZE];
+  char phone[64];
+  char email[128];
+  char signup_password[128];
+#ifdef USING_CURL
+  char code[4096];
+#endif
 
   uint8_t uamchal[REDIR_MD5LEN];
 
-  /* To store the RADIUS CLASS attribute received in the Access Accept */
-  uint8_t classbuf[RADIUS_ATTR_VLEN];
-  size_t classlen;
-
-  /* To store the RADIUS CUI attribute received in the Access Accept */
-  uint8_t cuibuf[RADIUS_ATTR_VLEN];
-  size_t cuilen;
-
-  /* To store the RADIUS STATE attribute between Radius requests */
-  uint8_t statebuf[RADIUS_ATTR_VLEN];
-  uint8_t statelen;
-
   /*  EAP identity of the last request sent */
   uint8_t eap_identity;
 
   /* UAM protocol used */
   uint8_t uamprotocol;
 
+  uint8_t tos:1;
+  uint8_t otp_state:1;
+  int auth_mode; /* user authentication mode */
+  int user_time;
+
 #ifdef ENABLE_USERAGENT
   char useragent[REDIR_USERAGENTSIZE];
 #endif
@@ -113,6 +124,15 @@
   size_t vsalen;
 #endif
 
+  /* To store the RADIUS CLASS attribute received in the Access Accept */
+  uint8_t classbuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS CUI attribute received in the Access Accept */
+  uint8_t cuibuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS STATE attribute between Radius requests */
+  uint8_t statebuf[RADIUS_ATTR_VLEN];
+  size_t classlen;
+  size_t cuilen;
+  uint8_t statelen;
 } __attribute__((packed));
 
 struct session_state {
@@ -133,16 +153,21 @@
 
   struct timespec last_bw_time;
 
+  time_t dhcp_last_time; /* Last time a dhcp packet was received */
   time_t last_up_time;
   time_t last_time; /* Last time a packet was received or sent */
   time_t uamtime;
 
+  int warning_sent_download;
+  int warning_sent_upload;
+
   uint64_t input_packets;
   uint64_t output_packets;
   uint64_t input_octets;
   uint64_t output_octets;
   uint32_t terminate_cause;
   uint32_t session_id;
+  uint32_t terminate_cause_ui;
 
 #ifdef ENABLE_GARDENACCOUNTING
   char garden_sessionid[REDIR_SESSIONID_LEN];
@@ -198,5 +223,14 @@
 #endif
 
 } __attribute__((packed));
+#ifdef ENABLE_DATABASE
+struct session_history {
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint32_t sessiontime;
+} __attribute__((packed));
+#endif
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/sqlite.c src/src/sqlite.c
--- upstream/src/sqlite.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,73 @@
+
+#include "sqlite.h"
+#include "system.h"
+
+sqlite3 *sqlopen(char *dbpath) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(dbpath, &db);
+    if (ret)
+        syslog(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int sqlclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int sqlprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        syslog(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int sqltable_exists(sqlite3 *db, char *table_name){
+    int ret;
+    int count = 0;
+    char *sql = NULL;
+    sqlite3_stmt *stmt;
+
+    asprintf(&sql, "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='%s';",
+			 table_name);
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return SQL_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? SQL_FAIL : SQL_SUCCESS;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/sqlite.h src/src/sqlite.h
--- upstream/src/sqlite.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,19 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_SQLITE_H
+#define RUTX_SQLITE_H
+
+#include <sqlite3.h>
+
+#define SQL_SUCCESS 0
+#define SQL_FAIL 1
+
+sqlite3 *sqlopen(char *dbpath);
+int sqlclose(sqlite3 *db);
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int sqlprepare(sqlite3 *db, char *sql);
+int sqltable_exists(sqlite3 *db, char *table_name);
+
+#endif //RUTX_SQLITE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ssl.c src/src/ssl.c
--- upstream/src/ssl.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ssl.c	2025-07-03 10:02:27.000000000 +0000
@@ -35,11 +35,13 @@
     if (openssl_init == 0) {
       openssl_init = 1;
 #ifdef HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       if (_options.debug) {
 	SSL_load_error_strings();
       }
       SSL_library_init();
       OpenSSL_add_all_algorithms();
+#endif
 #else
       matrixSslOpen();
       syslog(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
@@ -55,11 +57,13 @@
     if (openssl_init == 0) {
       openssl_init = 1;
 #ifdef HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       if (_options.debug) {
 	SSL_load_error_strings();
       }
       SSL_library_init();
       OpenSSL_add_all_algorithms();
+#endif
 #else
       matrixSslOpen();
       syslog(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
@@ -132,7 +136,7 @@
   if (_options.sslciphers) {
     SSL_CTX_set_cipher_list(env->ctx, _options.sslciphers);
   }
-#ifdef HAVE_OPENSSL_ENGINE
+#ifndef OPENSSL_NO_ENGINE
   if (engine) {
  retry:
     if ((env->engine = ENGINE_by_id(engine)) == NULL) {
@@ -315,7 +319,11 @@
     } else {
 
 #ifdef HAVE_OPENSSL_ENGINE
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+      X509 *peer_cert = SSL_get1_peer_certificate(c->con);
+#else
       X509 *peer_cert = SSL_get_peer_certificate(c->con);
+#endif
 
       if (peer_cert) {
 	char subj[1024];
@@ -609,7 +617,7 @@
 #endif
 #ifdef HAVE_OPENSSL
   if (env->ctx) SSL_CTX_free(env->ctx);
-#ifdef HAVE_OPENSSL_ENGINE
+#ifndef OPENSSL_NO_ENGINE
   if (env->engine) ENGINE_free(env->engine);
 #endif
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ssl.h src/src/ssl.h
--- upstream/src/ssl.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ssl.h	2025-07-03 10:02:27.000000000 +0000
@@ -41,6 +41,7 @@
 #include <openssl/ssl.h>
 #include <openssl/pem.h>
 #include <openssl/engine.h>
+#include <openssl/err.h>
 #elif HAVE_CYASSL
 #include <stdio.h>
 #include <stdlib.h>
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/statusfile.c src/src/statusfile.c
--- upstream/src/statusfile.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/statusfile.c	2025-07-03 10:02:27.000000000 +0000
@@ -324,7 +324,7 @@
   file = fopen(filedest, "w");
   if (!file) { syslog(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
   fprintf(file, "#CoovaChilli-Version: %s\n", VERSION);
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
 
   /* marker */
   fputc(MARK_START, file);
@@ -394,20 +394,20 @@
   fprintf(file, "#Version:1.1\n");
   fprintf(file, "#SessionID = SID\n#Start-Time = ST\n");
   fprintf(file, "#SessionTimeOut = STO\n#SessionTerminateTime = STT\n");
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
   fprintf(file, "#User, IP, MAC, SID, ST, STO, STT\n");
 
   while(dhcpconn) {
     appconn = (struct app_conn_t *)dhcpconn->peer;
     if (appconn && appconn->s_state.authenticated == 1) {
-      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %d, %d, %d\n",
+      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %"PRId64", %d, %d\n",
 	      appconn->s_state.redir.username,
 	      inet_ntoa(appconn->hisip),
 	      appconn->hismac[0], appconn->hismac[1],
 	      appconn->hismac[2], appconn->hismac[3],
 	      appconn->hismac[4], appconn->hismac[5],
 	      appconn->s_state.sessionid,
-	      appconn->s_state.start_time,
+	      (uint64_t)appconn->s_state.start_time,
 	      appconn->s_params.sessiontimeout,
 	      appconn->s_params.sessionterminatetime);
     }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/tun.c src/src/tun.c
--- upstream/src/tun.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/tun.c	2025-07-03 10:02:27.000000000 +0000
@@ -1184,9 +1184,11 @@
 #endif
 
 #ifdef HAVE_NETFILTER_COOVA
-  if (_options.kname) {
-    set_env("KNAME", VAL_STRING, _options.kname, 0);
-  }
+  set_env("KNAME", VAL_STRING, _options.kname ? _options.kname : "", 0);
+#endif
+
+#ifdef ENABLE_MULTILAN
+  set_moreif_env();
 #endif
 
   if (execl(
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ubus.c src/src/ubus.c
--- upstream/src/ubus.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,625 @@
+
+#include "chilli.h"
+#include "options.h"
+
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+enum {
+	FORMAT_TABLE,
+	FORMAT_ARRAY
+};
+
+enum {
+	CHILLI_IP,
+	CHILLI_MAC,
+	CHILLI_SESSION_ID,
+	CHILLI_MAX
+};
+
+enum {
+	CHILLI_FORGET_MAC,
+	CHILLI_FORGET_MAX
+};
+
+static const struct blobmsg_policy chilli_default_policy[] = {
+		[CHILLI_IP]  = {.name = "ip", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_SESSION_ID]   = {.name = "sessionid", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct blobmsg_policy chilli_forget_policy[] = {
+		[CHILLI_FORGET_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct ubus_method chilli_methods[] = {
+		UBUS_METHOD("list", chilli_list_method, chilli_default_policy),
+		UBUS_METHOD("logout", chilli_logout_method, chilli_default_policy),
+		UBUS_METHOD("forget", chilli_forget_method, chilli_forget_policy),
+};
+
+static struct ubus_object_type chilli_object_type =
+		UBUS_OBJECT_TYPE("chilli_obj_type", chilli_methods);
+
+struct ubus_object chilli_object = {
+		.name      = "chilli",
+		.type      = &chilli_object_type,
+		.methods   = chilli_methods,
+		.n_methods = ARRAY_SIZE(chilli_methods),
+};
+
+static int parse_mac(uint8_t *mac, char *string) {
+	unsigned int temp[PKT_ETH_ALEN];
+	char macstr[RADIUS_ATTR_VLEN];
+	int macstrlen;
+	int i;
+
+	if ((macstrlen = strlen(string)) >= (RADIUS_ATTR_VLEN-1)) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	memcpy(macstr, string, macstrlen);
+	macstr[macstrlen] = 0;
+
+	for (i=0; i<macstrlen; i++)
+		if (!isxdigit((int) macstr[i]))
+			macstr[i] = 0x20;
+
+	if (sscanf(macstr, "%2x %2x %2x %2x %2x %2x",
+			   &temp[0], &temp[1], &temp[2],
+			   &temp[3], &temp[4], &temp[5]) != 6) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	for (i = 0; i < PKT_ETH_ALEN; i++)
+		mac[i] = temp[i];
+
+	return 0;
+}
+
+static void chilli_session_params(struct session_state *state, struct session_params *params,
+								  struct blob_buf *b)
+{
+	time_t starttime = state->start_time;
+
+	blobmsg_add_string(b, "sessionId", state->sessionid);
+	blobmsg_add_string(b, "userName", state->redir.username);
+	blobmsg_add_u64(b, "startTime", (uint64_t) mainclock_towall(starttime));
+	blobmsg_add_u64(b, "sessionTimeout", params->sessiontimeout);
+	blobmsg_add_u64(b, "terminateTime", params->sessionterminatetime);
+	blobmsg_add_u32(b, "idleTimeout", params->idletimeout);
+#ifdef ENABLE_IEEE8021Q
+	if (_options.ieee8021q && state->tag8021q) {
+		blobmsg_add_u16(b, "vlan", ntohs(state->tag8021q & PKT_8021Q_MASK_VID));
+	}
+#endif
+	if (params->maxinputoctets) {
+		blobmsg_add_u64(b, "maxInputOctets", params->maxinputoctets);
+	}
+	if (params->maxoutputoctets) {
+		blobmsg_add_u64(b, "maxOutputOctets", params->maxoutputoctets);
+	}
+	if (params->maxtotaloctets) {
+		blobmsg_add_u64(b, "maxTotalOctets", params->maxtotaloctets);
+	}
+	if (params->bandwidthmaxdown) {
+		blobmsg_add_u64(b, "maxDwBandwidth", params->bandwidthmaxdown);
+	}
+	if (params->bandwidthmaxup) {
+		blobmsg_add_u64(b, "maxUpBandwidth", params->bandwidthmaxup);
+	}
+}
+
+static void chilli_session_acct(struct session_state *state, struct blob_buf *b)
+{
+	uint32_t inoctets = state->input_octets;
+	uint32_t outoctets = state->output_octets;
+	uint32_t ingigawords = (state->input_octets >> 32);
+	uint32_t outgigawords = (state->output_octets >> 32);
+	uint32_t sessiontime;
+	uint32_t idletime;
+
+	sessiontime = mainclock_diffu(state->start_time);
+	idletime    = mainclock_diffu(state->last_up_time);
+
+	blobmsg_add_u32(b, "sessionTime", !state->authenticated ? 0 : sessiontime);
+	blobmsg_add_u32(b, "idleTime", !state->authenticated ? 0 : idletime);
+	blobmsg_add_u32(b, "inputOctets", !state->authenticated ? 0 : inoctets);
+	blobmsg_add_u32(b, "outputOctets", !state->authenticated ? 0 : outoctets);
+	blobmsg_add_u32(b, "inputGigawords", !state->authenticated ? 0 : ingigawords);
+	blobmsg_add_u32(b, "outputGigawords", !state->authenticated ? 0 : (long)outgigawords);
+	blobmsg_add_string(b, "viewPoint", _options.swapoctets ? "nas" : "client");
+}
+
+static void chilli_getinfo(struct app_conn_t *appconn, struct blob_buf *b, int format_array) {
+	if (appconn->s_state.authenticated) {
+		void *i = blobmsg_open_table(b, "session");
+		chilli_session_params(&appconn->s_state, &appconn->s_params, b);
+		blobmsg_close_table(b, i);
+
+		if (format_array) {
+			i = blobmsg_open_table(b, "accounting");
+			chilli_session_acct(&appconn->s_state, b);
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void chilli_form_blob(struct blob_buf *b, struct app_conn_t *appconn, struct dhcp_conn_t *conn, int format_array) {
+	char tmp_buff[64];
+	void *i;
+
+	if (!appconn && conn)
+		appconn = (struct app_conn_t *)conn->peer;
+
+	if ((!appconn || !appconn->inuse)) {
+		return;
+	} else if (conn && !conn->inuse) {
+		return;
+	} else {
+		if (format_array) {
+			i = blobmsg_open_table(b, NULL);
+		}
+		if (appconn) {
+			blobmsg_add_u32(b, "nasPort", appconn->unit);
+			blobmsg_add_u8(b, "clientState", appconn->s_state.authenticated);
+			blobmsg_add_string(b, "ipAddress", inet_ntoa(appconn->hisip));
+			if (appconn->s_state.redir.userurl[0]) {
+				blobmsg_add_string(b, "url", appconn->s_state.redir.userurl);
+			}
+		}
+
+		if (conn) {
+			sprintf(tmp_buff, MAC_FMT, MAC_ARG(conn->hismac));
+			blobmsg_add_string(b, "macAddress", tmp_buff);
+			blobmsg_add_string(b, "dhcpState", state2name(conn->authstate));
+		}
+
+		if (appconn) {
+			chilli_getinfo(appconn, b, format_array);
+		}
+
+		if (format_array) {
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void unused (void){
+	return;
+}
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method,
+							  struct blob_attr *msg)
+{
+	struct cmdsock_request req_params = { 0 };
+	struct app_conn_t *appconn = NULL;
+	struct dhcp_conn_t *dhcpconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	struct blob_buf b = { 0 };
+	int crt = 0;
+	void *ses;
+
+	blob_buf_init(&b, 0);
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		crt = 1;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		crt = 1;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		crt = 1;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	ses = blobmsg_open_array(&b, "sessions");
+	appconn = find_app_conn(&req_params, &crt);
+	if (appconn) {
+		dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
+		chilli_form_blob(&b, appconn, dhcpconn, FORMAT_ARRAY);
+	} else if (!crt) {
+		if (dhcp) {
+			dhcpconn = dhcp->firstusedconn;
+			while (dhcpconn) {
+				chilli_form_blob(&b, NULL, dhcpconn, FORMAT_ARRAY);
+				dhcpconn = dhcpconn->next;
+			}
+		}
+	}
+
+	blobmsg_close_array(&b, ses);
+	ubus_send_reply(ctx, req, b.head);
+	blob_buf_free(&b);
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	int count = 0;
+
+	memset(&req_params, 0, sizeof(req_params));
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		count++;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		count++;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		count++;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	if (count == 0) {
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	appconn = find_app_conn(&req_params, 0);
+	if (_options.debug) {
+		syslog(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+			   inet_ntoa(req_params.ip));
+	}
+
+	if (appconn) {
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_ADMIN_RESET);
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	int ret = UBUS_STATUS_OK;
+	struct blob_attr *tb[CHILLI_FORGET_MAX];
+	uint8_t mac[6];
+
+	blobmsg_parse(chilli_forget_policy, CHILLI_FORGET_MAX,
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[CHILLI_FORGET_MAC] || parse_mac(mac, blobmsg_data(tb[CHILLI_FORGET_MAC]))) {
+		ret = UBUS_STATUS_INVALID_ARGUMENT;
+		goto end;
+	}
+
+	usr_rm_user(mac);
+	usr_rm_sms_user(mac);
+end:
+	return ret;
+}
+
+void ubus_disconnect_cb(struct ubus_context *ubus)
+{
+	int ret;
+
+	if ((ret = ubus_reconnect(ubus, NULL)))
+	{
+		syslog(LOG_ERR, "Cannot reconnect to UBus: %s", ubus_strerror(ret));
+		ubus_free(ubus);
+	}
+}
+
+void chilli_ubus_add_obj(struct ubus_context *ctx)
+{
+	int ret;
+
+	if ((ret = ubus_add_object(ctx, &chilli_object))) {
+		syslog(LOG_ERR, "Failed to add object: %s", ubus_strerror(ret));
+	}
+
+	ctx->connection_lost = ubus_disconnect_cb;
+}
+
+void chilli_ubus_remove_obj(struct ubus_context *ctx)
+{
+	int ret = ubus_remove_object(ctx, &chilli_object);
+	if (ret) {
+		syslog(LOG_ERR, "Failed to remove object: %s", ubus_strerror(ret));
+	}
+}
+
+// main hostapd event handler.
+// the general approach of using hostapd might be inefficient, as hostapd
+// is kind of a fire hose when it comes to the events it sends out.
+static int hostapd_event_handle(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+
+	// unused vars
+	UNUSED(ctx);
+	UNUSED(obj);
+	UNUSED(req);
+
+	// coova-chilli functionality related vars
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+
+	// blobmsg parsing related vars
+	struct blob_attr *cur;
+	int rem;
+
+	// check to see if we're receiving a dissasoc call
+	// from hostapd
+	if (strcmp(method, CHILLI_UBUS_HAP_DISASSOC) != 0) {
+		return UBUS_STATUS_OK;
+	}
+
+	// at this point, we know that we are dealing with data that is
+	// related to a disconnect event
+
+	// this loop is only really concerned with
+	// the first blobvalue of *msg.
+	// which may or may not be our MAC addr
+	blobmsg_for_each_attr(cur, msg, rem) {
+
+		// check if we have field named 'address' (contains our mac addr).
+		// if not, break.
+		if (strcmp(blobmsg_name(cur), CHILLI_UBUS_HAP_ADDR)) {
+			continue;
+		}
+
+		// use the same methods as above to remove the disconnect from coova-chilli
+		// internally.
+		if (parse_mac(req_params.mac, blobmsg_get_string(cur))) {
+			syslog(LOG_ERR, "Unable to parse incoming mac address from hostapd");
+			break;
+		}
+
+		appconn = find_app_conn(&req_params, 0);
+
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+				inet_ntoa(req_params.ip));
+		}
+
+		if (!appconn) {
+			break;
+		}
+
+		// at this point we have a valid appconn obj
+
+		if (_options.debug) {
+			syslog(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_LOST_SERVICE);
+
+		// we can break here since we
+		// got everything we needed out of *msg.
+		break;
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+// tries to subscribe a single *ubus_subscriber and an iface pair to hostapd
+static int chilli_ubus_singlesub_hostapd(struct ubus_context *ctx, struct ubus_subscriber *event, char *iface)
+{
+	// null-check
+	if (iface == NULL || iface[0] == '\0') {
+		syslog(LOG_DEBUG, "%s given null iface argument.", __FUNCTION__);
+		return 1;
+	}
+
+	uint32_t u_obj_id;
+
+	char obj_name_buf[CHILLI_UBUS_OBJ_BUFSIZ];
+
+	// set event handler for ubus_subscriber
+	event->cb = hostapd_event_handle;
+
+	// prepare ubus obj string. i,e take the iface we got and add the hostapd base ubus
+	// obj name and a dot before it
+	snprintf(obj_name_buf, CHILLI_UBUS_OBJ_BUFSIZ, "%s.%s", CHILLI_UBUS_HAP_OBJ, iface);
+
+	// try to look for ubus hostapd obj
+	if (ubus_lookup_id(ctx, obj_name_buf, &u_obj_id)) {
+		syslog(LOG_ERR, "Failed to find ubus object: %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to register ubus subscriber
+	if (ubus_register_subscriber(ctx, event)) {
+		syslog(LOG_ERR, "Failed to register ubus subscriber for %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to subscribe
+	if (ubus_subscribe(ctx, event, u_obj_id) != UBUS_STATUS_OK) {
+		syslog(LOG_ERR, "Failed to subscribe to %s", obj_name_buf);
+		return 1;
+	}
+
+	syslog(LOG_INFO, "Successfully subscribed to %s", obj_name_buf);
+	return 0;
+
+}
+
+
+// function that subscribes to any relevant hostapd ubus objects. This is used to track 
+// Wifi connects/disconnects in order to be able to remove user from session list
+// if they disconnect from the wifi itself.
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options)
+{
+	// NOTE: i know there's the _options global, accessible from here, but having the options be passed
+	// as an argument is better practice, especially for maintainability
+
+
+	// null-check. Something has probably gone very wrong if this gets triggered.
+	if (options.dhcpif == NULL || options.dhcpif[0] == '\0') {
+		syslog(LOG_ERR, "Unable to add hostapd listeners. DHCP iface not set.");
+		return;
+	}
+
+	static struct ubus_subscriber hostapd_event; // ubus subscription object
+
+	// try to subscribe to the hostapd instance of the main iface.
+	// if this fails, move on.
+	chilli_ubus_singlesub_hostapd(ctx, &hostapd_event, options.dhcpif);
+
+	// basically do the same as above, but with the idea that all data of note is stored as arrays
+	#ifdef ENABLE_MULTILAN
+		static struct ubus_subscriber hostapd_multi_events[MAX_MOREIF]; // array of additional ubus sub objs
+
+		// for every additional interface that we got
+		for (int i = 0; i < MAX_MOREIF; i++) {
+			// try to subscribe to additinoal interface, move on if failed.
+			chilli_ubus_singlesub_hostapd(ctx, &hostapd_multi_events[i], options.moreif[i].dhcpif);
+		}
+	#endif
+}
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+			struct dhcp_conn_t *dhcpconn)
+{
+	if (!ctx) {
+		return;
+	}
+
+	struct blob_buf b = { 0 };
+	int err = 0;
+
+	blob_buf_init(&b, 0);
+
+	if (appconn) {
+		if (!strcmp(state, CHILLI_EVENT_CONNECT)) {
+			chilli_form_blob(&b, appconn, dhcpconn, FORMAT_TABLE);
+		} else {
+			blobmsg_add_string(&b, "sessionId", appconn->s_state.sessionid);
+		}
+	}
+
+	err = ubus_send_event(ctx, state, b.head);
+	if (err) {
+		syslog(LOG_ERR, "Failed to send ubus event '%s': %s", state, ubus_strerror(err));
+	}
+
+	blob_buf_free(&b);
+}
+
+static const char* find_ssid_in_iface(struct ubus_request *req, struct blob_attr *msg) {
+	struct ubus_ssid_request *request = (struct ubus_ssid_request *)req->priv;
+	const char *target_ifname = request->target_ifname;
+	const char *ssid = NULL;
+
+	struct blob_attr *cur, *cur2;
+	int rem = 0, rem2 = 0;
+
+	/* for every attribute of interface */
+	blobmsg_for_each_attr (cur, msg, rem) {
+		const char *attr_name = blobmsg_name(cur);
+
+		if (strcmp(attr_name, "ifname") == 0 && strcmp(blobmsg_get_string(cur), target_ifname)) {
+			return ssid;
+		}
+
+		if (strcmp(attr_name, "config") == 0) {
+			/* for every config sub-attribute of interface */
+			blobmsg_for_each_attr (cur2, cur, rem2) {
+				if (strcmp(blobmsg_name(cur2), "ssid")) continue;
+				ssid = blobmsg_get_string(cur2);
+				return ssid;
+			}
+		}
+	}
+
+	return ssid;
+}
+
+static void get_interfaces_cb(struct ubus_request *req, int type, struct blob_attr *msg) {
+	struct ubus_ssid_request *request = (struct ubus_ssid_request *)req->priv;
+	const char **ssid_ptr = request->ssid_ptr;
+
+	struct blob_attr *cur, *cur2, *cur3;
+	int rem = 0, rem2 = 0, rem3 = 0;
+
+	/* top-level, this loops over the "radio*" sub-objects */
+	blobmsg_for_each_attr (cur, blob_memdup(msg), rem) {
+		/* for every attribute within a radio* */
+		blobmsg_for_each_attr (cur2, blob_memdup(cur), rem2) {
+			if (strcmp(blobmsg_name(cur2), "interfaces"))
+				continue;
+
+			/* for every interface */
+			blobmsg_for_each_attr (cur3, blob_memdup(cur2), rem3) {
+				const char *ssid = find_ssid_in_iface(req, blob_memdup(cur3));
+				if (ssid == NULL) continue;
+				*ssid_ptr = ssid;
+				return;
+			}
+		}
+	}
+}
+
+const char* find_ssid_by_ifname(const char *ifname) {
+	uint32_t net_obj;
+	struct blob_buf buf = {0};
+	const char *ssid = NULL;
+	struct ubus_ssid_request request = { .target_ifname = ifname, .ssid_ptr = &ssid };
+
+	ubus_ctx = ubus_connect(NULL);
+	if (!ubus_ctx) {
+		syslog(LOG_ERR, "Failed to connect to ubus");
+		return ssid;
+	}
+
+	blob_buf_init(&buf, 0);
+	if (ubus_lookup_id(ubus_ctx, CHILLI_UBUS_WIRELESS_OBJ, &net_obj)) {
+		goto free;
+	}
+
+	if (ubus_invoke(ubus_ctx, net_obj, CHILLI_UBUS_WIRELESS_STATUS, buf.head, get_interfaces_cb, &request, CHILLI_UBUS_TIMEOUT)) {
+		goto free;
+	}
+
+free:
+	ubus_free(ubus_ctx);
+	blob_buf_free(&buf);
+	return ssid;
+}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ubus.h src/src/ubus.h
--- upstream/src/ubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,39 @@
+
+#ifndef _CHILLI_UBUS_H
+#define _CHILLI_UBUS_H
+
+#include <libubus.h>
+
+#define CHILLI_UBUS_OBJ_BUFSIZ 50
+
+// various defines for parsing the incoming ubus obj
+#define CHILLI_UBUS_HAP_OBJ "hostapd"
+#define CHILLI_UBUS_HAP_DISASSOC "disassoc"
+#define CHILLI_UBUS_HAP_ADDR "address"
+
+#define CHILLI_UBUS_WIRELESS_OBJ "network.wireless"
+#define CHILLI_UBUS_WIRELESS_STATUS "status"
+
+#define CHILLI_UBUS_TIMEOUT 5000
+
+#define UNUSED(x) (void)(x)
+
+#define CHILLI_EVENT_CONNECT "chilli.connect"
+#define CHILLI_EVENT_DISCONNECT "chilli.disconnect"
+
+struct ubus_ssid_request {
+	const char *target_ifname;
+	const char **ssid_ptr;
+};
+
+void chilli_ubus_add_obj(struct ubus_context *ctx);
+void chilli_ubus_remove_obj(struct ubus_context *ctx);
+
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options);
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+                        struct dhcp_conn_t *dhcpconn);
+
+const char* find_ssid_by_ifname(const char *ifname);
+
+#endif //_CHILLI_UBUS_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/users.c src/src/users.c
--- upstream/src/users.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.c	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,695 @@
+#include "chilli.h"
+#include <uci.h>
+#include <libtlt_uci.h>
+#ifdef ENABLE_GSM
+#include "gsm.h"
+#endif
+
+static int rm_user(char *table, uint8_t *mac);
+
+/*!
+ * Generate a n octet random string
+ * @param dst The memory area to copy to
+ * @param size The number of bytes to copy
+ * @return 0 on success, -1 on fail.
+ */
+
+int usr_random_hex(char *dst, size_t size)
+{
+	size_t i = 0;
+	int c;
+	char x[3];
+	FILE *file;
+
+	if ((file = fopen("/dev/urandom", "r")) == NULL) {
+		syslog(LOG_ERR, "%s: fopen(/dev/urandom)", strerror(errno));
+		return -1;
+	}
+
+	for (i = 0; i <= size - 2; i++) {
+		c = fgetc(file);
+		snprintf(x, 3, "%.2x", c);
+		dst[i++] = x[0];
+		dst[i]	 = x[1];
+	}
+
+	dst[size] = 0;
+
+	fclose(file);
+	return 0;
+}
+
+int usr_runscript(struct redir_conn_t *conn, char *script, char *username, char *password)
+{
+	int status;
+	uint32_t sessiontime;
+
+	if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
+		syslog(LOG_ERR, "%s: forking %s", strerror(errno), script);
+		return 0;
+	}
+
+	if (status > 0) { /* Parent */
+		return 0;
+	}
+
+	set_env("DEV", VAL_STRING, tun(tun, 0).devname, 0);
+	set_env("ADDR", VAL_IN_ADDR, &conn->ourip, 0);
+	set_env("FRAMED_IP_ADDRESS", VAL_IN_ADDR, &conn->hisip, 0);
+	set_env("SESSION_TIMEOUT", VAL_ULONG64, &conn->s_params.sessiontimeout, 0);
+	set_env("IDLE_TIMEOUT", VAL_ULONG, &conn->s_params.idletimeout, 0);
+	set_env("CALLING_STATION_ID", VAL_MAC_ADDR, conn->hismac, 0);
+	set_env("CALLED_STATION_ID", VAL_MAC_ADDR, chilli_called_station(&conn->s_state), 0);
+	set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG, &conn->s_params.bandwidthmaxup, 0);
+	set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG, &conn->s_params.bandwidthmaxdown, 0);
+	set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxinputoctets, 0);
+	set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxoutputoctets, 0);
+	set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &conn->s_params.maxtotaloctets, 0);
+	set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &conn->s_params.warningoctets, 0);
+
+	sessiontime = mainclock_diffu(conn->s_state.start_time);
+	set_env("SESSION_TIME", VAL_ULONG, &sessiontime, 0);
+	sessiontime = mainclock_diffu(conn->s_state.last_up_time);
+	set_env("IDLE_TIME", VAL_ULONG, &sessiontime, 0);
+	set_env("USER_EXPIRATION_TIME", VAL_ULONG64, &conn->s_params.expiration, 0);
+	set_env("PHONE", VAL_STRING, &conn->s_state.redir.phone, 0);
+	set_env("EMAIL", VAL_STRING, &conn->s_state.redir.email, 0);
+
+	if (username) {
+		set_env("USER_NAME", VAL_STRING, username, 0);
+	}
+	if (_options.smsusers) {
+		if (password)
+			set_env("PASSWORD", VAL_STRING, password, 0);
+#ifdef ENABLE_GSM
+		if (_options.modemid)
+			set_env("MODEM_ID", VAL_STRING, _options.modemid, 0);
+#endif
+	}
+
+	if (execl(
+#ifdef ENABLE_CHILLISCRIPT
+		    SBINDIR "/chilli_script", SBINDIR "/chilli_script", _options.binconfig,
+#else
+		    script,
+#endif
+		    script, (char *)0) != 0) {
+		syslog(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
+	}
+
+	exit(0);
+}
+
+int usr_gen_message(char *msg, char *password)
+{
+	time_t now;
+
+	if (_options.dynexpirationtime) {
+		time(&now);
+		now += _options.dynexpirationtime;
+	}
+
+	sprintf(msg, MSG_FMT, password, _options.dynexpirationtime ? ctime(&now) : "unlimited");
+
+	return 0;
+}
+
+int _select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_user *p_str_user = (struct str_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_USER_NAME], USER_USERNAMENAMESIZE);
+		p_str_user->username[USER_USERNAMENAMESIZE] = 0;
+		strncpy(p_str_user->email, argv[COL_USER_EMAIL], USER_EMAILSIZE);
+		p_str_user->email[USER_EMAILSIZE] = 0;
+		strncpy(p_str_user->password, argv[COL_USER_PASS], USER_PASSWORDSIZE);
+		p_str_user->password[USER_PASSWORDSIZE] = 0;
+		strncpy(p_str_user->phone, argv[COL_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration =
+			argv[COL_USER_EXPIRATION] ? strtol(argv[COL_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->user_time = argv[COL_USER_TIME] ? strtol(argv[COL_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int _lusr_select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_luser *p_str_user = (struct str_luser *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_LUSER_NAME], USER_USERNAMENAMESIZE);
+		p_str_user->username[USER_USERNAMENAMESIZE] = 0;
+		strncpy(p_str_user->password, argv[COL_LUSER_PASS], USER_PASSWORDSIZE);
+		p_str_user->password[USER_PASSWORDSIZE] = 0;
+		strncpy(p_str_user->group, argv[COL_LUSER_GROUP], USER_GROUPSIZE);
+		p_str_user->group[USER_GROUPSIZE] = 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_user_expired(sqlite3 *db, char *email, uint8_t *mac)
+{
+	int ret = USER_RET_SUCCESS;
+	char *sql = 0;
+	sqlite3_stmt *stmt;
+
+	asprintf(&sql, SELECT_NOT_EXPIRED_EMAIL_FMT, "users", email, MAC_ARG(mac));
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+	if (ret != SQLITE_OK) {
+		syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__, sqlite3_errmsg(db));
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		if (sqlite3_column_int(stmt, 0) > 0)
+			ret = USER_RET_ALREADY;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+int usr_get_user(sqlite3 *db, struct str_user *user, char *email)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_USER_FMT, email);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int lusr_get_user(sqlite3 *db, struct str_luser *user, char *username)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_LUSER_FMT, username);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _lusr_select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_update_user_pwd(sqlite3 *db, struct str_user *user, char *email, char *new_passw)
+{
+#ifndef HAVE_OPENSSL
+	return SQL_FAIL;
+#endif
+	char *new_passw_hash = hash_sha512(new_passw);
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, UPDATE_USR_PWD, new_passw_hash, email);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		free(new_passw_hash);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	free(new_passw_hash);
+
+	return SQL_SUCCESS;
+}
+
+int lusr_update_user_pwd(sqlite3 *db, struct str_luser *user, char *username, char *new_passw)
+{
+#ifndef HAVE_OPENSSL
+	return SQL_FAIL;
+#endif
+	char *new_passw_hash = hash_sha512(new_passw);
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, UPDATE_LUSER_PWD, new_passw_hash, username);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _lusr_select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		free(new_passw_hash);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	free(new_passw_hash);
+
+	return SQL_SUCCESS;
+}
+
+int usr_add_user(struct redir_conn_t *conn)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_ERROR;
+	char username[USER_USERNAMENAMESIZE + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		conn->response = REDIR_SIGNUP_FAILED;
+		return USER_RET_ERROR;
+	}
+
+	if ((ret = usr_user_expired(db, conn->s_state.redir.email, conn->hismac)) != USER_RET_SUCCESS) {
+		if (ret == USER_RET_ALREADY)
+			conn->response = REDIR_SIGNUP_ALREADY;
+		else
+			conn->response = REDIR_SIGNUP_FAILED;
+
+		goto out;
+	}
+
+	if (usr_random_hex(username, USER_RAND_USERNAME_LEN)) {
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_USERS_FMT, username, conn->s_state.redir.email,
+		 conn->s_state.redir.signup_password, MAC_ARG(conn->hismac), conn->s_state.redir.phone,
+		 _options.dynexpirationtime);
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		conn->response = REDIR_SIGNUP_SUCCESS;
+		ret	       = USER_RET_SUCCESS;
+		if (_options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+			if (_options.debug)
+				syslog(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n", __FUNCTION__,
+				       __LINE__, _options.usersignup);
+
+			usr_runscript(conn, _options.usersignup, conn->s_state.redir.email, NULL);
+		}
+	} else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+static int lusr_add_user(sqlite3 *db, const char *username, const char *password, const char *group)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, INSERT_LUSER_FMT, username, password, group);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, 0, 0, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	return SQL_SUCCESS;
+}
+
+int _sms_select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_sms_user *p_str_user = (struct str_sms_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_SMS_USER_NAME], USER_RAND_USERNAME_LEN);
+		p_str_user->username[USER_RAND_USERNAME_LEN] = 0;
+		strncpy(p_str_user->password, argv[COL_SMS_USER_PASS], USER_RAND_PASSWORD_LEN);
+		p_str_user->password[USER_RAND_PASSWORD_LEN] = 0;
+		strncpy(p_str_user->phone, argv[COL_SMS_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration =
+			argv[COL_SMS_USER_EXPIRATION] ? strtol(argv[COL_SMS_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->used = argv[COL_SMS_USER_USED] ? strtol(argv[COL_SMS_USER_USED], NULL, 0) : 0;
+		p_str_user->user_time =
+			argv[COL_SMS_USER_TIME] ? strtol(argv[COL_SMS_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_get_sms_user(sqlite3 *db, struct str_sms_user *user, char *password)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_SMS_USER_FMT, password);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_sms_user_exists(sqlite3 *db, char *phone, uint8_t *mac)
+{
+	int ret = USER_RET_ERROR;
+	char *sql = 0;
+	sqlite3_stmt *stmt;
+
+	if (phone != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_FMT, "sms_users", phone);
+	else if (mac != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_MAC_FMT, "sms_users", MAC_ARG(mac));
+	else
+		goto out;
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
+		syslog(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__, sqlite3_errmsg(db));
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		ret = sqlite3_column_int(stmt, 0) > 0 ? USER_RET_ALREADY : USER_RET_SUCCESS;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+static int send_sms_created(struct redir_conn_t *conn, char *phone, char *password)
+{
+	int ret = USER_RET_SUCCESS;
+#ifdef ENABLE_GSM
+	char message[USER_MAX_MESSAGE_SIZE];
+
+	usr_gen_message(message, password);
+
+	if (chilli_send_sms(phone, message, _options.modemid) != CHILLI_GSM_OK) {
+		usr_rm_sms_user(conn->hismac);
+		ret = USER_RET_SMS_ERR;
+	}
+#endif
+	if (ret == USER_RET_SUCCESS && _options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+		if (_options.debug)
+			syslog(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n", __FUNCTION__, __LINE__,
+			       _options.usersignup);
+
+		usr_runscript(conn, _options.usersignup, phone, password);
+	}
+	return ret;
+}
+
+int usr_get_sms_user_phone(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac)
+{
+	int ret = SQL_SUCCESS;
+	char *sql = NULL;
+	char *err = 0;
+
+	if (phone != NULL)
+		asprintf(&sql, SELECT_SMS_USER_PHONE_FMT, phone);
+	else if (mac != NULL)
+		asprintf(&sql, SELECT_SMS_USER_MAC_FMT, MAC_ARG(mac));
+	else
+		goto out;
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+out:
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_add_sms_user(struct redir_conn_t *conn, char *phone, char *hexchall)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_ERROR;
+	char password[USER_RAND_PASSWORD_LEN + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath)))
+		return USER_RET_ERROR;
+
+	if (usr_random_hex(password, USER_RAND_PASSWORD_LEN)) {
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	if ((ret = usr_sms_user_exists(db, phone, conn->hismac)) != USER_RET_SUCCESS) {
+		struct str_sms_user user = { 0 };
+		if (usr_get_sms_user_phone(db, &user, phone, conn->hismac) || user.used == 0) {
+			syslog(LOG_DEBUG, "user already exists: %d\n", ret);
+			goto out;
+		}
+		if ((ret = usr_update_sms_user(db, &user, phone, conn->hismac, 0, password)) !=
+		    USER_RET_SUCCESS) {
+			goto out;
+		}
+		ret = send_sms_created(conn, phone, password);
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_SMS_USERS_FMT, phone, password, MAC_ARG(conn->hismac), phone,
+		 _options.dynexpirationtime);
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		ret = send_sms_created(conn, phone, password);
+	} else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+int usr_update_sms_user(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac, uint32_t used,
+			char *new_passw)
+{
+	int ret = USER_RET_SUCCESS;
+	char *sql = NULL;
+	char *err = 0;
+
+	if (new_passw) {
+		asprintf(&sql, UPDATE_SMS_USERS_PWD_FMT, new_passw, used, MAC_ARG(mac), phone);
+	} else {
+		asprintf(&sql, UPDATE_SMS_USERS_USE_FMT, used, MAC_ARG(mac), phone);
+	}
+
+	if (_options.debug)
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		syslog(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return USER_RET_ERROR;
+	}
+
+	free(sql);
+
+	return USER_RET_SUCCESS;
+}
+
+static int rm_user(char *table, uint8_t *mac)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_SUCCESS;
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		ret = USER_RET_ERROR;
+		goto end;
+	}
+
+	asprintf(&sql, DELETE_USER_FMT, table, MAC_ARG(mac));
+	if (_options.debug) {
+		syslog(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+	}
+
+	if (sqlexec(db, sql, NULL)) {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+	sqlclose(db);
+end:
+	return ret;
+}
+
+int usr_rm_user(uint8_t *mac)
+{
+	return rm_user("users", mac);
+}
+
+int usr_rm_sms_user(uint8_t *mac)
+{
+	return rm_user("sms_users", mac);
+}
+
+int usr_get(char *username)
+{
+	return 0;
+}
+
+static int migrate_localusers(sqlite3 *db)
+{
+	struct uci_context *uci = uci_alloc_context();
+	if (!uci) {
+		return 1;
+	}
+
+	struct uci_package *uci_chilli = NULL;
+	if (uci_load(uci, CHILLI_CONFIG, &uci_chilli)) {
+		uci_free_context(uci);
+		return 1;
+	}
+
+	struct uci_element *e = NULL;
+	struct uci_element *tmp = NULL;
+	uci_foreach_element_safe (&uci_chilli->sections, e, tmp) {
+		struct uci_section *s = uci_to_section(e);
+		if (!s->type || strcmp(s->type, "user")) {
+			continue;
+		}
+
+		const char *username_uci = uci_lookup_option_string(uci, s, "username");
+		if (!username_uci) {
+			continue;
+		}
+
+		const char *password_uci = uci_lookup_option_string(uci, s, "password");
+		if (!password_uci) {
+			continue;
+		}
+
+		const char *group_uci = uci_lookup_option_string(uci, s, "group");
+		lusr_add_user(db, username_uci, password_uci, !group_uci ? "default" : group_uci);
+
+		struct uci_ptr ptr = {
+			.target	 = UCI_TYPE_SECTION,
+			.package = uci_chilli->e.name,
+			.section = s->e.name,
+		};
+		uci_delete(uci, &ptr);
+		uci_save(uci, ptr.p);
+	}
+
+	uci_commit(uci, &uci_chilli, false);
+	uci_unload(uci, uci_chilli);
+	uci_free_context(uci);
+	return 0;
+}
+
+static int alter_table_add_column(sqlite3 *db, const char *table_name, const char *column_definition)
+{
+	int ret		= USER_RET_ERROR;
+	char *sql_alter = NULL;
+
+	asprintf(&sql_alter, ALTER_TABLE_FMT, table_name, column_definition);
+
+	if (sqlite3_exec(db, sql_alter, 0, 0, 0) == SQLITE_OK) {
+		ret = USER_RET_SUCCESS;
+	}
+
+	free(sql_alter);
+
+	return ret;
+}
+
+int alter_tables()
+{
+	sqlite3 *db;
+	int ret = USER_RET_ERROR;
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath)))
+		return ret;
+
+	ret = alter_table_add_column(db, "sms_users", "used TIMESTAMP DEFAULT 0 NOT NULL");
+	ret = sqlite3_exec(db, CREATE_LUSER_TABLE, 0, 0, 0);
+	ret = migrate_localusers(db);
+
+	sqlclose(db);
+	return ret;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/users.h src/src/users.h
--- upstream/src/users.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.h	2025-07-03 10:02:27.000000000 +0000
@@ -0,0 +1,182 @@
+
+#ifndef RUTX_USERS_H
+#define RUTX_USERS_H
+
+#include <inttypes.h>
+
+#define USER_MIN_PHONE_LEN 6
+
+#define USER_USERNAMENAMESIZE 128
+#define USER_PASSWORDSIZE     128
+#define USER_PHONESIZE	      64
+#define USER_EMAILSIZE	      128
+#define USER_GROUPSIZE	      128
+
+#define USER_RAND_USERNAME_LEN 16
+#define USER_RAND_PASSWORD_LEN 6
+
+#define USER_RET_SUCCESS 0
+#define USER_RET_ERROR	 1
+#define USER_RET_ALREADY 2
+#define USER_RET_SMS_ERR 3
+
+#define USER_MAX_MESSAGE_SIZE 128
+
+#define CHILLI_CONFIG "chilli"
+
+enum {
+	COL_SMS_USER_ID = 0,
+	COL_SMS_USER_NAME,
+	COL_SMS_USER_PASS,
+	COL_SMS_USER_MAC,
+	COL_SMS_USER_PHONE,
+	COL_SMS_USER_CREATED,
+	COL_SMS_USER_EXPIRATION,
+	COL_SMS_USER_USED,
+	COL_SMS_USER_TIME,
+};
+
+enum {
+	COL_USER_ID = 0,
+	COL_USER_NAME,
+	COL_USER_EMAIL,
+	COL_USER_PASS,
+	COL_USER_MAC,
+	COL_USER_PHONE,
+	COL_USER_CREATED,
+	COL_USER_EXPIRATION,
+	COL_USER_TIME,
+};
+
+enum { COL_LUSER_ID = 0, COL_LUSER_NAME, COL_LUSER_PASS, COL_LUSER_GROUP };
+
+#define INSERT_SMS_USERS_FMT                                                                                 \
+	"INSERT INTO sms_users (username, password, mac, phone,"                                             \
+	" expiration) VALUES ('%s', '%s', '" MAC_FMT "', '%s', '%" PRIi64 "');"
+
+#define NOT_EXPIRED_FMT                                                                                      \
+	"((strftime('%%s','now') - strftime('%%s', created)) < expiration"                                   \
+	" OR expiration = '0')"
+
+#define LIMIT_FMT " ORDER BY id DESC limit 1"
+
+#define UPDATE_USR_PWD                                                                                       \
+	"UPDATE users SET password='%s' \
+			WHERE (" NOT_EXPIRED_FMT " AND email = '%s');"
+
+#define UPDATE_SMS_USERS_PWD_FMT                                                                             \
+	"UPDATE sms_users SET password='%s', \
+			used='%" PRIu32 "', mac='"MAC_FMT"' WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+#define UPDATE_SMS_USERS_USE_FMT                                                                             \
+	"UPDATE sms_users SET used='%" PRIu32 "', mac='"MAC_FMT"' \
+			WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+#define USER_TIME_FMT "(strftime('%%s','now') - strftime('%%s', created)) AS user_time"
+
+//Cont all unexpired users with corresponding phone number
+#define SELECT_NOT_EXPIRED_FMT                                                                               \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+//Cont all unexpired users with corresponding mac
+#define SELECT_NOT_EXPIRED_MAC_FMT                                                                           \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND mac = '" MAC_FMT "');"
+
+#define SELECT_NOT_EXPIRED_EMAIL_FMT                                                                         \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND (email = '%s' OR mac = '" MAC_FMT "'));"
+
+#define SELECT_SMS_USER_FMT                                                                                  \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND password = '%s')" LIMIT_FMT ";"
+
+#define SELECT_SMS_USER_PHONE_FMT                                                                            \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND phone = '%s')" LIMIT_FMT ";"
+
+#define SELECT_SMS_USER_MAC_FMT                                                                            \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND mac = '" MAC_FMT "')" LIMIT_FMT ";"
+
+#define INSERT_USERS_FMT                                                                                     \
+	"INSERT INTO users (username, email, password, mac, phone,"                                          \
+	" expiration) VALUES ('%s', '%s', '%s', '" MAC_FMT "', '%s', '%" PRIi64 "');"
+
+#define SELECT_USER_FMT                                                                                      \
+	"SELECT *, " USER_TIME_FMT " FROM users "                                                            \
+	"WHERE (" NOT_EXPIRED_FMT " AND email = '%s')" LIMIT_FMT ";"
+
+#define DELETE_USER_FMT "DELETE FROM %s WHERE (mac = '" MAC_FMT "');"
+
+#define ALTER_TABLE_FMT "ALTER TABLE %s ADD COLUMN %s;"
+
+#define MSG_FMT "Password - %s, expiration time - %s"
+
+#define CREATE_LUSER_TABLE                                                                                   \
+	"CREATE TABLE IF NOT EXISTS local_users ("                                                           \
+	"id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,"                                              \
+	"username TEXT NOT NULL UNIQUE,"                                                                     \
+	"password TEXT NOT NULL,"                                                                            \
+	"user_group TEXT NOT NULL"                                                                           \
+	");"
+
+#define SELECT_LUSER_FMT                                                                                     \
+	"SELECT * FROM local_users "                                                                         \
+	"WHERE username = '%s'" LIMIT_FMT ";"
+
+#define UPDATE_LUSER_PWD                                                                                     \
+	"UPDATE local_users SET password='%s' \
+			WHERE username = '%s';"
+
+#define INSERT_LUSER_FMT                                                                                     \
+	"INSERT INTO local_users (username, password, user_group"                                            \
+	") VALUES ('%s', '%s', '%s');"
+
+struct str_sms_user {
+	char username[USER_RAND_USERNAME_LEN + 1];
+	char password[USER_RAND_PASSWORD_LEN + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t used;
+	uint32_t user_time;
+};
+
+struct str_user {
+	char username[USER_USERNAMENAMESIZE + 1];
+	char email[USER_EMAILSIZE + 1];
+	char password[USER_PASSWORDSIZE + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t user_time;
+};
+
+struct str_luser {
+	char username[USER_USERNAMENAMESIZE + 1];
+	char password[USER_PASSWORDSIZE + 1];
+	char group[USER_GROUPSIZE + 1];
+};
+
+int usr_get_user(sqlite3 *db, struct str_user *user, char *email);
+int usr_update_user_pwd(sqlite3 *db, struct str_user *user, char *email, char *new_passw);
+int usr_add_user(struct redir_conn_t *conn);
+
+int usr_get_sms_user(sqlite3 *db, struct str_sms_user *user, char *password);
+int usr_get_sms_user_phone(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac);
+int usr_update_sms_user(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac, uint32_t used,
+			char *new_passw);
+int usr_add_sms_user(struct redir_conn_t *conn, char *phone, char *hexchall);
+int usr_sms_user_exists(sqlite3 *db, char *phone, uint8_t *mac);
+
+int usr_rm_user(uint8_t *mac);
+int usr_rm_sms_user(uint8_t *mac);
+
+int lusr_get_user(sqlite3 *db, struct str_luser *user, char *username);
+int lusr_update_user_pwd(sqlite3 *db, struct str_luser *user, char *username, char *new_passw);
+
+int usr_random_hex(char *dst, size_t size);
+
+int alter_tables();
+
+#endif //RUTX_USERS_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/util.c src/src/util.c
--- upstream/src/util.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/util.c	2025-07-03 10:02:27.000000000 +0000
@@ -117,6 +117,54 @@
   return 0;
 }
 
+int bstrtocstr(bstring src, char *dst, unsigned int len) {
+	if (!src || src->slen == 0) {
+		dst[0] = 0;
+		return 0;
+	}
+
+	strlcpy(dst, (char*)src->data, len);
+	return 0;
+}
+
+int bescape_str(bstring src, bstring dst) {
+  int n;
+
+  bassigncstr(dst, "");
+  for (n=0; n < src->slen; n++)
+    if ('\'' != src->data[n] && src->data[n] != '"' &&
+        '\\' != src->data[n]) {
+      bconchar(dst,src->data[n]);
+    }
+
+  return 0;
+}
+
+int escape_cstr(char *src, char *dst) {
+  int i = 0;
+  int n;
+
+  for (n = 0; n < strlen(src); n++)
+    if ('\'' != src[n] && src[n] != '"' &&
+        '\\' != src[n]) {
+      dst[i++] = src[n];
+    }
+
+  dst[i] = 0;
+
+  return 0;
+}
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len) {
+  bstring dst_bt = bfromcstr("");
+
+  bescape_str(src, dst_bt);
+  bstrtocstr(dst_bt, dst, len);
+  bdestroy(dst_bt);
+
+  return 0;
+}
+
 
 /* This file is free software; you can redistribute it and/or modify */
 /* it under the terms of the GNU General Public License as published by */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/www/Makefile.am src/www/Makefile.am
--- upstream/www/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/www/Makefile.am	2025-07-03 10:02:27.000000000 +0000
@@ -17,7 +17,7 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(sysconfdir)/init.d,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
