Index: netifd-2024-01-04-c18cc79d/system-linux.c
===================================================================
--- netifd-2024-01-04-c18cc79d.orig/system-linux.c
+++ netifd-2024-01-04-c18cc79d/system-linux.c
@@ -77,7 +77,6 @@
 #include "device.h"
 #include "system.h"
 #include "utils.h"
-#include "port_link.h"
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,300)
 enum ethtool_link_mode_bit_indices {
@@ -1894,6 +1893,15 @@ failure:
 }
 #endif
 
+bool ethtool_link_mode_set_bit(int nr, uint32_t *mask)
+{
+	if (nr < 0)
+		return false;
+
+        mask[nr / 32] |= (1 << (nr % 32));
+        return 0;
+}
+
 static void ethtool_link_mode_clear_bit(__s8 nwords, int nr, __u32 *mask)
 {
 	if (nr < 0)
@@ -1905,7 +1913,7 @@ static void ethtool_link_mode_clear_bit(
 	mask[nr / 32] &= ~(1U << (nr % 32));
 }
 
-static bool ethtool_link_mode_test_bit(__s8 nwords, int nr, const __u32 *mask)
+bool ethtool_link_mode_test_bit(__s8 nwords, int nr, const __u32 *mask)
 {
 	if (nr < 0)
 		return false;
@@ -2243,53 +2251,126 @@ system_if_get_settings(struct device *de
 #endif
 }
 
-int set_dev_link(const char *ifname, bool autoneg, bool duplex, int speed, int advert)
+static void validate_link_settings(struct netifd_link_settings *data, uint32_t *advert)
 {
-	if (!ifname) {
+	unsigned int i = 0;
+
+	uint32_t *advert_zone  = &data->link_mode_data[data->req.link_mode_masks_nwords];
+	uint32_t *support_zone = &data->link_mode_data[0];
+
+	memcpy(advert_zone, support_zone, sizeof(uint32_t) * data->req.link_mode_masks_nwords);
+
+	// Clear all available modes
+	for (i = 0; i < ARRAY_SIZE(ethtool_modes); i++) {
+		ethtool_link_mode_clear_bit(data->req.link_mode_masks_nwords, ethtool_modes[i].bit_full, advert_zone);
+		ethtool_link_mode_clear_bit(data->req.link_mode_masks_nwords, ethtool_modes[i].bit_half, advert_zone);
+	}
+
+	for (i = 0; i < sizeof(uint32_t) * data->req.link_mode_masks_nwords; i++) {
+		advert_zone[i] |= advert[i];
+	}
+}
+
+static int set_dev_link_legacy(const char *ifname, bool autoneg, bool duplex, uint32_t speed, uint32_t advert, struct ifreq *ifr)
+{
+	memset(ifr->ifr_data, 0, sizeof(struct netifd_link_settings));
+	struct ethtool_cmd *ecmd = (struct ethtool_cmd *)ifr->ifr_data;
+	ecmd->cmd		 = ETHTOOL_GSET;
+	if (ioctl(sock_ioctl, SIOCETHTOOL, ifr) < 0) {
 		return EXIT_FAILURE;
 	}
 
-	struct ethtool_cmd ecmd = { 0 };
-	ecmd.cmd = ETHTOOL_GSET;
+	ecmd->cmd = ETHTOOL_SSET;
 
-	struct ifreq ifr = { 0 };
-	ifr.ifr_data = (caddr_t)&ecmd;
+	if (advert < 1 || advert >= MAX_ADV_VAL) {
+		advert = ecmd->supported;
+	}
 
-	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
+	ecmd->autoneg = autoneg;
+	if (autoneg) {
+		ecmd->advertising = ecmd->supported;
+		ecmd->advertising &= ~(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | ADVERTISED_100baseT_Half |
+				       ADVERTISED_100baseT_Full | ADVERTISED_1000baseT_Half |
+				       ADVERTISED_1000baseT_Full | ADVERTISED_2500baseX_Full);
+		ecmd->advertising |= advert;
+		goto end;
+	}
+
+	ecmd->duplex = duplex ? DUPLEX_FULL : DUPLEX_HALF;
+
+	switch (speed) {
+	case SPEED_10:
+	case SPEED_100:
+	case SPEED_1000:
+		ethtool_cmd_speed_set(ecmd, speed);
+		break;
+	default:
+		ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
+	}
 
-	if (ioctl(sock_ioctl, SIOCETHTOOL, &ifr) != 0) {
+end:
+	return EXIT_SUCCESS;
+}
+
+int set_dev_link(const char *ifname, bool autoneg, bool duplex, uint32_t speed, uint32_t *advert)
+{
+	if (!ifname) {
 		return EXIT_FAILURE;
 	}
 
-	ecmd.cmd = ETHTOOL_SSET;
+	struct ifreq ifr		 = { 0 };
+	struct netifd_link_settings ecmd = { 0 };
 
-	if (advert < 1 || advert >= MAX_ADV_VAL) {
-		advert = ecmd.supported;
+	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
+
+	ecmd.req.cmd = ETHTOOL_GLINKSETTINGS;
+	ifr.ifr_data = (void *)&ecmd;
+	if (ioctl(sock_ioctl, SIOCETHTOOL, &ifr)) {
+		if (!set_dev_link_legacy(ifname, autoneg, duplex, speed, *advert, &ifr)) {
+			goto end;
+		}
+		return EXIT_FAILURE;
+	}
+
+	if (ecmd.req.link_mode_masks_nwords < 0) {
+		ecmd.req.link_mode_masks_nwords = -ecmd.req.link_mode_masks_nwords;
+		ioctl(sock_ioctl, SIOCETHTOOL, &ifr);
+	} else {
+		return EXIT_FAILURE;
 	}
 
-	ecmd.autoneg = autoneg;
+	ecmd.req.cmd = ETHTOOL_SLINKSETTINGS;
+
+	ecmd.req.autoneg = autoneg;
 	if (autoneg) {
-		ecmd.advertising = ecmd.supported;
-		ecmd.advertising &= ~(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | \
-		 			ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full | \
-					ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full | \
-					ADVERTISED_2500baseX_Full);
-		ecmd.advertising |= advert;
+		uint32_t *advert_p = advert;
+		if (*advert_p < 1 || ethtool_link_mode_test_bit(ecmd.req.link_mode_masks_nwords,
+								ETHTOOL_LINK_MODE_2500baseT_Full_BIT, advert_p)) {
+			advert_p = &ecmd.link_mode_data[0];
+		}
+
+		validate_link_settings(&ecmd, advert_p);
+
 		goto end;
 	}
 
-	ecmd.duplex = duplex ? DUPLEX_FULL : DUPLEX_HALF;
+	ecmd.req.duplex = duplex ? DUPLEX_FULL : DUPLEX_HALF;
 
-	switch(speed) {
+	struct ethtool_cmd eth_cmd = { .speed = SPEED_UNKNOWN };
+	switch (speed) {
 	case SPEED_10:
 	case SPEED_100:
 	case SPEED_1000:
-		ethtool_cmd_speed_set(&ecmd, speed);
+	case SPEED_2500:
+	case SPEED_5000:
+	case SPEED_10000:
+		eth_cmd.speed = speed;
 		break;
 	default:
-		ethtool_cmd_speed_set(&ecmd, SPEED_UNKNOWN);
+		break;
 	}
 
+	ecmd.req.speed = ethtool_cmd_speed(&eth_cmd);
 end:
 	return ioctl(sock_ioctl, SIOCETHTOOL, &ifr);
 }
Index: netifd-2024-01-04-c18cc79d/port_link.h
===================================================================
--- netifd-2024-01-04-c18cc79d.orig/port_link.h
+++ netifd-2024-01-04-c18cc79d/port_link.h
@@ -1,18 +1,25 @@
 #ifndef __NETIFD_PORT_LINK_H
 #define __NETIFD_PORT_LINK_H
 
+#include <linux/ethtool.h>
+
 #define BFR_SIZE 256
 #define MAX_ADV_VAL 32815
 
 extern struct vlist_tree port_entries;
 
+struct netifd_link_settings {
+	struct ethtool_link_settings req;
+	uint32_t link_mode_data[3 * __ETHTOOL_LINK_MODE_MASK_NBITS];
+};
+
 struct port_entry {
 	bool enabled;
 
 	bool autoneg;
 	bool duplex;
-	int speed;
-	int advert;
+	uint32_t speed;
+	uint32_t advert[__ETHTOOL_LINK_MODE_MASK_NBITS];
 
 	char *ifname;
 
Index: netifd-2024-01-04-c18cc79d/port_link.c
===================================================================
--- netifd-2024-01-04-c18cc79d.orig/port_link.c
+++ netifd-2024-01-04-c18cc79d/port_link.c
@@ -1,9 +1,28 @@
 #include "netifd.h"
-#include "port_link.h"
 #include "device.h"
 #include "system.h"
 
-struct vlist_tree port_entries = {0};
+struct vlist_tree port_entries = { 0 };
+
+static void update_advert(struct port_entry *port_section, uint64_t val)
+{
+	if (val & ADVERTISED_10baseT_Half)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, port_section->advert);
+	if (val & ADVERTISED_10baseT_Full)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, port_section->advert);
+	if (val & ADVERTISED_100baseT_Half)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, port_section->advert);
+	if (val & ADVERTISED_100baseT_Full)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, port_section->advert);
+	if (val & ADVERTISED_1000baseT_Half)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, port_section->advert);
+	if (val & ADVERTISED_1000baseT_Full)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, port_section->advert);
+	if (val & ADVERTISED_10000baseT_Full)
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, port_section->advert);
+	if (val & (1ULL << ETHTOOL_LINK_MODE_2500baseT_Full_BIT))
+		ethtool_link_mode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, port_section->advert);
+}
 
 struct port_entry *
 ret_port_section(struct uci_section *s, struct uci_context *uci_ctx)
@@ -52,7 +71,9 @@ ret_port_section(struct uci_section *s,
 
 	tmp = uci_lookup_option_string(uci_ctx, s, "advert");
 	if (tmp) {
-		port_section->advert = strtol(tmp, &end, 0);
+		uint64_t val = strtoll(tmp, &end, 0);
+
+		update_advert(port_section, val);
 	}
 
 	return port_section;
@@ -81,7 +102,8 @@ cleanup_and_restore_port(struct port_ent
 	}
 
 	set_port_state(port_old->ifname, true);
-	set_dev_link(port_old->ifname, true, false, false, 0);
+	uint32_t advert[__ETHTOOL_LINK_MODE_MASK_NBITS] = { 0 };
+	set_dev_link(port_old->ifname, true, false, 0, advert);
 
 	free(port_old);
 }
@@ -103,10 +125,12 @@ update_port_state(struct port_entry *por
 	}
 
 	if (port_old->autoneg != port_new->autoneg || port_old->duplex != port_new->duplex ||
-			port_old->speed != port_new->speed || port_old->advert != port_new->advert) {
-		ret = set_dev_link(port_new->ifname, port_new->autoneg, port_new->duplex, port_new->speed, port_new->advert);
+	    port_old->speed != port_new->speed ||
+	    memcmp(port_old->advert, port_new->advert, sizeof(port_old->advert))) {
+		ret = set_dev_link(port_new->ifname, port_new->autoneg, port_new->duplex, port_new->speed,
+				   port_new->advert);
 	}
-	
+
 end:
 	free(port_old);
 	return ret;
Index: netifd-2024-01-04-c18cc79d/system.h
===================================================================
--- netifd-2024-01-04-c18cc79d.orig/system.h
+++ netifd-2024-01-04-c18cc79d/system.h
@@ -18,11 +18,11 @@
 #include <sys/time.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
-#include <linux/ethtool.h>
 #include "device.h"
 #include "interface-ip.h"
 #include "iprule.h"
 #include "utils.h"
+#include "port_link.h"
 
 enum tunnel_param {
 	TUNNEL_ATTR_TYPE,
@@ -338,6 +338,9 @@ int system_update_ipv6_mtu(struct device
 int system_link_netns_move(struct device *dev, const pid_t target_ns, const char *target_ifname);
 int system_netns_open(const pid_t target_ns);
 int system_netns_set(int netns_fd);
-int set_dev_link(const char *ifname, bool autoneg, bool duplex, int speed, int advert);
+int set_dev_link(const char *ifname, bool autoneg, bool duplex, uint32_t speed, uint32_t *advert);
+
+bool ethtool_link_mode_set_bit(int nr, uint32_t *mask);
+bool ethtool_link_mode_test_bit(__s8 nwords, int nr, const __u32 *mask);
 
 #endif
