--- a/src/Makefile
+++ b/src/Makefile
@@ -79,6 +79,7 @@ OBJS=	mosquitto.o \
 		websockets.o \
 		will_delay.o \
 		will_mosq.o \
+		misq_utils.o \
 		xtreport.o
 
 mosquitto : ${OBJS}
@@ -309,6 +310,9 @@ will_delay.o : will_delay.c mosquitto_br
 will_mosq.o : ../lib/will_mosq.c ../lib/will_mosq.h
 	${CROSS_COMPILE}${CC} $(BROKER_CPPFLAGS) $(BROKER_CFLAGS) -c $< -o $@
 
+misq_utils.o : misq_utils.c misq_utils.h
+	${CROSS_COMPILE}${CC} $(BROKER_CPPFLAGS) $(BROKER_CFLAGS) -c $< -o $@
+
 xtreport.o : xtreport.c
 	${CROSS_COMPILE}${CC} $(BROKER_CPPFLAGS) $(BROKER_CFLAGS) -c $< -o $@
 
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -70,7 +70,8 @@ set (MOSQ_SRCS
 	../lib/utf8_mosq.c
 	websockets.c
 	will_delay.c
-	../lib/will_mosq.c ../lib/will_mosq.h)
+	../lib/will_mosq.c ../lib/will_mosq.h
+	misq_utils.c misq_utils.h)
 
 
 if (WITH_BUNDLED_DEPS)
--- /dev/null
+++ b/src/misq_utils.h
@@ -0,0 +1,8 @@
+#include <string.h>
+#include <stdio.h>
+#include <libubus.h>
+#include <libubox/blobmsg.h>
+
+#include "mosquitto_broker_internal.h"
+
+void ip_block_invoke(const char *command, struct mosquitto *context);
--- /dev/null
+++ b/src/misq_utils.c
@@ -0,0 +1,36 @@
+#include "misq_utils.h"
+
+void ip_block_invoke(const char *command, struct mosquitto *context) {
+	uint32_t tmp_id = 0;
+	struct blob_buf b = { 0 };
+	char *host = context->address;
+	char port[6] = {0};
+
+	struct ubus_context *ubus = ubus_connect(NULL);
+	if (!ubus) {
+		printf("Warning: Failed to connect to ubus.");
+		return;
+	}
+
+	if (strstr(context->address, ".") && strstr(context->address, ":")) { //if host is IPv4 mapped IPv6 address
+		host = strrchr(context->address, ':') + 1;
+	}
+
+	int ret = ubus_lookup_id(ubus, "ip_block", &tmp_id);
+
+	if (ret) {
+		printf("Warning: Failed to find 'ip_block' object.");
+		goto end;
+	}
+	snprintf(port, sizeof(port), "%d", context->listener->port);
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ip", host);
+	blobmsg_add_string(&b, "port", port);
+	blobmsg_add_string(&b, "proto", "MQTT");
+
+	ubus_invoke(ubus, tmp_id, command, b.head, NULL, NULL, 1000);
+	blob_buf_free(&b);
+end:
+	ubus_free(ubus);
+}
--- a/config.mk
+++ b/config.mk
@@ -252,7 +252,7 @@ endif
 ifeq ($(WITH_TLS),yes)
 	APP_CPPFLAGS:=$(APP_CPPFLAGS) -DWITH_TLS -DOPENSSL_API_COMPAT=0x10100000L
 	BROKER_CPPFLAGS:=$(BROKER_CPPFLAGS) -DWITH_TLS -DOPENSSL_API_COMPAT=0x10100000L
-	BROKER_LDADD:=$(BROKER_LDADD) -lssl -lcrypto
+	BROKER_LDADD:=$(BROKER_LDADD) -lssl -lcrypto -lubus -lubox -luci
 	CLIENT_CPPFLAGS:=$(CLIENT_CPPFLAGS) -DWITH_TLS -DOPENSSL_API_COMPAT=0x10100000L
 	LIB_CPPFLAGS:=$(LIB_CPPFLAGS) -DWITH_TLS -DOPENSSL_API_COMPAT=0x10100000L
 	LIB_LIBADD:=$(LIB_LIBADD) -lssl -lcrypto
--- a/include/mosquitto.h
+++ b/include/mosquitto.h
@@ -122,6 +122,7 @@ enum mosq_err_t {
 	MOSQ_ERR_TOPIC_ALIAS_INVALID = 29,
 	MOSQ_ERR_ADMINISTRATIVE_ACTION = 30,
 	MOSQ_ERR_ALREADY_EXISTS = 31,
+	MOSQ_ERR_SSL = 32,
 };
 
 /* Enum: mosq_opt_t
--- a/src/security_default.c
+++ b/src/security_default.c
@@ -1151,7 +1151,7 @@ int mosquitto_security_apply_default(voi
 					send__disconnect(context, MQTT_RC_ADMINISTRATIVE_ACTION, NULL);
 				}
 				mosquitto__set_state(context, mosq_cs_disconnecting);
-				do_disconnect(context, MOSQ_ERR_AUTH);
+				do_disconnect(context, MOSQ_ERR_SSL);
 				continue;
 			}
 #ifdef FINAL_WITH_TLS_PSK
--- a/src/handle_connect.c
+++ b/src/handle_connect.c
@@ -33,6 +33,7 @@ Contributors:
 #include "tls_mosq.h"
 #include "util_mosq.h"
 #include "will_mosq.h"
+#include "misq_utils.h"
 
 #ifdef WITH_WEBSOCKETS
 #  include <libwebsockets.h>
@@ -314,6 +315,8 @@ int connect__on_authorised(struct mosqui
 	free(auth_data_out);
 	auth_data_out = NULL;
 
+	ip_block_invoke("unblock", context);
+
 	mosquitto__set_state(context, mosq_cs_active);
 	rc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);
 	mosquitto_property_free_all(&connack_props);
--- a/src/loop.c
+++ b/src/loop.c
@@ -53,6 +53,7 @@ Contributors:
 #include "sys_tree.h"
 #include "time_mosq.h"
 #include "util_mosq.h"
+#include "misq_utils.h"
 
 extern bool flag_reload;
 #ifdef WITH_PERSISTENCE
@@ -284,6 +285,9 @@ void do_disconnect(struct mosquitto *con
 	bool is_duplicate = false;
 #endif
 
+	if(reason == MOSQ_ERR_AUTH) {
+		ip_block_invoke("push", context);
+	}
 	if(context->state == mosq_cs_disconnected){
 		return;
 	}
