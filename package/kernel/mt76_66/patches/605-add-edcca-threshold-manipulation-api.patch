Index: mt76_66-2025-01-22-a22d59e4/mt7615/main.c
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt7615/main.c
+++ mt76_66-2025-01-22-a22d59e4/mt7615/main.c
@@ -12,6 +12,8 @@
 #include "mt7615.h"
 #include "mcu.h"
 
+#define MT_EDCCA_THRESHOLD_VALUE 16
+
 static bool mt7615_dev_running(struct mt7615_dev *dev)
 {
 	struct mt7615_phy *phy;
@@ -77,6 +79,22 @@ static int mt7615_start(struct ieee80211
 	if (ret)
 		goto out;
 
+	dev->edcca_state[MT_BAND0] = true;
+
+	ret = mt7615_mcu_set_edcca(dev, MT_BAND0, dev->edcca_state);
+	WARN_ON(ret != 0);
+
+	if (phy != &dev->phy) {
+		dev->edcca_state[MT_BAND1] = true;
+
+		ret = mt7615_mcu_set_edcca(dev, MT_BAND1, dev->edcca_state);
+		WARN_ON(ret != 0);
+	}
+
+	dev->edcca_threshold = MT_EDCCA_THRESHOLD_VALUE;
+	ret = mt7615_mcu_set_edcca_threshold(dev, dev->edcca_threshold);
+	WARN_ON(ret != 0);
+
 	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
 	timeout = mt7615_get_macwork_timeout(dev);
Index: mt76_66-2025-01-22-a22d59e4/mt7615/mcu.c
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt7615/mcu.c
+++ mt76_66-2025-01-22-a22d59e4/mt7615/mcu.c
@@ -2543,6 +2543,35 @@ int mt7615_mcu_set_bss_pm(struct mt7615_
 				 &req, sizeof(req), false);
 }
 
+int mt7615_mcu_set_edcca(struct mt7615_dev *dev, u8 idx, bool enable)
+{
+	struct {
+		u8 enable;
+		u8 band_idx;
+		u8 _rsv[2];
+	} req = {
+		.enable = enable ? 1 : 0,
+		.band_idx = idx,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_EDCCA_CTRL,
+				 &req, sizeof(req), false);
+}
+
+int mt7615_mcu_set_edcca_threshold(struct mt7615_dev *dev, u32 threshold)
+{
+	struct {
+		u32 cmd;
+		u32 threshold;
+	} req = {
+		.cmd = cpu_to_le32(MT_SET_EDCCA_THRESHOLD),
+		.threshold = cpu_to_le32(threshold),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_EAP_CTRL,
+				 &req, sizeof(req), false);
+}
+
 int mt7615_mcu_set_roc(struct mt7615_phy *phy, struct ieee80211_vif *vif,
 		       struct ieee80211_channel *chan, int duration)
 {
Index: mt76_66-2025-01-22-a22d59e4/mt7615/mcu.h
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt7615/mcu.h
+++ mt76_66-2025-01-22-a22d59e4/mt7615/mcu.h
@@ -132,6 +132,10 @@ enum {
     MT_SKU_4SS_DELTA,
 };
 
+enum {
+	MT_SET_EDCCA_THRESHOLD = 0x1,
+};
+
 struct mt7615_mcu_rxd {
 	__le32 rxd[4];
 
Index: mt76_66-2025-01-22-a22d59e4/mt7615/mt7615.h
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt7615/mt7615.h
+++ mt76_66-2025-01-22-a22d59e4/mt7615/mt7615.h
@@ -65,6 +65,8 @@
 #define MT7615_CFEND_RATE_DEFAULT	0x49 /* OFDM 24M */
 #define MT7615_CFEND_RATE_11B		0x03 /* 11B LP, 11M */
 
+#define MT7615_MAX_BAND_CNT		2
+
 struct mt7615_vif;
 struct mt7615_sta;
 struct mt7615_dfs_pulse;
@@ -274,6 +276,8 @@ struct mt7615_dev {
 	bool dbdc_support;
 
 	u8 fw_ver;
+	bool edcca_state[MT7615_MAX_BAND_CNT];
+	u32 edcca_threshold;
 
 	struct work_struct rate_work;
 	struct list_head wrd_head;
@@ -534,6 +538,9 @@ int mt7615_mac_set_beacon_filter(struct
 				 bool enable);
 int mt7615_mcu_set_bss_pm(struct mt7615_dev *dev, struct ieee80211_vif *vif,
 			  bool enable);
+int mt7615_mcu_set_edcca(struct mt7615_dev *dev, u8 idx, bool enable);
+int mt7615_mcu_set_edcca_threshold(struct mt7615_dev *dev, u32 threshold);
+
 int __mt7663_load_firmware(struct mt7615_dev *dev);
 void mt7615_coredump_work(struct work_struct *work);
 
Index: mt76_66-2025-01-22-a22d59e4/mt76_connac_mcu.h
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt76_connac_mcu.h
+++ mt76_66-2025-01-22-a22d59e4/mt76_connac_mcu.h
@@ -1239,6 +1239,7 @@ enum {
 	MCU_EXT_CMD_TXDPD_CAL = 0x60,
 	MCU_EXT_CMD_CAL_CACHE = 0x67,
 	MCU_EXT_CMD_RED_ENABLE = 0x68,
+	MCU_EXT_CMD_EDCCA_CTRL = 0x70,
 	MCU_EXT_CMD_CP_SUPPORT = 0x75,
 	MCU_EXT_CMD_SET_RADAR_TH = 0x7c,
 	MCU_EXT_CMD_SET_RDD_PATTERN = 0x7d,
@@ -1249,6 +1250,7 @@ enum {
 	MCU_EXT_CMD_OFFCH_SCAN_CTRL = 0x9a,
 	MCU_EXT_CMD_SET_RDD_TH = 0x9d,
 	MCU_EXT_CMD_MURU_CTRL = 0x9f,
+	MCU_EXT_CMD_EAP_CTRL = 0xa0,
 	MCU_EXT_CMD_SET_SPR = 0xa8,
 	MCU_EXT_CMD_GROUP_PRE_CAL_INFO = 0xab,
 	MCU_EXT_CMD_DPD_PRE_CAL_INFO = 0xac,
Index: mt76_66-2025-01-22-a22d59e4/mt7615/debugfs.c
===================================================================
--- mt76_66-2025-01-22-a22d59e4.orig/mt7615/debugfs.c
+++ mt76_66-2025-01-22-a22d59e4/mt7615/debugfs.c
@@ -218,6 +218,112 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_dbdc, mt76
 			 mt7615_dbdc_set, "%lld\n");
 
 static int
+mt7615_edcca_state_set(void *data, u64 val)
+{
+	struct mt7615_dev *dev = data;
+	int ret = 0;
+
+	dev->edcca_state[MT_BAND0] = val ? true : false;
+
+ 	ret = mt7615_mcu_set_edcca(dev, MT_BAND0,  dev->edcca_state);
+	WARN_ON(ret != 0);
+
+	return 0;
+}
+
+static int
+mt7615_edcca_state_get(void *data, u64 *val)
+{
+	struct mt7615_dev *dev = data;
+
+	*val = dev->edcca_state[MT_BAND0] ? 1 : 0;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_edcca_state, mt7615_edcca_state_get,
+			 mt7615_edcca_state_set, "%lld\n");
+
+static int
+mt7615_edcca_state_set_ext_phy(void *data, u64 val)
+{
+	struct mt7615_dev *dev = data;
+	int ret = 0;
+
+	dev->edcca_state[MT_BAND1] = val ? true : false;
+
+ 	ret = mt7615_mcu_set_edcca(dev, MT_BAND1,  dev->edcca_state);
+	WARN_ON(ret != 0);
+
+	return 0;
+}
+
+static int
+mt7615_edcca_state_get_ext_phy(void *data, u64 *val)
+{
+	struct mt7615_dev *dev = data;
+
+	*val = dev->edcca_state[MT_BAND1] ? 1 : 0;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_edcca_state_ext_phy, mt7615_edcca_state_get_ext_phy,
+			 mt7615_edcca_state_set_ext_phy, "%lld\n");
+
+static int mt7615_edcca_threshold_set(struct file *file, const char __user *userbuf, size_t count, loff_t *ppos)
+{
+	struct mt7615_dev *dev = file->private_data;
+	long edcca_threshold   = 0;
+	char buf[5];
+	int ret = 0;
+
+	if (count > sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[sizeof(buf) - 1] = '\0';
+
+	if (kstrtol(buf, 0, &edcca_threshold) || edcca_threshold > -62 || edcca_threshold < -95)
+		return -EINVAL;
+
+	dev->edcca_threshold = abs(edcca_threshold) - 62;
+
+	ret = mt7615_mcu_set_edcca_threshold(dev, dev->edcca_threshold);
+	WARN_ON(ret != 0);
+
+	return count;
+}
+
+static int mt7615_edcca_threshold_get(struct file *file, char __user *userbuf, size_t count, loff_t *ppos)
+{
+	struct mt7615_dev *dev = file->private_data;
+	u32 len		       = 8;
+	char *buf	       = NULL;
+	int ofs		       = 0;
+
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ofs += snprintf(buf + ofs, len - ofs, "-%d\n", dev->edcca_threshold + 62);
+	ofs = simple_read_from_buffer(userbuf, count, ppos, buf, ofs);
+
+	kfree(buf);
+	return ofs;
+}
+
+static const struct file_operations fops_edcca_threshold = {
+	.open	= simple_open,
+	.llseek = generic_file_llseek,
+	.read	= mt7615_edcca_threshold_get,
+	.write	= mt7615_edcca_threshold_set,
+	.owner	= THIS_MODULE,
+};
+
+static int
 mt7615_fw_debug_set(void *data, u64 val)
 {
 	struct mt7615_dev *dev = data;
@@ -548,6 +654,7 @@ mt7663s_sched_quota_read(struct seq_file
 int mt7615_init_debugfs(struct mt7615_dev *dev)
 {
 	struct dentry *dir;
+	struct mt7615_phy *ext_phy = mt7615_ext_phy(dev);
 
 	dir = mt76_register_debugfs_fops(&dev->mphy, &fops_regval);
 	if (!dir)
@@ -564,6 +671,11 @@ int mt7615_init_debugfs(struct mt7615_de
 	debugfs_create_file("ampdu_stat", 0400, dir, dev, &mt7615_ampdu_stat_fops);
 	debugfs_create_file("scs", 0600, dir, dev, &fops_scs);
 	debugfs_create_file("dbdc", 0600, dir, dev, &fops_dbdc);
+	debugfs_create_file("edcca_state", 0600, dir, dev, &fops_edcca_state);
+	if (ext_phy)
+		debugfs_create_file("edcca_state_ext_phy", 0600, dir, dev,
+			    &fops_edcca_state_ext_phy);
+	debugfs_create_file("edcca_threshold", 0600, dir, dev, &fops_edcca_threshold);
 	debugfs_create_file("fw_debug", 0600, dir, dev, &fops_fw_debug);
 	debugfs_create_file("runtime-pm", 0600, dir, dev, &fops_pm);
 	debugfs_create_file("idle-timeout", 0600, dir, dev,
