--- a/Makefile
+++ b/Makefile
@@ -612,6 +612,10 @@ ifdef CONFIG_FEATURE_NETIFD
 CONFIG_EXTRA_LDLIBS+=netifd ubus
 endif
 
+ifdef CONFIG_FEATURE_PASSWORD_POLICY
+CONFIG_EXTRA_LDLIBS+=uci
+endif
+
 # Rule to link busybox - also used during CONFIG_KALLSYMS
 # May be overridden by arch/$(ARCH)/Makefile
 quiet_cmd_busybox__ ?= LINK    $@
--- a/loginutils/passwd.c
+++ b/loginutils/passwd.c
@@ -21,6 +21,11 @@
 //config:	depends on PASSWD
 //config:	help
 //config:	With this option passwd will refuse new passwords which are "weak".
+//config:config FEATURE_PASSWORD_POLICY
+//config:	bool "Support for password policy"
+//config:	default y
+//config:	depends on PASSWD && FEATURE_SHADOWPASSWDS
+//config:
 
 //applet:/* Needs to be run by root or be suid root - needs to change /etc/{passwd,shadow}: */
 //applet:IF_PASSWD(APPLET(passwd, BB_DIR_BIN, BB_SUID_REQUIRE))
@@ -68,6 +73,101 @@ void log_event(char *user) {
 }
 #endif // CONFIG_PASSWD
 
+#ifdef CONFIG_FEATURE_PASSWORD_POLICY
+#include <uci.h>
+#include <ctype.h>
+
+static int get_policy_int_value(struct uci_context *ctx, const char *option_name, int default_value) {
+	struct uci_ptr ptr;
+	char uci_path[64];
+	char *endptr;
+
+	snprintf(uci_path, sizeof(uci_path), "password_policy.@policy[0].%s", option_name);
+	if (uci_lookup_ptr(ctx, &ptr, uci_path, true) != UCI_OK || !ptr.o || !ptr.o->v.string) {
+		return default_value;
+	}
+	long value = strtol(ptr.o->v.string, &endptr, 10);
+	if (*endptr != '\0' || value < INT_MIN || value > INT_MAX) {
+		return default_value;
+	}
+
+	return (int)value;
+}
+
+static bool get_policy_bool_value(struct uci_context *ctx, const char *option_name, bool default_value) {
+	struct uci_ptr ptr;
+	char uci_path[64];
+	char *endptr;
+
+	snprintf(uci_path, sizeof(uci_path), "password_policy.@policy[0].%s", option_name);
+	if (uci_lookup_ptr(ctx, &ptr, uci_path, true) != UCI_OK || !ptr.o || !ptr.o->v.string) {
+		return default_value;
+	}
+	long value = strtol(ptr.o->v.string, &endptr, 10);
+	if (*endptr != '\0' || value < 0 || value > 1) {
+		return default_value;
+	}
+
+	return value == 1;
+}
+
+static int validate_password(const char *newval)
+{
+	struct uci_context *ctx;
+	const char *msg = NULL;
+	int length = strlen(newval);
+	int has_digit = 0, has_lower = 0, has_upper = 0, has_special = 0, ret = 0;
+
+	ctx = uci_alloc_context();
+	if (!ctx) {
+		printf("Failed to allocate UCI context\n");
+		return 0;
+	}
+
+	int password_length = get_policy_int_value(ctx, "password_length", 8);
+	bool require_digits = get_policy_bool_value(ctx, "require_digits", true);
+	bool require_lower_upper = get_policy_bool_value(ctx, "require_lower_upper", true);
+	bool require_special = get_policy_bool_value(ctx, "require_special", false);
+
+	if (length < password_length) {
+		printf("Bad password: Password is too short. Minimum length is %d characters.\n", password_length);
+		ret = 1;
+		goto out;
+	}
+
+	for (int i = 0; i < length; i++) {
+		if (isdigit(newval[i])) has_digit = 1;
+		if (islower(newval[i])) has_lower = 1;
+		if (isupper(newval[i])) has_upper = 1;
+		if (ispunct(newval[i])) has_special = 1;
+	}
+
+	if (require_digits && !has_digit) {
+		msg = "Password must contain at least one digit.";
+		goto out;
+	}
+
+	if (require_lower_upper && (!has_lower || !has_upper)) {
+		msg = "Password must contain both lowercase and uppercase letters.";
+		goto out;
+	}
+
+	if (require_special && !has_special) {
+		msg = "Password must contain at least one special character.";
+		goto out;
+	}
+
+out:
+	if (msg) {
+		printf("Bad password: %s\n", msg);
+		ret = 1;
+	}
+
+	uci_free_context(ctx);
+	return ret;
+}
+#endif // CONFIG_FEATURE_PASSWORD_POLICY
+
 static char* new_password(const struct passwd *pw, uid_t myuid, const char *algo)
 {
 	char salt[MAX_PW_SALT_LEN];
@@ -95,13 +195,31 @@ static char* new_password(const struct p
 	newp = bb_ask_noecho_stdin("New password: "); /* returns malloced str */
 	if (!newp)
 		goto err_ret;
-	if (ENABLE_FEATURE_PASSWD_WEAK_CHECK
-	 && obscure(orig, newp, pw) /* NB: passing NULL orig is ok */
-	 && myuid != 0
+	if (ENABLE_FEATURE_PASSWD_WEAK_CHECK &&
+#ifdef CONFIG_FEATURE_PASSWORD_POLICY
+	 validate_password(newp)
+#else
+	 obscure(orig, newp, pw) && myuid != 0 /* NB: passing NULL orig is ok */
+#endif
 	) {
 		goto err_ret; /* non-root is not allowed to have weak passwd */
 	}
 
+#ifdef CONFIG_FEATURE_PASSWORD_POLICY
+	if (ENABLE_FEATURE_PASSWD_WEAK_CHECK &&
+		pw->pw_passwd && pw->pw_passwd[0] &&
+		pw->pw_passwd[0] != 'x' && pw->pw_passwd[0] != '!' && pw->pw_passwd[0] != '*') {
+		char *encrypted = pw_encrypt(newp, pw->pw_passwd, 1); /* returns malloced str */
+		if (!strcmp(encrypted, pw->pw_passwd)) {
+			puts("Password is the same. Use a different password");
+			goto err_ret;
+		}
+
+		if (ENABLE_FEATURE_CLEAN_UP)
+			free(encrypted);
+	}
+#endif
+
 	cp = bb_ask_noecho_stdin("Retype password: ");
 	if (!cp)
 		goto err_ret;
--- a/libbb/setup_environment.c
+++ b/libbb/setup_environment.c
@@ -59,6 +59,9 @@ void FAST_FUNC setup_environment(const c
 		//xsetenv("LOGNAME", pw->pw_name);
 		//xsetenv("HOME",    pw->pw_dir);
 		//xsetenv("SHELL",   shell);
+	} else if (flags & SETUP_ENV_CHANGEENV_FORCE) {
+		/* Set variables no matter user type */
+		goto shortcut;
 	} else if (flags & SETUP_ENV_CHANGEENV) {
 		/* Set HOME, SHELL, and if not becoming a super-user,
 		 * USER and LOGNAME.  */
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -1729,10 +1729,11 @@ extern void selinux_or_die(void) FAST_FU
  * NB: CHANGEENV and CLEARENV use setenv() - this leaks memory!
  * If setup_environment() is used is vforked child, this leaks memory _in parent too_!
  */
-#define SETUP_ENV_CHANGEENV (1 << 0)
-#define SETUP_ENV_CLEARENV  (1 << 1)
-#define SETUP_ENV_TO_TMP    (1 << 2)
-#define SETUP_ENV_NO_CHDIR  (1 << 4)
+#define SETUP_ENV_CHANGEENV        (1 << 0)
+#define SETUP_ENV_CLEARENV         (1 << 1)
+#define SETUP_ENV_TO_TMP           (1 << 2)
+#define SETUP_ENV_CHANGEENV_FORCE  (1 << 3)
+#define SETUP_ENV_NO_CHDIR         (1 << 4)
 void setup_environment(const char *shell, int flags, const struct passwd *pw) FAST_FUNC;
 void nuke_str(char *str) FAST_FUNC;
 #if ENABLE_FEATURE_SECURETTY && !ENABLE_PAM
--- a/loginutils/login.c
+++ b/loginutils/login.c
@@ -640,7 +640,7 @@ int login_main(int argc UNUSED_PARAM, ch
 
 	change_identity(pw);
 	setup_environment(pw->pw_shell,
-			(!(opt & LOGIN_OPT_p) * SETUP_ENV_CLEARENV) + SETUP_ENV_CHANGEENV,
+			(!(opt & LOGIN_OPT_p) * SETUP_ENV_CLEARENV) + ((opt & LOGIN_OPT_f) ? SETUP_ENV_CHANGEENV : SETUP_ENV_CHANGEENV_FORCE),
 			pw);
 
 #if ENABLE_PAM
--- /dev/null
+++ b/loginutils/pwage.c
@@ -0,0 +1,171 @@
+/* vi: set sw=4 ts=4: */
+//config:config FEATURE_PASSWORD_POLICY
+//config:	bool "Support for password policy"
+//config:	default y
+//config:	depends on PASSWD && FEATURE_SHADOWPASSWDS
+//config:
+
+//applet:/* Needs to be run by root or be suid root - needs to change /etc/{passwd,shadow}: */
+//applet:IF_FEATURE_PASSWORD_POLICY(APPLET(pwage, BB_DIR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_FEATURE_PASSWORD_POLICY) += pwage.o
+
+//usage:#define pwage_trivial_usage
+//usage:       "[-cnxwde] [USER]"
+//usage:#define pwage_full_usage "\n\n"
+//usage:       "Get USER's password expiry information (default: current user)"
+//usage:     "\n"
+//usage:     "\n	-c	Get date of last change"
+//usage:     "\n	-n	Get min # of days between changes"
+//usage:     "\n	-x	Get max # of days between changes"
+//usage:     "\n	-w	Get # of days before password expires to warn user to change it"
+//usage:     "\n	-d	Get # of days after password expires until account is disabled"
+//usage:     "\n	-e	Get date when account expires"
+
+#include "libbb.h"
+#include <syslog.h>
+#include <uci.h>
+
+static int get_policy_value(struct uci_context *ctx, const char *option_name, int default_value) {
+	struct uci_ptr ptr;
+	char uci_path[64];
+	char *endptr;
+
+	snprintf(uci_path, sizeof(uci_path), "password_policy.@policy[0].%s", option_name);
+	if (uci_lookup_ptr(ctx, &ptr, uci_path, true) != UCI_OK || !ptr.o || !ptr.o->v.string) {
+		return default_value;
+	}
+	long value = strtol(ptr.o->v.string, &endptr, 10);
+	if (*endptr != '\0' || value < INT_MIN || value > INT_MAX) {
+		return default_value;
+	}
+
+	return (int)value;
+}
+
+int pwage_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int pwage_main(int argc UNUSED_PARAM, char **argv)
+{
+	enum {
+		OPT_lstchg   = (1 << 0), /* -c - date of last change */
+		OPT_min   = (1 << 1), /* -n - min # of days between changes */
+		OPT_max = (1 << 2), /* -x - max # of days between changes */
+		OPT_warn = (1 << 3), /* -w - # of days before password expires to warn user to change it */
+		OPT_inact = (1 << 4), /* -d - # of days after password expires until account is disabled */
+		OPT_expire = (1 << 5), /* -e - date when account expires */
+	};
+	unsigned opt;
+	char *myname;
+	char *name;
+	struct passwd *pw;
+	uid_t myuid;
+	struct uci_context *ctx;
+#if ENABLE_FEATURE_SHADOWPASSWDS
+	/* Using _r function to avoid pulling in static buffers */
+	struct spwd spw;
+	char buffer[256];
+#else
+	/* LOGMODE_BOTH */
+	bb_error_msg_and_die("Account information not supported without /etc/shadow");
+#endif
+
+	logmode = LOGMODE_BOTH;
+	openlog(applet_name, 0, LOG_AUTH);
+	opt = getopt32(argv, "cnxwde");
+	//argc -= optind;
+	argv += optind;
+
+	myuid = getuid();
+
+	/* Will complain and die if username not found */
+	myname = xstrdup(xuid2uname(myuid));
+	name = argv[0] ? argv[0] : myname;
+
+	pw = xgetpwnam(name);
+	if (myuid != 0 && pw->pw_uid != myuid) {
+		/* LOGMODE_BOTH */
+		bb_error_msg_and_die("%s can't get password information of %s", myname, name);
+	}
+
+#if ENABLE_FEATURE_SHADOWPASSWDS
+	/* getspnam_r may return 0 yet set result to NULL.
+		* At least glibc 2.4 does this. Be extra paranoid here. */
+	struct spwd *result = NULL;
+	errno = 0;
+	if (getspnam_r(pw->pw_name, &spw, buffer, sizeof(buffer), &result) != 0
+		|| !result /* no error, but no record found either */
+		|| strcmp(result->sp_namp, pw->pw_name) != 0 /* paranoia */
+	) {
+		if (errno != ENOENT) {
+			/* LOGMODE_BOTH */
+			bb_error_msg_and_die("no record of %s in %s",
+				name, bb_path_shadow_file);
+		} else {
+			/* LOGMODE_BOTH */
+			bb_error_msg_and_die("file %s not found", bb_path_shadow_file);
+		}
+	}
+
+	ctx = uci_alloc_context();
+	if (!ctx) {
+		/* LOGMODE_BOTH */
+		bb_error_msg_and_die("Failed to allocate UCI context");
+	}
+
+	int print_all = !(opt & (OPT_lstchg | OPT_min | OPT_max | OPT_warn | OPT_inact | OPT_expire));
+	if (print_all) {
+		printf("Account information for %s\n", name);
+	}
+	if (opt & OPT_lstchg || print_all) {
+		if (result->sp_lstchg != -1) {
+			printf("Last password change: %ld\n", (long)result->sp_lstchg);
+		} else if (print_all) {
+			printf("Last password change: N/A\n");
+		}
+	}
+	if (opt & OPT_min || print_all) {
+		if (result->sp_min != -1) {
+			printf("Minimum days required between password changes: %ld\n", (long)result->sp_min);
+		} else if (print_all) {
+			printf("Minimum days required between password changes: N/A\n");
+		}
+	}
+	if (opt & OPT_max || print_all) {
+		int password_lifetime = get_policy_value(ctx, "password_lifetime", 0);
+		if (password_lifetime != 0) {
+			printf("Maximum days password is valid: %d\n", password_lifetime);
+		} else if (result->sp_max != -1) {
+			printf("Maximum days password is valid: %ld\n", (long)result->sp_max);
+		} else if (print_all) {
+			printf("Maximum days password is valid: N/A\n");
+		}
+	}
+	if (opt & OPT_warn || print_all) {
+		if (result->sp_warn != -1) {
+			printf("Days before password is to expire that user is warned: %ld\n", (long)result->sp_warn);
+		} else if (print_all) {
+			printf("Days before password is to expire that user is warned: N/A\n");
+		}
+	}
+	if (opt & OPT_inact || print_all) {
+		if (result->sp_inact != -1) {
+			printf("Days after password expires that account is disabled: %ld\n", (long)result->sp_inact);
+		} else if (print_all) {
+			printf("Days after password expires that account is disabled: N/A\n");
+		}
+	}
+	if (opt & OPT_expire || print_all) {
+		if (result->sp_expire != -1) {
+			printf("Unix date when login expires: %ld\n", (long)result->sp_expire);
+		} else if (print_all) {
+			printf("Unix date when login expires: N/A\n");
+		}
+	}
+	uci_free_context(ctx);
+#endif
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		free(myname);
+
+	return 0;
+}
