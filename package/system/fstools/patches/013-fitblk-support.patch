--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -9,6 +9,7 @@ ADD_LIBRARY(fstools SHARED
 		libfstools/common.c
 		libfstools/snapshot.c
 		libfstools/extroot.c
+		libfstools/fit.c
 		libfstools/overlay.c
 		libfstools/volume.c
 		libfstools/mtd.c
--- a/block.c
+++ b/block.c
@@ -599,6 +599,7 @@ static void cache_load(int mtd)
 	_cache_load("/dev/vd*");
 	_cache_load("/dev/xvd*");
 	_cache_load("/dev/dm-*");
+	_cache_load("/dev/fit*");
 }
 
 
--- a/libfstools/common.c
+++ b/libfstools/common.c
@@ -113,18 +113,57 @@ int block_volume_format(struct volume *v
 {
 	int ret = 0;
 	char str[128];
+	unsigned int skip_blocks = 0;
+	int fd;
+	__u32 deadc0de;
+	size_t sz;
 
 	switch (volume_identify(v)) {
-	case FS_TARGZ:
-		snprintf(str, sizeof(str), "gzip -cd %s > /tmp/sysupgrade.tar", v->blk);
-		system(str);
-		/* fall-through */
+	case FS_DEADCODE:
 	case FS_NONE:
+		/* skip padding */
+		fd = open(v->blk, O_RDONLY);
+		if (fd < 0) {
+			ret = EIO;
+			break;
+		}
+		do {
+			if (lseek(fd, (skip_blocks + 1) * 512, SEEK_SET) == (off_t) -1) {
+				ret = EIO;
+				break;
+			}
+			sz = read(fd, &deadc0de, sizeof(deadc0de));
+			if (sz != sizeof(deadc0de)) {
+				ret = EIO;
+				break;
+			}
+		} while(++skip_blocks <= 512 &&
+			(deadc0de == cpu_to_be32(0xdeadc0de) || deadc0de == 0xffffffff));
+
+		close(fd);
+		if (ret)
+			break;
+
+		/* only try extracting in case gzip header is present */
+		if (deadc0de != cpu_to_le32(0x88b1f))
+			goto do_format;
+
+		/* fall-through */
+	case FS_TARGZ:
+		snprintf(str, sizeof(str),
+			 "dd if=%s bs=512 skip=%u 2>/dev/null  > /tmp/sysupgrade.tgz",
+			 v->blk, skip_blocks);
+		ret = system(str);
+		if (ret < 0) {
+			ULOG_ERR("failed extracting config backup from %s\n", v->blk);
+			break;
+		}
+do_format:
 		ULOG_INFO("overlay filesystem in %s has not been formatted yet\n", v->blk);
 		if (use_f2fs(v, offset, bdev))
-			snprintf(str, sizeof(str), "mkfs.f2fs -q -l rootfs_data %s", v->blk);
+			snprintf(str, sizeof(str), "mkfs.f2fs -q -f -l rootfs_data %s", v->blk);
 		else
-			snprintf(str, sizeof(str), "mkfs.ext4 -q -L rootfs_data %s", v->blk);
+			snprintf(str, sizeof(str), "mkfs.ext4 -q -F -L rootfs_data %s", v->blk);
 
 		ret = system(str);
 		break;
--- a/libfstools/common.h
+++ b/libfstools/common.h
@@ -25,3 +25,5 @@ int read_uint_from_file(char *dirname, c
 char *read_string_from_file(const char *dirname, const char *filename, char *buf, size_t bufsz);
 int block_file_identify(FILE *f, uint64_t offset);
 int block_volume_format(struct volume *v, uint64_t offset, const char *bdev);
+
+static const char *const block_dir_name = "/sys/class/block";
--- /dev/null
+++ b/libfstools/fit.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "common.h"
+
+#define BUFLEN 64
+#define DEVPATHSTR_SIZE 15
+
+static const char *const fit0 = "/dev/fit0";
+static const char *const fitrw = "/dev/fitrw";
+
+struct devpath {
+	char prefix[5];
+	char device[11];
+};
+
+struct fit_volume {
+	struct volume v;
+	union {
+		char devpathstr[DEVPATHSTR_SIZE+1];
+		struct devpath devpath;
+	} dev;
+};
+
+static struct driver fit_driver;
+
+static int fit_volume_identify(struct volume *v)
+{
+	struct fit_volume *p = container_of(v, struct fit_volume, v);
+	int ret = FS_NONE;
+	FILE *f;
+
+	f = fopen(p->dev.devpathstr, "r");
+	if (!f)
+		return ret;
+
+	ret = block_file_identify(f, 0);
+
+	fclose(f);
+
+	return ret;
+}
+
+static int fit_volume_init(struct volume *v)
+{
+	struct fit_volume *p = container_of(v, struct fit_volume, v);
+	char voldir[BUFLEN];
+	unsigned int volsize;
+
+	snprintf(voldir, sizeof(voldir), "%s/%s", block_dir_name, p->dev.devpath.device);
+
+	if (read_uint_from_file(voldir, "size", &volsize))
+		return -1;
+
+	v->type = BLOCKDEV;
+	v->size = volsize << 9; /* size is returned in sectors of 512 bytes */
+	v->blk = p->dev.devpathstr;
+
+	return block_volume_format(v, 0, p->dev.devpathstr);
+}
+
+static struct volume *fit_volume_find(char *name)
+{
+	struct fit_volume *p;
+	struct stat buf;
+	const char *fname;
+	int ret;
+
+	if (!strcmp(name, "rootfs"))
+		fname = fit0;
+	else if (!strcmp(name, "rootfs_data"))
+		fname = fitrw;
+	else
+		return NULL;
+
+	ret = stat(fname, &buf);
+	if (ret)
+		return NULL;
+
+	p = calloc(1, sizeof(struct fit_volume));
+	if (!p)
+		return NULL;
+
+	strncpy(p->dev.devpathstr, fname, DEVPATHSTR_SIZE);
+	p->v.drv = &fit_driver;
+	p->v.blk = p->dev.devpathstr;
+	p->v.name = name;
+
+	return &p->v;
+}
+
+static struct driver fit_driver = {
+	.name = "fit",
+	.priority = 30,
+	.find = fit_volume_find,
+	.init = fit_volume_init,
+	.identify = fit_volume_identify,
+};
+
+DRIVER(fit_driver);
--- a/libfstools/partname.c
+++ b/libfstools/partname.c
@@ -4,8 +4,6 @@
 
 #define BUFLEN 64
 
-const char *const block_dir_name = "/sys/class/block";
-
 struct devpath {
 	char prefix[5];
 	char device[11];
@@ -180,6 +178,7 @@ static struct volume *partname_volume_fi
 
 static struct driver partname_driver = {
 	.name = "partname",
+	.priority = 25,
 	.find = partname_volume_find,
 	.init = partname_volume_init,
 	.identify = partname_volume_identify,
