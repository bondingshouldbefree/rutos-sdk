--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -5480,6 +5480,10 @@ struct wpa_driver_ops {
 	bool (*can_share_drv)(void *ctx, struct wpa_init_params *params,
 			      void **hapd);
 
+	int (*frame_registration)(void *priv, u16 type,
+					  const u8 *match, size_t match_len,
+					  bool multicast, bool register_frame);
+
 #ifdef CONFIG_TESTING_OPTIONS
 	int (*register_frame)(void *priv, u16 type,
 			      const u8 *match, size_t match_len,
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -2493,6 +2493,35 @@ static int nl80211_register_frame(struct
 	return ret;
 }
 
+static int nl80211_unregister_frame(struct i802_bss *bss,
+				  struct nl_sock *nl_handle, u16 type)
+{
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	wpa_printf(MSG_DEBUG,
+		   "nl80211: Unregister frame type=0x%x (%s) nl_handle=%p",
+		   type, fc2str(type), nl_handle);
+
+	if (!(msg = nl80211_cmd_msg(bss, 0, NL80211_CMD_UNREGISTER_FRAME)) ||
+	    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE, type)) {
+		nlmsg_free(msg);
+		return -1;
+	}
+
+	ret = send_and_recv(drv, nl_handle, msg, NULL, NULL,
+			    NULL, NULL, NULL);
+
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "nl80211: Unregister frame command "
+			   "failed (type=%u): ret=%d (%s)",
+			   type, ret, strerror(-ret));
+	}
+
+	return ret;
+}
+
 
 static int nl80211_alloc_mgmt_handle(struct i802_bss *bss)
 {
@@ -2715,18 +2744,6 @@ static int nl80211_mgmt_subscribe_non_ap
 					  5) < 0)
 		ret = -1;
 
-	if (nl80211_register_frame(bss, bss->nl_mgmt, (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_PROBE_REQ << 4), NULL,
-				   0, false) < 0)
-		ret = -1;
-
-	if (nl80211_register_frame(bss, bss->nl_mgmt, (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_PROBE_RESP << 4), NULL,
-				   0, false) < 0)
-		ret = -1;
-
-	if (nl80211_register_frame(bss, bss->nl_mgmt, (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_BEACON << 4), NULL, 0,
-				   false) < 0)
-		ret = -1;
-
 	nl80211_mgmt_handle_register_eloop(bss);
 
 	return ret;
@@ -11895,6 +11912,26 @@ static int nl80211_del_ts(void *priv, u8
 	return ret;
 }
 
+static int nl80211_frame_registration(void *priv, u16 type,
+					  const u8 *match, size_t match_len,
+					  bool multicast, bool register_frame)
+{
+	struct i802_bss *bss = priv;
+	struct nl_sock *handle;
+	int ret;
+
+	if (!bss->nl_mgmt)
+		return -1;
+
+	handle = (void *) (((intptr_t) bss->nl_mgmt) ^ ELOOP_SOCKET_INVALID);
+
+	if(!register_frame)
+		return nl80211_unregister_frame(bss, handle, type);
+	 
+	return nl80211_register_frame(bss, handle, type, match, match_len,
+					multicast);
+}
+
 
 #ifdef CONFIG_TESTING_OPTIONS
 static int cmd_reply_handler(struct nl_msg *msg, void *arg)
@@ -15047,6 +15084,7 @@ const struct wpa_driver_ops wpa_driver_n
 #endif /* CONFIG_DPP */
 	.get_sta_mlo_info = nl80211_get_sta_mlo_info,
 	.link_add = nl80211_link_add,
+	.frame_registration = nl80211_frame_registration,
 #ifdef CONFIG_IEEE80211BE
 	.link_remove = driver_nl80211_link_remove,
 	.is_drv_shared = nl80211_is_drv_shared,
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -12112,6 +12112,33 @@ free_scs_desc:
 	return -1;
 }
 
+static int wpa_ctrl_frame_registration(struct wpa_supplicant *wpa_s,
+				       const char *cmd, bool register_frame)
+{
+	u16 type;
+	char *pos, *end;
+	u8 match[10];
+	size_t match_len;
+	bool multicast = false;
+	int ret;
+
+	type = strtol(cmd, &pos, 16);
+	if (*pos != ' ')
+		return -1;
+	pos++;
+	end = os_strchr(pos, ' ');
+	if (end) {
+		match_len = end - pos;
+		multicast = os_strstr(end, "multicast") != NULL;
+	} else {
+		match_len = os_strlen(pos) / 2;
+	}
+	if (hexstr2bin(pos, match, match_len))
+		return -1;
+
+	return wpa_drv_frame_registration(wpa_s, type, match, match_len, multicast, register_frame);
+}
+
 
 static int wpas_ctrl_iface_send_dscp_resp(struct wpa_supplicant *wpa_s,
 					  const char *cmd)
@@ -13864,6 +13891,12 @@ char * wpa_supplicant_ctrl_iface_process
 	} else if (os_strcmp(buf, "MLO_SIGNAL_POLL") == 0) {
 		reply_len = wpas_ctrl_iface_mlo_signal_poll(wpa_s, reply,
 							    reply_size);
+	} else if (os_strncmp(buf, "REGISTER_FRAME", 14) == 0) {
+		if (wpa_ctrl_frame_registration(wpa_s, buf + 15, true) < 0)
+			reply_len = -1;
+	} else if (os_strncmp(buf, "UNREGISTER_FRAME", 16) == 0) {
+		if (wpa_ctrl_frame_registration(wpa_s, buf + 17, false) < 0)
+			reply_len = -1;
 	} else if (os_strcmp(buf, "NEW_RANDOM_MAC_ADDRESS") == 0) {
 		enum wpas_mac_addr_style mac_addr_style =
 			wpa_s->conf->preassoc_mac_addr;
--- a/wpa_supplicant/driver_i.h
+++ b/wpa_supplicant/driver_i.h
@@ -1257,4 +1257,16 @@ wpas_drv_nan_cancel_subscribe(struct wpa
 						   subscribe_id);
 }
 
+static inline int
+wpa_drv_frame_registration(struct wpa_supplicant *wpa_s, u16 type,
+			   					const u8 *match, size_t match_len,
+			   					bool multicast, bool register_frame)
+{
+	if (!wpa_s->driver || !wpa_s->drv_priv || !wpa_s->driver->frame_registration)
+		return -1;
+
+	return wpa_s->driver->frame_registration(wpa_s->drv_priv, type, match, 
+						 match_len, multicast, register_frame);
+}
+
 #endif /* DRIVER_I_H */
--- a/wpa_supplicant/wpa_cli.c
+++ b/wpa_supplicant/wpa_cli.c
@@ -3313,6 +3313,17 @@ static int wpa_cli_cmd_dscp_query(struct
 }
 
 
+static int wpa_cli_cmd_register_frame(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	return wpa_cli_cmd(ctrl, "REGISTER_FRAME", 1, argc, argv);
+}
+
+
+static int wpa_cli_cmd_unregister_frame(struct wpa_ctrl *ctrl, int argc, char *argv[])
+{
+	return wpa_cli_cmd(ctrl, "UNREGISTER_FRAME", 1, argc, argv);
+}
+
 #ifdef CONFIG_NAN_USD
 
 static int wpa_cli_cmd_nan_publish(struct wpa_ctrl *ctrl, int argc,
@@ -3573,6 +3584,12 @@ static const struct wpa_cli_cmd wpa_cli_
 	{ "scan_results", wpa_cli_cmd_scan_results, NULL,
 	  cli_cmd_flag_none,
 	  "= get latest scan results" },
+	{ "register_frame", wpa_cli_cmd_register_frame, NULL,
+	  cli_cmd_flag_none,
+	  "= register management frame | <hex_flag> <match> <match_len> |" },
+	{ "unregister_frame", wpa_cli_cmd_unregister_frame, NULL,
+	  cli_cmd_flag_none,
+	  "= unregister management frame | <hex_flag> <match> <match_len> |" },
 	{ "abort_scan", wpa_cli_cmd_abort_scan, NULL,
 	  cli_cmd_flag_none,
 	  "= request ongoing scan to be aborted" },
