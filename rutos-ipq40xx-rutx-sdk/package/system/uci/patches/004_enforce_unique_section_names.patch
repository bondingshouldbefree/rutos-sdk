--- a/delta.c
+++ b/delta.c
@@ -211,49 +211,225 @@ error:
 	return 0;
 }

-static void uci_parse_delta_line(struct uci_context *ctx, struct uci_package *p)
+static void uci_parse_delta_line(struct uci_context *ctx, struct uci_package *p, int cmd, struct uci_ptr *ptr)
 {
 	struct uci_element *e = NULL;
-	struct uci_ptr ptr;
-	int cmd;
-
-	cmd = uci_parse_delta_tuple(ctx, &ptr);
-	if (strcmp(ptr.package, p->e.name) != 0)
-		goto error;

 	if (ctx->flags & UCI_FLAG_SAVED_DELTA)
-		uci_add_delta(ctx, &p->saved_delta, cmd, ptr.section, ptr.option, ptr.value);
+		uci_add_delta(ctx, &p->saved_delta, cmd, ptr->section, ptr->option, ptr->value);

 	switch(cmd) {
 	case UCI_CMD_REORDER:
-		uci_expand_ptr(ctx, &ptr, true);
-		if (!ptr.s)
+		uci_expand_ptr(ctx, ptr, true);
+		if (!ptr->s)
 			UCI_THROW(ctx, UCI_ERR_NOTFOUND);
-		UCI_INTERNAL(uci_reorder_section, ctx, ptr.s, strtoul(ptr.value, NULL, 10));
+		UCI_INTERNAL(uci_reorder_section, ctx, ptr->s, strtoul(ptr->value, NULL, 10));
 		break;
 	case UCI_CMD_RENAME:
-		UCI_INTERNAL(uci_rename, ctx, &ptr);
+		UCI_INTERNAL(uci_rename, ctx, ptr);
 		break;
 	case UCI_CMD_REMOVE:
-		UCI_INTERNAL(uci_delete, ctx, &ptr);
+		UCI_INTERNAL(uci_delete, ctx, ptr);
 		break;
 	case UCI_CMD_LIST_ADD:
-		UCI_INTERNAL(uci_add_list, ctx, &ptr);
+		UCI_INTERNAL(uci_add_list, ctx, ptr);
 		break;
 	case UCI_CMD_LIST_DEL:
-		UCI_INTERNAL(uci_del_list, ctx, &ptr);
+		UCI_INTERNAL(uci_del_list, ctx, ptr);
 		break;
 	case UCI_CMD_ADD:
 	case UCI_CMD_CHANGE:
-		UCI_INTERNAL(uci_set, ctx, &ptr);
-		e = ptr.last;
-		if (!ptr.option && e && (cmd == UCI_CMD_ADD))
+		UCI_INTERNAL(uci_set, ctx, ptr);
+		e = ptr->last;
+		if (!ptr->option && e && (cmd == UCI_CMD_ADD))
 			uci_to_section(e)->anonymous = true;
 		break;
 	}
-	return;
-error:
-	UCI_THROW(ctx, UCI_ERR_PARSE);
+}
+
+struct uci_parsed_delta {
+	int cmd;
+	struct uci_ptr ptr;
+};
+
+static int uci_find_rename_cmd(struct uci_parsed_delta *deltas, size_t count, size_t from, const char *from_name)
+{
+	for (size_t i = from; i < count; i++) {
+		int cmd = deltas[i].cmd;
+		if (cmd != UCI_CMD_RENAME) {
+			continue;
+		}
+
+		struct uci_ptr ptr = deltas[i].ptr;
+		if (!strcmp(ptr.section, from_name)) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static void uci_remove_parsed_delta(struct uci_parsed_delta *deltas, size_t *count, size_t index)
+{
+	(*count)--;
+	for (size_t i = index; i < *count; i++) {
+		deltas[i] = deltas[i+1];
+	}
+}
+
+static void uci_insert_parsed_delta(struct uci_parsed_delta *deltas, size_t *count, size_t index, struct uci_parsed_delta inserted)
+{
+	for (size_t i = *count; i > index; i--) {
+		deltas[i] = deltas[i - 1];
+	}
+	deltas[index] = inserted;
+	(*count)++;
+}
+
+static void uci_replace_section_names(struct uci_parsed_delta *deltas, size_t count, const char *from_name, const char *to_name)
+{
+	for (size_t i = 0; i < count; i++) {
+		struct uci_ptr *ptr = &deltas[i].ptr;
+		if (!strcmp(ptr->section, from_name)) {
+			ptr->section = to_name;
+		}
+	}
+}
+
+static int uci_parse_deltas_to_list(struct uci_context *ctx, struct uci_package *p, struct uci_parsed_delta **result_deltas, char ***result_buffer_lines)
+{
+	volatile int rc = -1;
+	struct uci_parse_context *pctx = ctx->pctx;
+
+	size_t capacity = 4;
+	size_t delta_count = 0;
+	struct uci_parsed_delta *deltas = NULL;
+	char **buffer_lines = NULL;
+
+	deltas = malloc(capacity * sizeof(struct uci_parsed_delta));
+	if (!deltas) {
+		goto done;
+	}
+
+	buffer_lines = malloc(capacity * sizeof(char *));
+	if (!buffer_lines) {
+		goto done;
+	}
+
+	while (!feof(pctx->file)) {
+		pctx->buf = NULL;
+		pctx->pos = 0;
+		uci_getln(ctx, pctx->pos);
+		if (!pctx->buf[pctx->pos]) {
+			continue;
+		}
+
+		struct uci_ptr ptr = { 0 };
+		int cmd = uci_parse_delta_tuple(ctx, &ptr);
+		if (strcmp(ptr.package, p->e.name) != 0) {
+			continue;
+		}
+
+		if (delta_count >= capacity) {
+			size_t larger_capacity = capacity * 1.5;
+
+			struct uci_parsed_delta *larger_deltas = realloc(deltas, larger_capacity * sizeof(struct uci_parsed_delta));
+			if (!larger_deltas) {
+				goto done;
+			}
+			deltas = larger_deltas;
+
+			char **larger_buffer_lines = realloc(buffer_lines, larger_capacity * sizeof(char *));
+			if (!larger_buffer_lines) {
+				goto done;
+			}
+			buffer_lines = larger_buffer_lines;
+
+			capacity = larger_capacity;
+		}
+
+		deltas[delta_count] = (struct uci_parsed_delta){
+			.cmd = cmd,
+			.ptr = ptr
+		};
+		buffer_lines[delta_count] = pctx->buf;
+		delta_count++;
+
+	}
+
+	(*result_deltas) = deltas;
+	(*result_buffer_lines) = buffer_lines;
+	rc = delta_count;
+done:
+	if (rc == -1) {
+		for (size_t i = 0; i < delta_count; i++) {
+			free(buffer_lines[i]);
+		}
+		free(buffer_lines);
+		free(deltas);
+	}
+	return rc;
+}
+
+// This section will return `true` if adding section needs to be skipped
+static bool uci_reorder_and_skip_renames(struct uci_context *ctx, struct uci_package *p, struct uci_parsed_delta *parsed_deltas, size_t *delta_count, size_t add_index)
+{
+	struct uci_ptr add_ptr = parsed_deltas[add_index].ptr;
+	const char *current_name = add_ptr.section;
+
+	size_t rename_from = add_index + 1;
+	while (true) {
+		int rename_index = uci_find_rename_cmd(parsed_deltas, *delta_count, rename_from, current_name);
+		if (rename_index == -1) {
+			break;
+		}
+
+		const char* new_name = parsed_deltas[rename_index].ptr.value;
+
+		// Update all of the uci change command up until the rename to use the new name,
+		// because the rename will be moved to before all of the deltas. So all of them need to
+		// use the new name
+		size_t replace_from = add_index + 1;
+		uci_replace_section_names(parsed_deltas + replace_from, rename_index - replace_from, current_name, new_name);
+
+		// Remove the rename command from the deltas. Because it might not be needed, because another
+		// delta will also rename this section again.
+		//
+		// If it is really needed, it will be added back to be right after the add command.
+		uci_remove_parsed_delta(parsed_deltas, delta_count, rename_index);
+
+		// Search for more rename commands from `rename_index`
+		rename_from = rename_index;
+		current_name = new_name;
+	}
+
+	if (current_name == add_ptr.section) {
+		// This section was not renamed, don't skip addint it
+		return false;
+	}
+
+	if (uci_lookup_list(&p->sections, current_name) != NULL) {
+		// A section with this name already exists, skip adding it
+		return true;
+	}
+
+	// This section was renamed and it doesn't exist, so add back a rename command to be right
+	// after the add command.
+	struct uci_parsed_delta rename_delta = {
+		.cmd = UCI_CMD_RENAME,
+		.ptr = {
+			.package = add_ptr.package,
+			.section = add_ptr.section,
+			.value = current_name
+		}
+	};
+
+	// Should be safe to append delta, will have memory allocated/available for it.
+	// Because if it got to this point, another rename delta had to be removed.
+	uci_insert_parsed_delta(parsed_deltas, delta_count, add_index + 1, rename_delta);
+
+	// Doesn't need to skip adding section
+	return false;
 }

 /* returns the number of changes that were successfully parsed */
@@ -269,24 +445,44 @@ static int uci_parse_delta(struct uci_context *ctx, FILE *stream, struct uci_pac
 	ctx->pctx = pctx;
 	pctx->file = stream;

-	while (!feof(pctx->file)) {
-		pctx->pos = 0;
-		uci_getln(ctx, 0);
-		if (!pctx->buf[0])
-			continue;
+	size_t i = 0;
+	size_t delta_count = 0;
+	struct uci_parsed_delta *parsed_deltas = NULL;
+	char **lines = NULL;
+	int line_count = uci_parse_deltas_to_list(ctx, p, &parsed_deltas, &lines);
+	if (line_count == -1) {
+		goto error;
+	}
+
+	delta_count = line_count;
+
+	for (i = 0; i < delta_count; i++) {
+		int cmd = parsed_deltas[i].cmd;
+		struct uci_ptr ptr = parsed_deltas[i].ptr;
+
+		if (ctx->enforce_unique_section_names && cmd == UCI_CMD_ADD) {
+			if (uci_reorder_and_skip_renames(ctx, p, parsed_deltas, &delta_count, i)) {
+				continue;
+			}
+		}

 		/*
 		 * ignore parse errors in single lines, we want to preserve as much
 		 * delta as possible
 		 */
 		UCI_TRAP_SAVE(ctx, error);
-		uci_parse_delta_line(ctx, p);
+		uci_parse_delta_line(ctx, p, cmd, &ptr);
 		UCI_TRAP_RESTORE(ctx);
 		changes++;
 error:
 		continue;
 	}

+	for (int i = 0; i < line_count; i++) {
+		free(lines[i]);
+	}
+	free(lines);
+	free(parsed_deltas);
 	/* no error happened, we can get rid of the parser context now */
 	uci_cleanup(ctx);
 	return changes;
--- a/list.c
+++ b/list.c
@@ -526,6 +526,10 @@ int uci_rename(struct uci_context *ctx, struct uci_ptr *ptr)
 	UCI_ASSERT(ctx, ptr->s);
 	UCI_ASSERT(ctx, ptr->value);

+	if (ctx->enforce_unique_section_names && uci_lookup_list(&p->sections, ptr->value) != NULL) {
+		UCI_THROW(ctx, UCI_ERR_INVAL);
+	}
+
 	if (!internal && p->has_delta)
 		uci_add_delta(ctx, &p->delta, UCI_CMD_RENAME, ptr->section, ptr->option, ptr->value);

--- a/lua/uci.c
+++ b/lua/uci.c
@@ -822,8 +822,18 @@ uci_lua_add_change(lua_State *L, struct uci_element *e)

 		lua_pop(L, 1);
 	} else {
-		lua_pushstring(L, value);
-		lua_setfield(L, -2, ".type");
+		if (h->cmd == UCI_CMD_RENAME) {
+			// remove section from package table
+			lua_pushnil(L);
+			lua_setfield(L, -3, h->section);
+
+			// add section to package table with different name
+			lua_pushvalue(L, -1); /* copy for setfield */
+			lua_setfield(L, -3, value);
+		} else {
+			lua_pushstring(L, value);
+			lua_setfield(L, -2, ".type");
+		}
 	}

 	lua_pop(L, 1);
@@ -946,6 +956,15 @@ uci_was_empty_commit(lua_State *L)
 	return 1;
 }

+static int
+uci_set_enforce_unique_section_names(lua_State *L)
+{
+	int offset = 0;
+	struct uci_context *ctx = find_context(L, &offset);
+	ctx->enforce_unique_section_names = lua_toboolean(L, 1 + offset);
+	return uci_push_status(L, ctx, false);
+}
+
 static int
 uci_lua_set_savedir(lua_State *L)
 {
@@ -1053,6 +1072,7 @@ static const luaL_Reg uci[] = {
 	{ "set_savedir", uci_lua_set_savedir },
 	{ "list_configs", uci_lua_list_configs },
 	{ "was_empty_commit", uci_was_empty_commit },
+	{ "set_enforce_unique_section_names", uci_set_enforce_unique_section_names },
 	{ NULL, NULL },
 };

--- a/uci.h
+++ b/uci.h
@@ -420,6 +420,7 @@ struct uci_context
 	struct uci_list delta_path;

 	bool was_empty_commit;
+	bool enforce_unique_section_names;

 	/* private: */
 	int err;
