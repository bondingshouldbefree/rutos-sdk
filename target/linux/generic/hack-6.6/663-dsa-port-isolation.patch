From 29135536a183a1b356771fbe93b2aa1e319bbff7 Mon Sep 17 00:00:00 2001
From: Joris Vaisvila <joris.vaisvila@teltonika.lt>
Date: Tue, 3 Dec 2024 16:24:52 +0200
Subject: [PATCH 1/1] dsa port isolation

---
 include/linux/uidgid.h |    2 +
 include/net/dsa.h      |    3 +
 net/dsa/port.c         |   41 +++++++++++++++--------
 net/dsa/slave.c        |   84 +++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 116 insertions(+), 14 deletions(-)

--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -325,6 +325,9 @@ struct dsa_port {
 		 */
 		struct list_head	user_vlans;
 	};
+
+	bool			isolated;
+	struct net_device 	*isolated_br;
 };
 
 static inline struct dsa_port *
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@ -496,6 +496,11 @@ int dsa_port_bridge_join(struct dsa_port
 	if (br_mst_enabled(br) && !dsa_port_supports_mst(dp))
 		return -EOPNOTSUPP;
 
+	if (dp->isolated) {
+		dp->isolated_br = br;
+		return 0;
+	}
+
 	/* Here the interface is already bridged. Reflect the current
 	 * configuration so that drivers can program their chips accordingly.
 	 */
@@ -510,6 +515,10 @@ int dsa_port_bridge_join(struct dsa_port
 	if (err)
 		goto out_rollback;
 
+	err = dsa_port_switchdev_sync_attrs(dp, extack);
+	if (err)
+		goto out_rollback_unbridge;
+
 	/* Drivers which support bridge TX forwarding should set this */
 	dp->bridge->tx_fwd_offload = info.tx_fwd_offload;
 
@@ -518,18 +527,12 @@ int dsa_port_bridge_join(struct dsa_port
 					    &dsa_slave_switchdev_blocking_notifier,
 					    dp->bridge->tx_fwd_offload, extack);
 	if (err)
-		goto out_rollback_unbridge;
-
-	err = dsa_port_switchdev_sync_attrs(dp, extack);
-	if (err)
-		goto out_rollback_unoffload;
+		goto out_rollback_unsync;
 
 	return 0;
 
-out_rollback_unoffload:
-	switchdev_bridge_port_unoffload(brport_dev, dp,
-					&dsa_slave_switchdev_notifier,
-					&dsa_slave_switchdev_blocking_notifier);
+out_rollback_unsync:
+	dsa_port_switchdev_unsync_attrs(dp, info.bridge);
 	dsa_flush_workqueue();
 out_rollback_unbridge:
 	dsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);
@@ -542,6 +545,12 @@ void dsa_port_pre_bridge_leave(struct ds
 {
 	struct net_device *brport_dev = dsa_port_to_bridge_port(dp);
 
+	if (dp->isolated) {
+		WARN_ON(br && dp->isolated_br != br);
+		return;
+	}
+	WARN_ON(dsa_port_bridge_dev_get(dp) != br);
+
 	/* Don't try to unoffload something that is not offloaded */
 	if (!brport_dev)
 		return;
@@ -560,6 +569,13 @@ void dsa_port_bridge_leave(struct dsa_po
 	};
 	int err;
 
+	if (dp->isolated) {
+		WARN_ON(br && dp->isolated_br != br);
+		dp->isolated_br = NULL;
+		return;
+	}
+	WARN_ON(dsa_port_bridge_dev_get(dp) != br);
+
 	/* If the port could not be offloaded to begin with, then
 	 * there is nothing to do.
 	 */
@@ -692,9 +708,7 @@ err_lag_create:
 void dsa_port_pre_lag_leave(struct dsa_port *dp, struct net_device *lag_dev)
 {
 	struct net_device *br = dsa_port_bridge_dev_get(dp);
-
-	if (br)
-		dsa_port_pre_bridge_leave(dp, br);
+	dsa_port_pre_bridge_leave(dp, br);
 }
 
 void dsa_port_lag_leave(struct dsa_port *dp, struct net_device *lag_dev)
@@ -711,8 +725,7 @@ void dsa_port_lag_leave(struct dsa_port
 	/* Port might have been part of a LAG that in turn was
 	 * attached to a bridge.
 	 */
-	if (br)
-		dsa_port_bridge_leave(dp, br);
+	dsa_port_bridge_leave(dp, br);
 
 	info.lag = *dp->lag;
 
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -2591,6 +2591,80 @@ int dsa_slave_resume(struct net_device *
 	return 0;
 }
 
+static ssize_t isolation_show(struct device *d, struct device_attribute *attr,
+			      char *buf)
+{
+	bool isolated;
+	struct net_device *dev = to_net_dev(d);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	if (!rtnl_trylock())
+		return restart_syscall();
+	isolated = dp->isolated;
+	rtnl_unlock();
+	return sprintf(buf, "%c\n", isolated ? 'Y' : 'N');
+}
+
+static ssize_t isolation_store(struct device *d, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	bool bv;
+	int err;
+	struct net_device *dev = to_net_dev(d);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct net_device *br;
+
+	err = kstrtobool(buf, &bv);
+	if (err)
+		return err;
+
+	if (!rtnl_trylock())
+		return restart_syscall();
+
+	if (dp->isolated == bv)
+		goto out_unlock;
+
+	if (bv) {
+		// Enable isolation
+
+		br = dsa_port_bridge_dev_get(dp);
+		if (br) {
+			// Remove exisiting bridge
+			dsa_port_pre_bridge_leave(dp, br);
+			dsa_port_bridge_leave(dp, br);
+		}
+		dp->isolated = true;
+		dp->isolated_br = br;
+	} else {
+		// Disable isolation
+
+		br = dp->isolated_br;
+		dp->isolated = false;
+		dp->isolated_br = NULL;
+		if (br) {
+			// Restore existing bridge
+			dsa_port_bridge_join(dp, br, NULL);
+		}
+	}
+
+out_unlock:
+	rtnl_unlock();
+	if (err)
+		return err;
+	return count;
+}
+
+static DEVICE_ATTR(isolation, 0664, isolation_show, isolation_store);
+
+static struct attribute *dsa_slave_attrs[] = {
+	&dev_attr_isolation.attr,
+	NULL
+};
+
+static const struct attribute_group port_group = {
+	.name = "dsa_port",
+	.attrs = dsa_slave_attrs,
+};
+
 int dsa_slave_create(struct dsa_port *port)
 {
 	struct net_device *master = dsa_port_to_master(port);
@@ -2699,6 +2773,13 @@ int dsa_slave_create(struct dsa_port *po
 	if (ret)
 		goto out_unregister;
 
+	if (dsa_is_user_port(ds, port->index)) {
+		ret = sysfs_create_group(&slave_dev->dev.kobj, &port_group);
+		sysfs_group_change_owner(&slave_dev->dev.kobj, &port_group, GLOBAL_ROOT_UID, GLOBAL_DOT1X_GID);
+	}
+	if (ret)
+		goto out_unregister;
+
 	return 0;
 
 out_unregister:
@@ -2723,6 +2804,9 @@ void dsa_slave_destroy(struct net_device
 	struct dsa_port *dp = dsa_slave_to_port(slave_dev);
 	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 
+	if (dsa_is_user_port(dp->ds, dp->index))
+		sysfs_remove_group(&slave_dev->dev.kobj, &port_group);
+
 	netif_carrier_off(slave_dev);
 	rtnl_lock();
 	netdev_upper_dev_unlink(master, slave_dev);
--- a/include/linux/uidgid.h
+++ b/include/linux/uidgid.h
@@ -55,6 +55,8 @@ static inline gid_t __kgid_val(kgid_t gi
 #define GLOBAL_ROOT_UID KUIDT_INIT(0)
 #define GLOBAL_ROOT_GID KGIDT_INIT(0)
 
+#define GLOBAL_DOT1X_GID KGIDT_INIT(596)
+
 #define GLOBAL_LEDS_GID KGIDT_INIT(900)
 #define GLOBAL_GPIO_GID KGIDT_INIT(901)
 #define GLOBAL_MNF_SEC_GID KGIDT_INIT(902)
